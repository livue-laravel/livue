{"version":3,"file":"livue.esm.js","sources":["../resources/js/runtime/helpers/csrf.js","../resources/js/runtime/helpers/progress.js","../resources/js/runtime/features/navigation.js","../resources/js/runtime/helpers/hooks.js","../resources/js/runtime/features/request/pool.js","../resources/js/runtime/features/request/request.js","../resources/js/runtime/core/state.js","../resources/js/runtime/helpers/errors.js","../resources/js/runtime/core/registry.js","../resources/js/runtime/features/echo.js","../resources/js/runtime/devtools/index.js","../resources/js/runtime/features/events.js","../resources/js/runtime/features/url.js","../resources/js/runtime/features/upload.js","../node_modules/pinia/dist/pinia.mjs","../resources/js/runtime/features/lazy.js","../resources/js/runtime/helpers/modifiers.js","../resources/js/runtime/features/broadcast.js","../resources/js/runtime/directives/transition.js","../resources/js/runtime/features/request/stream.js","../resources/js/runtime/features/composables.js","../resources/js/runtime/core/component.js","../resources/js/runtime/directives/init.js","../resources/js/runtime/directives/submit.js","../resources/js/runtime/directives/intersect.js","../resources/js/runtime/directives/current.js","../resources/js/runtime/directives/ignore.js","../resources/js/runtime/directives/model.js","../resources/js/runtime/directives/poll.js","../resources/js/runtime/directives/offline.js","../resources/js/runtime/directives/replace.js","../resources/js/runtime/directives/loading.js","../resources/js/runtime/directives/target.js","../resources/js/runtime/directives/stream.js","../resources/js/runtime/directives/click.js","../resources/js/runtime/directives/navigate.js","../resources/js/runtime/directives/scroll.js","../resources/js/runtime/directives/dirty.js","../resources/js/runtime/directives/watch.js","../resources/js/runtime/directives/model-modifiers.js","../node_modules/sortablejs/modular/sortable.esm.js","../resources/js/runtime/directives/sort.js","../resources/js/runtime/directives/index.js","../resources/js/runtime/features/hmr/hmr-indicator.js","../resources/js/runtime/features/hmr/hmr.js","../resources/js/runtime/core/runtime.js","../resources/js/livue-esm.js"],"sourcesContent":["/**\n * CSRF token helper for LiVue AJAX requests.\n */\n\nlet cachedToken = null;\n\n/**\n * Get the CSRF token from the page meta tag or XSRF-TOKEN cookie.\n */\nexport function getToken() {\n    if (cachedToken) {\n        return cachedToken;\n    }\n\n    // Try meta tag first (Laravel default)\n    const meta = document.querySelector('meta[name=\"csrf-token\"]');\n\n    if (meta) {\n        cachedToken = meta.getAttribute('content');\n        return cachedToken;\n    }\n\n    // Fallback: read from XSRF-TOKEN cookie\n    const match = document.cookie.match(/XSRF-TOKEN=([^;]+)/);\n\n    if (match) {\n        cachedToken = decodeURIComponent(match[1]);\n        return cachedToken;\n    }\n\n    return null;\n}\n\n/**\n * Clear the cached token (useful if token is rotated).\n */\nexport function clearToken() {\n    cachedToken = null;\n}\n","/**\n * Progress bar for LiVue AJAX requests.\n * Inspired by NProgress - shows a thin progress bar at the top of the page.\n */\n\nlet _config = {\n    color: '#29d',\n    height: '2px',\n    showSpinner: true,\n    minimum: 0.08,\n    easing: 'ease',\n    speed: 200,\n    trickle: true,\n    trickleSpeed: 200,\n    parent: 'body',\n};\n\nlet _status = null;      // null = hidden, number = progress (0-1)\nlet _trickleTimer = null;\nlet _barEl = null;\nlet _spinnerEl = null;\nlet _stylesInjected = false;\nlet _pendingCount = 0;   // Track concurrent requests\n\n/**\n * Clamp a number between min and max.\n */\nfunction clamp(n, min, max) {\n    if (n < min) return min;\n    if (n > max) return max;\n    return n;\n}\n\n/**\n * Convert progress (0-1) to CSS translate percentage.\n */\nfunction toBarPercent(n) {\n    return (-1 + n) * 100;\n}\n\n/**\n * Inject CSS styles for the progress bar.\n */\nfunction injectStyles() {\n    if (_stylesInjected) return;\n    _stylesInjected = true;\n\n    let style = document.createElement('style');\n    style.id = 'livue-progress-styles';\n    style.textContent = `\n        .livue-progress-bar {\n            position: fixed;\n            z-index: 99999;\n            top: 0;\n            left: 0;\n            width: 100%;\n            height: ${_config.height};\n            background: ${_config.color};\n            transform: translate3d(-100%, 0, 0);\n            transition: transform ${_config.speed}ms ${_config.easing};\n            pointer-events: none;\n        }\n        .livue-progress-peg {\n            position: absolute;\n            right: 0;\n            width: 100px;\n            height: 100%;\n            box-shadow: 0 0 10px ${_config.color}, 0 0 5px ${_config.color};\n            opacity: 1;\n            transform: rotate(3deg) translate(0px, -4px);\n        }\n        .livue-progress-spinner {\n            display: block;\n            position: fixed;\n            z-index: 99999;\n            top: 15px;\n            right: 15px;\n            pointer-events: none;\n        }\n        .livue-progress-spinner-icon {\n            width: 18px;\n            height: 18px;\n            border: solid 2px transparent;\n            border-top-color: ${_config.color};\n            border-left-color: ${_config.color};\n            border-radius: 50%;\n            animation: livue-spinner 400ms linear infinite;\n        }\n        .livue-progress-bar.livue-progress-hidden,\n        .livue-progress-spinner.livue-progress-hidden {\n            opacity: 0;\n            transition: opacity ${_config.speed}ms ${_config.easing};\n        }\n        @keyframes livue-spinner {\n            0% { transform: rotate(0deg); }\n            100% { transform: rotate(360deg); }\n        }\n    `;\n    document.head.appendChild(style);\n}\n\n/**\n * Create DOM elements for the progress bar.\n */\nfunction createElements() {\n    if (_barEl) return;\n\n    injectStyles();\n\n    // Create bar\n    _barEl = document.createElement('div');\n    _barEl.className = 'livue-progress-bar livue-progress-hidden';\n    _barEl.innerHTML = '<div class=\"livue-progress-peg\"></div>';\n\n    // Create spinner\n    if (_config.showSpinner) {\n        _spinnerEl = document.createElement('div');\n        _spinnerEl.className = 'livue-progress-spinner livue-progress-hidden';\n        _spinnerEl.innerHTML = '<div class=\"livue-progress-spinner-icon\"></div>';\n    }\n\n    let parent = document.querySelector(_config.parent) || document.body;\n    parent.appendChild(_barEl);\n    if (_spinnerEl) parent.appendChild(_spinnerEl);\n}\n\n/**\n * Update styles when config changes.\n */\nfunction updateStyles() {\n    if (!_stylesInjected) return;\n\n    let style = document.getElementById('livue-progress-styles');\n    if (style) {\n        style.remove();\n        _stylesInjected = false;\n        injectStyles();\n    }\n}\n\n/**\n * Configure progress bar options.\n *\n * @param {object} options\n * @param {string} [options.color] - Bar color (default: '#29d')\n * @param {string} [options.height] - Bar height (default: '2px')\n * @param {boolean} [options.showSpinner] - Show spinner icon (default: true)\n * @param {number} [options.minimum] - Minimum starting value (default: 0.08)\n * @param {string} [options.easing] - CSS easing function (default: 'ease')\n * @param {number} [options.speed] - Animation speed ms (default: 200)\n * @param {boolean} [options.trickle] - Auto-advance progress (default: true)\n * @param {number} [options.trickleSpeed] - Trickle interval ms (default: 200)\n * @param {string} [options.parent] - Parent element selector (default: 'body')\n */\nexport function configure(options) {\n    Object.assign(_config, options);\n    updateStyles();\n}\n\n/**\n * Start the progress bar.\n * Multiple concurrent starts are tracked - only first shows the bar,\n * and only last done() hides it.\n */\nexport function start() {\n    _pendingCount++;\n\n    if (_status !== null) {\n        // Already showing, just track the new request\n        return;\n    }\n\n    createElements();\n    _status = 0;\n\n    // Show elements\n    if (_barEl) {\n        _barEl.classList.remove('livue-progress-hidden');\n    }\n    if (_spinnerEl) {\n        _spinnerEl.classList.remove('livue-progress-hidden');\n    }\n\n    set(_config.minimum);\n\n    if (_config.trickle) {\n        _trickleTimer = setInterval(function () {\n            trickle();\n        }, _config.trickleSpeed);\n    }\n}\n\n/**\n * Set the progress bar to a specific value.\n *\n * @param {number} n - Progress value (0-1)\n */\nexport function set(n) {\n    if (_status === null) return;\n\n    n = clamp(n, _config.minimum, 1);\n    _status = n;\n\n    if (_barEl) {\n        _barEl.style.transform = 'translate3d(' + toBarPercent(n) + '%, 0, 0)';\n    }\n}\n\n/**\n * Increment progress by a small amount.\n * Amount decreases as progress approaches 1.\n */\nexport function trickle() {\n    if (_status === null || _status >= 1) return;\n\n    let amount;\n    if (_status < 0.2) amount = 0.1;\n    else if (_status < 0.5) amount = 0.04;\n    else if (_status < 0.8) amount = 0.02;\n    else if (_status < 0.99) amount = 0.005;\n    else amount = 0;\n\n    set(_status + amount);\n}\n\n/**\n * Complete the progress bar.\n * Only actually hides when all pending requests are done.\n */\nexport function done() {\n    _pendingCount = Math.max(0, _pendingCount - 1);\n\n    if (_pendingCount > 0) {\n        // Still have pending requests\n        return;\n    }\n\n    if (_status === null) return;\n\n    // Complete the bar\n    set(1);\n    clearInterval(_trickleTimer);\n    _trickleTimer = null;\n\n    // Fade out after animation completes\n    setTimeout(function () {\n        if (_barEl) {\n            _barEl.classList.add('livue-progress-hidden');\n        }\n        if (_spinnerEl) {\n            _spinnerEl.classList.add('livue-progress-hidden');\n        }\n\n        // Reset position after fade\n        setTimeout(function () {\n            _status = null;\n            if (_barEl) {\n                _barEl.style.transform = 'translate3d(-100%, 0, 0)';\n            }\n        }, _config.speed);\n    }, _config.speed);\n}\n\n/**\n * Force complete, ignoring pending count.\n */\nexport function forceDone() {\n    _pendingCount = 0;\n    done();\n}\n\n/**\n * Check if progress bar is currently showing.\n *\n * @returns {boolean}\n */\nexport function isStarted() {\n    return _status !== null;\n}\n\n/**\n * Get current progress value.\n *\n * @returns {number|null}\n */\nexport function getStatus() {\n    return _status;\n}\n\nexport default {\n    configure,\n    start,\n    set,\n    trickle,\n    done,\n    forceDone,\n    isStarted,\n    getStatus,\n};\n","/**\n * Navigation module for LiVue.\n *\n * Handles redirects (full page reload) and SPA navigation\n * (fetch + DOM swap + history push + LiVue reboot).\n *\n * Features:\n * - Prefetching: preload pages on hover/mousedown\n * - Page caching: instant back/forward navigation\n * - @persist: preserve DOM elements across navigations\n * - Scroll restoration: restore scroll position on back/forward\n * - Progress bar: visual loading indicator during navigation\n */\n\nimport { clearToken } from '../helpers/csrf.js';\nimport progress from '../helpers/progress.js';\n\n/**\n * Reference to the LiVue runtime, set during init.\n * @type {object|null}\n */\nvar _runtime = null;\n\n/**\n * Whether navigation has been initialized.\n * @type {boolean}\n */\nvar _initialized = false;\n\n/**\n * Whether a SPA navigation is currently in progress.\n * Prevents double execution when both pool.js and component.js detect a redirect.\n * @type {boolean}\n */\nvar _navigating = false;\n\n/**\n * Configuration for navigation behavior.\n * @type {object}\n */\nvar _config = {\n    showProgressBar: true,\n    progressBarColor: '#29d',\n    prefetch: true,\n    prefetchOnHover: true,\n    hoverDelay: 60,\n    cachePages: true,\n    maxCacheSize: 10,\n    restoreScroll: true,\n};\n\n/**\n * Cache of fetched pages for instant back/forward navigation.\n * Key: URL, Value: { html: string, title: string, scroll: { x: number, y: number }, timestamp: number }\n * @type {Map<string, object>}\n */\nvar _pageCache = new Map();\n\n/**\n * Map of URLs currently being prefetched.\n * @type {Map<string, Promise<string>>}\n */\nvar _prefetching = new Map();\n\n/**\n * Hover timers for prefetch delay.\n * @type {WeakMap<HTMLElement, number>}\n */\nvar _hoverTimers = new WeakMap();\n\n/**\n * Saved scroll positions for pages.\n * @type {Map<string, { x: number, y: number }>}\n */\nvar _scrollPositions = new Map();\n\n/**\n * Current page key for scroll tracking.\n * @type {string|null}\n */\nvar _currentPageKey = null;\n\n/**\n * Configure navigation options.\n *\n * @param {object} options\n * @param {boolean} [options.showProgressBar] - Show progress bar during navigation (default: true)\n * @param {string} [options.progressBarColor] - Progress bar color (default: '#29d')\n * @param {boolean} [options.prefetch] - Enable prefetching (default: true)\n * @param {boolean} [options.prefetchOnHover] - Prefetch on hover vs mousedown only (default: true)\n * @param {number} [options.hoverDelay] - Hover delay before prefetch in ms (default: 60)\n * @param {boolean} [options.cachePages] - Cache pages for back/forward (default: true)\n * @param {number} [options.maxCacheSize] - Max cached pages (default: 10)\n * @param {boolean} [options.restoreScroll] - Restore scroll position on back/forward (default: true)\n */\nexport function configure(options) {\n    Object.assign(_config, options);\n\n    if (options.progressBarColor) {\n        progress.configure({ color: options.progressBarColor });\n    }\n}\n\n/**\n * Initialize the navigation module.\n * Sets initial history state and listens for popstate.\n *\n * @param {object} runtime - The LiVueRuntime instance\n */\nexport function initNavigation(runtime) {\n    _runtime = runtime;\n\n    if (_initialized) {\n        return;\n    }\n    _initialized = true;\n\n    // Generate a unique key for the current page\n    _currentPageKey = generatePageKey();\n\n    // Set initial history state so popstate can return here\n    history.replaceState(\n        { livueNavigate: true, url: location.href, pageKey: _currentPageKey },\n        '',\n        location.href\n    );\n\n    // Listen for browser back/forward\n    window.addEventListener('popstate', function (event) {\n        if (event.state && event.state.livueNavigate) {\n            // Save current scroll before leaving\n            saveScrollPosition(_currentPageKey);\n\n            _currentPageKey = event.state.pageKey;\n            navigateTo(event.state.url, false, true);\n        }\n    });\n\n    // Set up global link handlers for prefetching\n    setupPrefetching();\n}\n\n/**\n * Generate a unique page key for scroll tracking.\n * @returns {string}\n */\nfunction generatePageKey() {\n    return location.href + '#' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);\n}\n\n/**\n * Save scroll position for a page key.\n * @param {string} pageKey\n */\nfunction saveScrollPosition(pageKey) {\n    if (!_config.restoreScroll || !pageKey) {\n        return;\n    }\n\n    _scrollPositions.set(pageKey, {\n        x: window.scrollX,\n        y: window.scrollY,\n    });\n\n    // Also save individual scroll positions for elements with data-livue-scroll\n    var scrollElements = document.querySelectorAll('[data-livue-scroll]');\n    scrollElements.forEach(function (el) {\n        var key = el.dataset.livueScroll || el.id;\n        if (key) {\n            var pos = _scrollPositions.get(pageKey) || {};\n            pos['el:' + key] = { x: el.scrollLeft, y: el.scrollTop };\n            _scrollPositions.set(pageKey, pos);\n        }\n    });\n}\n\n/**\n * Restore scroll position for a page key.\n * @param {string} pageKey\n */\nfunction restoreScrollPosition(pageKey) {\n    if (!_config.restoreScroll || !pageKey) {\n        return;\n    }\n\n    var pos = _scrollPositions.get(pageKey);\n\n    if (pos) {\n        // Use requestAnimationFrame to ensure DOM is ready\n        requestAnimationFrame(function () {\n            window.scrollTo(pos.x || 0, pos.y || 0);\n\n            // Restore individual element scroll positions\n            Object.keys(pos).forEach(function (key) {\n                if (key.startsWith('el:')) {\n                    var elKey = key.substring(3);\n                    var el = document.querySelector('[data-livue-scroll=\"' + elKey + '\"]')\n                        || document.getElementById(elKey);\n                    if (el) {\n                        el.scrollLeft = pos[key].x || 0;\n                        el.scrollTop = pos[key].y || 0;\n                    }\n                }\n            });\n        });\n    }\n}\n\n/**\n * Set up event listeners for prefetching and navigation.\n */\nfunction setupPrefetching() {\n    // Global click handler for v-navigate links (more robust than per-element listeners)\n    document.addEventListener('click', handleGlobalClick, true);\n\n    if (!_config.prefetch) {\n        return;\n    }\n\n    // Use event delegation on document for efficiency\n    document.addEventListener('mouseenter', handleMouseEnter, true);\n    document.addEventListener('mouseleave', handleMouseLeave, true);\n    document.addEventListener('mousedown', handleMouseDown, true);\n    document.addEventListener('focus', handleFocus, true);\n}\n\n/**\n * Global click handler for v-navigate links.\n * Uses event delegation so it works even when elements are moved in the DOM.\n *\n * @param {Event} event\n */\nfunction handleGlobalClick(event) {\n    if (!event.target || typeof event.target.closest !== 'function') {\n        return;\n    }\n\n    var el = event.target.closest('a[data-livue-navigate], a[v-navigate]');\n\n    if (!el) {\n        return;\n    }\n\n    // Ignore if modifier keys are pressed\n    if (event.metaKey || event.ctrlKey || event.shiftKey || event.altKey) {\n        return;\n    }\n\n    // Ignore right-click\n    if (event.button !== 0) {\n        return;\n    }\n\n    var href = el.getAttribute('href');\n\n    if (!href) {\n        return;\n    }\n\n    // Ignore external links\n    try {\n        var url = new URL(href, window.location.origin);\n        if (url.origin !== window.location.origin) {\n            return;\n        }\n    } catch (e) {\n        return;\n    }\n\n    // Ignore anchor links\n    if (href.startsWith('#')) {\n        return;\n    }\n\n    // Ignore javascript: links\n    if (href.startsWith('javascript:')) {\n        return;\n    }\n\n    // Ignore download links\n    if (el.hasAttribute('download')) {\n        return;\n    }\n\n    // Ignore target=\"_blank\" links\n    if (el.getAttribute('target') === '_blank') {\n        return;\n    }\n\n    event.preventDefault();\n    event.stopPropagation();\n\n    console.log('[v-navigate global] Navigating to:', href);\n\n    // Navigate via LiVue SPA navigation\n    navigateTo(href, true, false);\n}\n\n/**\n * Check if an element is a navigate link.\n * @param {HTMLElement} el\n * @returns {boolean}\n */\nfunction isNavigateLink(el) {\n    if (el.tagName !== 'A') {\n        return false;\n    }\n\n    // Check for v-navigate attribute\n    if (el.hasAttribute('data-livue-navigate') || el.hasAttribute('v-navigate')) {\n        return true;\n    }\n\n    return false;\n}\n\n/**\n * Get the navigate mode from a link.\n * @param {HTMLElement} el\n * @returns {string} 'mousedown' (default) or 'hover'\n */\nfunction getNavigateMode(el) {\n    var mode = el.dataset.livueNavigateMode;\n\n    if (mode === 'hover') {\n        return 'hover';\n    }\n\n    return 'mousedown';\n}\n\n/**\n * Handle mouseenter for hover prefetching.\n * @param {Event} event\n */\nfunction handleMouseEnter(event) {\n    // event.target might not be an Element (could be text node)\n    if (!event.target || typeof event.target.closest !== 'function') {\n        return;\n    }\n\n    var el = event.target.closest('a[data-livue-navigate], a[v-navigate]');\n\n    if (!el || !_config.prefetchOnHover) {\n        return;\n    }\n\n    var mode = getNavigateMode(el);\n\n    if (mode !== 'hover') {\n        return;\n    }\n\n    var href = el.getAttribute('href');\n\n    if (!href || href.startsWith('#') || href.startsWith('javascript:')) {\n        return;\n    }\n\n    // Start prefetch after hover delay\n    var timer = setTimeout(function () {\n        prefetchUrl(href);\n    }, _config.hoverDelay);\n\n    _hoverTimers.set(el, timer);\n}\n\n/**\n * Handle mouseleave to cancel hover prefetch.\n * @param {Event} event\n */\nfunction handleMouseLeave(event) {\n    if (!event.target || typeof event.target.closest !== 'function') {\n        return;\n    }\n\n    var el = event.target.closest('a[data-livue-navigate], a[v-navigate]');\n\n    if (!el) {\n        return;\n    }\n\n    var timer = _hoverTimers.get(el);\n\n    if (timer) {\n        clearTimeout(timer);\n        _hoverTimers.delete(el);\n    }\n}\n\n/**\n * Handle mousedown for default prefetching.\n * @param {Event} event\n */\nfunction handleMouseDown(event) {\n    if (!event.target || typeof event.target.closest !== 'function') {\n        return;\n    }\n\n    var el = event.target.closest('a[data-livue-navigate], a[v-navigate]');\n\n    if (!el) {\n        return;\n    }\n\n    var href = el.getAttribute('href');\n\n    if (!href || href.startsWith('#') || href.startsWith('javascript:')) {\n        return;\n    }\n\n    // Prefetch on mousedown (before click fires)\n    prefetchUrl(href);\n}\n\n/**\n * Handle focus for keyboard navigation prefetching.\n * @param {Event} event\n */\nfunction handleFocus(event) {\n    if (!event.target || typeof event.target.closest !== 'function') {\n        return;\n    }\n\n    var el = event.target.closest('a[data-livue-navigate], a[v-navigate]');\n\n    if (!el || !_config.prefetchOnHover) {\n        return;\n    }\n\n    var href = el.getAttribute('href');\n\n    if (!href || href.startsWith('#') || href.startsWith('javascript:')) {\n        return;\n    }\n\n    prefetchUrl(href);\n}\n\n/**\n * Prefetch a URL and cache it.\n *\n * @param {string} url - URL to prefetch\n * @returns {Promise<string|null>} The HTML content or null on error\n */\nexport function prefetchUrl(url) {\n    // Normalize URL\n    var normalizedUrl = new URL(url, location.origin).href;\n\n    // Already prefetching?\n    if (_prefetching.has(normalizedUrl)) {\n        return _prefetching.get(normalizedUrl);\n    }\n\n    // Already cached?\n    if (_pageCache.has(normalizedUrl)) {\n        return Promise.resolve(_pageCache.get(normalizedUrl).html);\n    }\n\n    // Start prefetch\n    var fetchPromise = fetch(normalizedUrl, {\n        method: 'GET',\n        headers: {\n            'Accept': 'text/html',\n            'X-LiVue-Navigate': '1',\n            'X-LiVue-Prefetch': '1',\n        },\n        credentials: 'same-origin',\n    }).then(function (response) {\n        _prefetching.delete(normalizedUrl);\n\n        if (!response.ok) {\n            return null;\n        }\n\n        return response.text().then(function (html) {\n            // Cache the page\n            if (_config.cachePages) {\n                cachePage(normalizedUrl, html);\n            }\n\n            return html;\n        });\n    }).catch(function (err) {\n        _prefetching.delete(normalizedUrl);\n        console.warn('[LiVue] Prefetch failed:', err);\n        return null;\n    });\n\n    _prefetching.set(normalizedUrl, fetchPromise);\n\n    return fetchPromise;\n}\n\n/**\n * Cache a page for instant navigation.\n *\n * @param {string} url - Page URL\n * @param {string} html - Page HTML\n */\nfunction cachePage(url, html) {\n    // Parse to get title\n    var parser = new DOMParser();\n    var doc = parser.parseFromString(html, 'text/html');\n    var title = doc.querySelector('title');\n\n    // Enforce max cache size\n    while (_pageCache.size >= _config.maxCacheSize) {\n        var oldestKey = _pageCache.keys().next().value;\n        _pageCache.delete(oldestKey);\n    }\n\n    _pageCache.set(url, {\n        html: html,\n        title: title ? title.textContent : '',\n        timestamp: Date.now(),\n    });\n}\n\n/**\n * Clear the page cache.\n */\nexport function clearCache() {\n    _pageCache.clear();\n}\n\n/**\n * Handle a redirect response from the server.\n * Decides between classic redirect and SPA navigate.\n *\n * @param {object} redirect - { url: string, navigate: boolean }\n */\nexport function handleRedirect(redirect) {\n    if (_navigating || !redirect || !redirect.url) {\n        return;\n    }\n\n    if (redirect.navigate) {\n        navigateTo(redirect.url, true, false);\n    } else {\n        _navigating = true;\n        window.location.href = redirect.url;\n    }\n}\n\n/**\n * SPA navigate: fetch the target URL, swap the page content,\n * update history, and reboot LiVue.\n *\n * @param {string} url - Target URL\n * @param {boolean} pushState - Whether to push a new history entry\n * @param {boolean} isPopstate - Whether this is a popstate navigation (back/forward)\n */\nexport async function navigateTo(url, pushState, isPopstate) {\n    if (_navigating) {\n        return;\n    }\n\n    if (!_runtime) {\n        window.location.href = url;\n        return;\n    }\n\n    // Normalize URL\n    var normalizedUrl = new URL(url, location.origin).href;\n\n    // Dispatch livue:navigate event (cancellable)\n    var navigateEvent = new CustomEvent('livue:navigate', {\n        detail: {\n            url: normalizedUrl,\n            cached: _pageCache.has(normalizedUrl),\n            isPopstate: isPopstate || false,\n        },\n        cancelable: true,\n    });\n\n    if (!window.dispatchEvent(navigateEvent)) {\n        return; // Navigation was cancelled\n    }\n\n    _navigating = true;\n\n    // Save current scroll position\n    if (!isPopstate) {\n        saveScrollPosition(_currentPageKey);\n    }\n\n    // Start progress bar\n    if (_config.showProgressBar) {\n        progress.start();\n    }\n\n    try {\n        var html;\n        var cached = _pageCache.get(normalizedUrl);\n\n        if (cached) {\n            html = cached.html;\n        } else if (_prefetching.has(normalizedUrl)) {\n            // Wait for prefetch to complete\n            html = await _prefetching.get(normalizedUrl);\n        } else {\n            var response = await fetch(normalizedUrl, {\n                method: 'GET',\n                headers: {\n                    'Accept': 'text/html',\n                    'X-LiVue-Navigate': '1',\n                },\n                credentials: 'same-origin',\n            });\n\n            if (!response.ok) {\n                throw new Error('HTTP ' + response.status);\n            }\n\n            html = await response.text();\n\n            // Cache this page\n            if (_config.cachePages) {\n                cachePage(normalizedUrl, html);\n            }\n        }\n\n        // Parse the HTML response\n        var parser = new DOMParser();\n        var doc = parser.parseFromString(html, 'text/html');\n\n        // Dispatch livue:navigating event (allows mutation)\n        var navigatingEvent = new CustomEvent('livue:navigating', {\n            detail: {\n                url: normalizedUrl,\n                doc: doc,\n                onSwap: function (mutator) {\n                    if (typeof mutator === 'function') {\n                        mutator(doc);\n                    }\n                },\n            },\n        });\n        window.dispatchEvent(navigatingEvent);\n\n        // 1. Collect @persist elements from current page\n        var persistedElements = collectPersistedElements();\n\n        // 2. Collect LiVue IDs that should be preserved (inside @persist elements)\n        var preservedIds = new Set();\n        persistedElements.forEach(function (data) {\n            data.livueIds.forEach(function (id) {\n                preservedIds.add(id);\n            });\n        });\n\n        // 3. Stop the MutationObserver to prevent it from destroying persisted components\n        //    when the body is swapped\n        _runtime._stopObserver();\n\n        // 4. Destroy only non-persisted LiVue components\n        _runtime.destroyExcept(preservedIds);\n\n        // 6. Remove persisted elements from DOM BEFORE body swap\n        //    (otherwise innerHTML = ... will destroy them)\n        persistedElements.forEach(function (data) {\n            if (data.element.parentNode) {\n                data.element.parentNode.removeChild(data.element);\n            }\n        });\n\n        // 7. Update the page title\n        var newTitle = doc.querySelector('title');\n        if (newTitle) {\n            document.title = newTitle.textContent;\n        }\n\n        // 8. Swap the <body> content\n        document.body.innerHTML = doc.body.innerHTML;\n\n        // 9. Restore @persist elements\n        restorePersistedElements(persistedElements);\n\n        // 10. Update CSRF token from the new page\n        var newCsrf = doc.querySelector('meta[name=\"csrf-token\"]');\n        var oldCsrf = document.querySelector('meta[name=\"csrf-token\"]');\n        if (newCsrf && oldCsrf) {\n            oldCsrf.setAttribute('content', newCsrf.getAttribute('content'));\n            clearToken();\n        }\n\n        // 11. Handle <head> scripts with data-navigate-track\n        handleTrackedScripts(doc);\n\n        // 12. Push or replace history state (BEFORE scripts so URL is updated)\n        if (pushState) {\n            _currentPageKey = generatePageKey();\n            history.pushState(\n                { livueNavigate: true, url: normalizedUrl, pageKey: _currentPageKey },\n                '',\n                normalizedUrl\n            );\n        }\n\n        // 13. Execute body scripts (after URL is updated)\n        executeBodyScripts(doc);\n\n        // 14. Reboot LiVue to discover and mount NEW components only\n        //     (preserves already mounted components from @persist)\n        _runtime.rebootPreserving();\n\n        // 15. Restore scroll position (for back/forward) or scroll to top\n        if (isPopstate) {\n            restoreScrollPosition(_currentPageKey);\n        } else {\n            // Check for hash\n            if (location.hash) {\n                var hashEl = document.querySelector(location.hash);\n                if (hashEl) {\n                    hashEl.scrollIntoView();\n                } else {\n                    window.scrollTo(0, 0);\n                }\n            } else {\n                window.scrollTo(0, 0);\n            }\n        }\n\n        // 13. Dispatch livue:navigated event\n        window.dispatchEvent(new CustomEvent('livue:navigated', {\n            detail: { url: normalizedUrl },\n        }));\n\n    } catch (err) {\n        console.error('[LiVue] Navigation failed:', err);\n        window.location.href = url;\n    } finally {\n        _navigating = false;\n\n        if (_config.showProgressBar) {\n            progress.done();\n        }\n    }\n}\n\n/**\n * Collect @persist elements from the current page.\n * These will be preserved across navigation.\n *\n * @returns {Map<string, { element: HTMLElement, livueIds: string[] }>}\n */\nfunction collectPersistedElements() {\n    var persisted = new Map();\n\n    var elements = document.querySelectorAll('[data-livue-persist]');\n    elements.forEach(function (el) {\n        var key = el.dataset.livuePersist;\n        if (key) {\n            // Collect all LiVue component IDs within this persisted element\n            var livueIds = [];\n            var livueElements = el.querySelectorAll('[data-livue-id]');\n            livueElements.forEach(function (livueEl) {\n                livueIds.push(livueEl.dataset.livueId);\n            });\n            // Also check if the element itself is a LiVue component\n            if (el.dataset.livueId) {\n                livueIds.push(el.dataset.livueId);\n            }\n\n            // Save scroll positions of internal scrollable elements\n            var scrollData = {};\n            var scrollElements = el.querySelectorAll('[data-livue-scroll]');\n            scrollElements.forEach(function (scrollEl) {\n                var scrollKey = scrollEl.dataset.livueScroll;\n                if (scrollKey) {\n                    scrollData[scrollKey] = {\n                        scrollTop: scrollEl.scrollTop,\n                        scrollLeft: scrollEl.scrollLeft,\n                    };\n                }\n            });\n\n            persisted.set(key, {\n                element: el,\n                livueIds: livueIds,\n                scrollData: scrollData,\n            });\n        }\n    });\n\n    return persisted;\n}\n\n/**\n * Restore @persist elements to the new page.\n *\n * @param {Map<string, { element: HTMLElement, livueIds: string[], scrollTop: number, scrollLeft: number }>} persisted\n */\nfunction restorePersistedElements(persisted) {\n    if (persisted.size === 0) {\n        return;\n    }\n\n    persisted.forEach(function (data, key) {\n        var placeholder = document.querySelector('[data-livue-persist=\"' + key + '\"]');\n\n        if (placeholder) {\n            // Replace the placeholder with the original element\n            placeholder.parentNode.replaceChild(data.element, placeholder);\n\n            // Restore scroll positions of internal elements\n            if (data.scrollData) {\n                requestAnimationFrame(function () {\n                    Object.keys(data.scrollData).forEach(function (scrollKey) {\n                        var scrollEl = data.element.querySelector('[data-livue-scroll=\"' + scrollKey + '\"]');\n                        if (scrollEl) {\n                            scrollEl.scrollTop = data.scrollData[scrollKey].scrollTop;\n                            scrollEl.scrollLeft = data.scrollData[scrollKey].scrollLeft;\n                        }\n                    });\n                });\n            }\n        }\n    });\n}\n\n/**\n * Handle scripts with data-navigate-track attribute.\n * Triggers full reload if asset versions change.\n *\n * @param {Document} doc - The new document\n */\nfunction handleTrackedScripts(doc) {\n    var currentScripts = document.querySelectorAll('script[data-navigate-track]');\n    var newScripts = doc.querySelectorAll('script[data-navigate-track]');\n\n    // Build map of current script versions\n    var currentVersions = {};\n    currentScripts.forEach(function (script) {\n        var src = script.getAttribute('src');\n        if (src) {\n            currentVersions[src.split('?')[0]] = src;\n        }\n    });\n\n    // Check if any new script has a different version\n    var needsReload = false;\n    newScripts.forEach(function (script) {\n        var src = script.getAttribute('src');\n        if (src) {\n            var base = src.split('?')[0];\n            if (currentVersions[base] && currentVersions[base] !== src) {\n                needsReload = true;\n            }\n        }\n    });\n\n    if (needsReload) {\n        window.location.reload();\n    }\n}\n\n/**\n * Execute scripts in the body.\n * Scripts without data-navigate-once run on every navigation.\n *\n * @param {Document} doc - The new document\n */\nfunction executeBodyScripts(doc) {\n    var scripts = document.body.querySelectorAll('script');\n\n    scripts.forEach(function (oldScript) {\n        // Skip if script was already removed from DOM\n        if (!oldScript.parentNode) {\n            return;\n        }\n\n        // Skip scripts with data-navigate-once that already ran\n        if (oldScript.hasAttribute('data-navigate-once')) {\n            if (oldScript.dataset.navigateRan) {\n                return;\n            }\n            oldScript.dataset.navigateRan = 'true';\n        }\n\n        // Skip LiVue component scripts (handled separately)\n        if (oldScript.type === 'application/livue-setup') {\n            return;\n        }\n\n        // Skip LiVue loader script - it would reload the bundle\n        if (oldScript.hasAttribute('data-livue-loader')) {\n            return;\n        }\n\n        // Skip module scripts - they are already loaded and shouldn't be re-executed\n        // This includes Vite's module scripts that load LiVue\n        if (oldScript.type === 'module') {\n            return;\n        }\n\n        // Skip LiVue runtime bundle - it's already loaded and we don't want to reinitialize\n        var src = oldScript.getAttribute('src') || '';\n        if (src.includes('livue')) {\n            return;\n        }\n\n        // Skip Vite client and HMR scripts\n        if (src.includes('@vite') || src.includes('/@fs/') || src.includes('node_modules')) {\n            return;\n        }\n\n        // Skip app.js and similar entry points (they initialize LiVue)\n        if (src.includes('/resources/js/') || src.includes('/build/assets/')) {\n            return;\n        }\n\n        // Create a new script element to execute it\n        var newScript = document.createElement('script');\n\n        // Copy attributes\n        Array.from(oldScript.attributes).forEach(function (attr) {\n            newScript.setAttribute(attr.name, attr.value);\n        });\n\n        // Copy content for inline scripts\n        if (!oldScript.src) {\n            newScript.textContent = oldScript.textContent;\n        }\n\n        // Replace the old script with the new one to execute it\n        oldScript.parentNode.replaceChild(newScript, oldScript);\n    });\n}\n\n/**\n * Get the current navigation configuration.\n *\n * @returns {object}\n */\nexport function getConfig() {\n    return Object.assign({}, _config);\n}\n\n/**\n * Check if navigation is currently in progress.\n *\n * @returns {boolean}\n */\nexport function isNavigating() {\n    return _navigating;\n}\n","/**\n * LiVue Hooks System\n *\n * A lightweight hook system for client-side lifecycle events.\n * Allows external code (plugins, libraries, developer code) to\n * tap into LiVue's internal lifecycle at various points.\n *\n * A client-side hook system adapted for LiVue's\n * Vue-based architecture (no morphing, uses template swapping).\n *\n * Available hooks:\n * - component.init: When a component is initialized (root or child)\n * - component.destroy: When a component is destroyed\n * - element.init: When each DOM element in a component is initialized\n * - request.started: When an AJAX request starts (pooled or isolated)\n * - request.finished: When an AJAX request completes\n * - template.updating: Before a component template is swapped\n * - template.updated: After a component template is swapped\n * - error.occurred: When an error occurs on any component\n */\n\n/**\n * Registry of hook callbacks.\n * @type {Map<string, Set<Function>>}\n */\nvar _hooks = new Map();\n\n/**\n * Available hook names (for validation).\n */\nvar HOOK_NAMES = [\n    'component.init',\n    'component.destroy',\n    'element.init',\n    'request.started',\n    'request.finished',\n    'template.updating',\n    'template.updated',\n    'error.occurred',\n];\n\n/**\n * Register a callback for a specific hook.\n *\n * @param {string} hookName - The hook to listen for\n * @param {Function} callback - The callback function\n * @returns {Function} Unsubscribe function\n *\n * @example\n * // Track all component initializations\n * const unsubscribe = LiVue.hook('component.init', ({ component, el, cleanup }) => {\n *     console.log('Component initialized:', component.name);\n *     cleanup(() => {\n *         console.log('Component cleanup');\n *     });\n * });\n *\n * // Later, stop listening\n * unsubscribe();\n */\nexport function hook(hookName, callback) {\n    if (typeof hookName !== 'string') {\n        console.warn('[LiVue Hooks] Invalid hook name:', hookName);\n        return function () {};\n    }\n\n    if (typeof callback !== 'function') {\n        console.warn('[LiVue Hooks] Callback must be a function');\n        return function () {};\n    }\n\n    if (!_hooks.has(hookName)) {\n        _hooks.set(hookName, new Set());\n    }\n\n    _hooks.get(hookName).add(callback);\n\n    // Return unsubscribe function\n    return function () {\n        var set = _hooks.get(hookName);\n        if (set) {\n            set.delete(callback);\n            if (set.size === 0) {\n                _hooks.delete(hookName);\n            }\n        }\n    };\n}\n\n/**\n * Trigger a hook with the given payload.\n * Callbacks are executed synchronously in registration order.\n *\n * @param {string} hookName - The hook to trigger\n * @param {object} payload - Data to pass to callbacks\n */\nexport function trigger(hookName, payload) {\n    var callbacks = _hooks.get(hookName);\n    if (!callbacks || callbacks.size === 0) {\n        return;\n    }\n\n    callbacks.forEach(function (callback) {\n        try {\n            callback(payload);\n        } catch (error) {\n            console.error('[LiVue Hooks] Error in \"' + hookName + '\" callback:', error);\n        }\n    });\n}\n\n/**\n * Trigger a hook asynchronously.\n * Awaits each callback before proceeding to the next.\n *\n * @param {string} hookName - The hook to trigger\n * @param {object} payload - Data to pass to callbacks\n * @returns {Promise<void>}\n */\nexport async function triggerAsync(hookName, payload) {\n    var callbacks = _hooks.get(hookName);\n    if (!callbacks || callbacks.size === 0) {\n        return;\n    }\n\n    for (var callback of callbacks) {\n        try {\n            await callback(payload);\n        } catch (error) {\n            console.error('[LiVue Hooks] Error in async \"' + hookName + '\" callback:', error);\n        }\n    }\n}\n\n/**\n * Create a cleanup collector for component lifecycle hooks.\n * Allows hooks to register cleanup functions that run when\n * the component is destroyed.\n *\n * @returns {{ cleanup: Function, runCleanups: Function }}\n */\nexport function createCleanupCollector() {\n    var cleanups = [];\n\n    return {\n        /**\n         * Register a cleanup function.\n         * @param {Function} fn - Cleanup function\n         */\n        cleanup: function (fn) {\n            if (typeof fn === 'function') {\n                cleanups.push(fn);\n            }\n        },\n\n        /**\n         * Run all registered cleanup functions.\n         */\n        runCleanups: function () {\n            cleanups.forEach(function (fn) {\n                try {\n                    fn();\n                } catch (error) {\n                    console.error('[LiVue Hooks] Error in cleanup:', error);\n                }\n            });\n            cleanups = [];\n        },\n    };\n}\n\n/**\n * Check if a hook has any registered callbacks.\n *\n * @param {string} hookName - The hook to check\n * @returns {boolean}\n */\nexport function hasListeners(hookName) {\n    var callbacks = _hooks.get(hookName);\n    return callbacks && callbacks.size > 0;\n}\n\n/**\n * Get the count of registered callbacks for a hook.\n *\n * @param {string} hookName - The hook to check\n * @returns {number}\n */\nexport function listenerCount(hookName) {\n    var callbacks = _hooks.get(hookName);\n    return callbacks ? callbacks.size : 0;\n}\n\n/**\n * Clear all hooks (useful for testing).\n */\nexport function clearAll() {\n    _hooks.clear();\n}\n\n/**\n * Get list of all available hook names.\n * @returns {string[]}\n */\nexport function getAvailableHooks() {\n    return HOOK_NAMES.slice();\n}\n","/**\n * Request pooling for LiVue.\n *\n * Collects pending component updates within a single microtask\n * and sends them as a single batch HTTP request to /livue/update.\n */\n\nimport { getToken } from '../../helpers/csrf.js';\nimport { handleRedirect } from '../navigation.js';\nimport progress from '../../helpers/progress.js';\nimport { trigger } from '../../helpers/hooks.js';\n\n/**\n * Pending update request entries.\n * Each entry: { payload, resolve, reject }\n * @type {Array}\n */\nvar _pending = [];\n\n/**\n * Pending lazy load request entries.\n * Each entry: { payload, resolve, reject }\n * @type {Array}\n */\nvar _pendingLazy = [];\n\n/**\n * Whether a flush is already scheduled for this microtask.\n * @type {boolean}\n */\nvar _scheduled = false;\n\n/**\n * Add a request to the pool.\n * Returns a Promise that resolves with this specific component's response.\n *\n * Isolated components (payload.isolate === true) bypass the pool\n * and send immediately in their own HTTP request.\n *\n * @param {object} payload - { snapshot, diffs, method, params, isolate }\n * @returns {Promise<object>}\n */\nexport function poolRequest(payload) {\n    // Isolated components send immediately, bypassing the batch\n    if (payload.isolate) {\n        return sendIsolated(payload);\n    }\n\n    return new Promise(function (resolve, reject) {\n        _pending.push({\n            payload: payload,\n            resolve: resolve,\n            reject: reject,\n        });\n\n        if (!_scheduled) {\n            _scheduled = true;\n            queueMicrotask(flush);\n        }\n    });\n}\n\n/**\n * Add a lazy load request to the pool.\n * Returns a Promise that resolves with the loaded component's response.\n *\n * @param {object} payload - { component, props }\n * @returns {Promise<object>}\n */\nexport function poolLazyLoad(payload) {\n    return new Promise(function (resolve, reject) {\n        _pendingLazy.push({\n            payload: payload,\n            resolve: resolve,\n            reject: reject,\n        });\n\n        if (!_scheduled) {\n            _scheduled = true;\n            queueMicrotask(flush);\n        }\n    });\n}\n\n/**\n * Flush all pending requests as a single batch HTTP call.\n * Combines both component updates and lazy loads into one request.\n */\nasync function flush() {\n    // Grab the current batches and reset\n    var updateBatch = _pending;\n    var lazyBatch = _pendingLazy;\n    _pending = [];\n    _pendingLazy = [];\n    _scheduled = false;\n\n    if (updateBatch.length === 0 && lazyBatch.length === 0) {\n        return;\n    }\n\n    // Start progress bar\n    progress.start();\n\n    var url = buildUrl();\n    var token = getToken();\n\n    var headers = {\n        'Content-Type': 'application/json',\n        'Accept': 'application/json',\n    };\n\n    if (token) {\n        headers['X-CSRF-TOKEN'] = token;\n    }\n\n    var updates = updateBatch.map(function (entry) {\n        return entry.payload;\n    });\n\n    var lazyLoads = lazyBatch.map(function (entry) {\n        return entry.payload;\n    });\n\n    var body = {};\n    if (updates.length > 0) {\n        body.updates = updates;\n    }\n    if (lazyLoads.length > 0) {\n        body.lazyLoads = lazyLoads;\n    }\n\n    // Trigger request.started hook\n    trigger('request.started', {\n        url: url,\n        updates: updates,\n        lazyLoads: lazyLoads,\n        updateCount: updateBatch.length,\n        lazyCount: lazyBatch.length,\n    });\n\n    try {\n        var response = await fetch(url, {\n            method: 'POST',\n            headers: headers,\n            body: JSON.stringify(body),\n            credentials: 'same-origin',\n        });\n\n        var data = await response.json();\n\n        if (!response.ok) {\n            // Entire batch failed (e.g., 400 validation at transport level)\n            var error = new Error(data.error || 'Request failed');\n            error.status = response.status;\n            error.data = data;\n\n            for (var i = 0; i < updateBatch.length; i++) {\n                updateBatch[i].reject(error);\n            }\n            for (var i = 0; i < lazyBatch.length; i++) {\n                lazyBatch[i].reject(error);\n            }\n            return;\n        }\n\n        // data.responses is an array in the same order as updates\n        var responses = data.responses || [];\n        var lazyResponses = data.lazyResponses || [];\n\n        // Check for redirect in any response â€” handle before distributing.\n        // Don't resolve promises: the page is navigating away, components\n        // will be destroyed, and unresolved promises will be GC'd.\n        for (var i = 0; i < responses.length; i++) {\n            if (responses[i] && responses[i].redirect) {\n                handleRedirect(responses[i].redirect);\n                return;\n            }\n        }\n\n        // Distribute update responses\n        for (var i = 0; i < updateBatch.length; i++) {\n            var result = responses[i];\n\n            if (!result) {\n                updateBatch[i].reject(new Error('No response for component update at index ' + i));\n                continue;\n            }\n\n            if (result.error) {\n                var err = new Error(result.error);\n                err.status = result.status || 500;\n                err.data = result;\n                updateBatch[i].reject(err);\n            } else if (result.errors) {\n                // Validation errors (422-equivalent)\n                var err = new Error('Validation failed');\n                err.status = 422;\n                err.data = result;\n                updateBatch[i].reject(err);\n            } else {\n                updateBatch[i].resolve(result);\n            }\n        }\n\n        // Distribute lazy load responses\n        for (var i = 0; i < lazyBatch.length; i++) {\n            var result = lazyResponses[i];\n\n            if (!result) {\n                lazyBatch[i].reject(new Error('No response for lazy load at index ' + i));\n                continue;\n            }\n\n            if (result.error) {\n                var err = new Error(result.error);\n                err.status = result.status || 500;\n                err.data = result;\n                lazyBatch[i].reject(err);\n            } else {\n                lazyBatch[i].resolve(result);\n            }\n        }\n\n        // Trigger request.finished hook on success\n        trigger('request.finished', {\n            url: url,\n            success: true,\n            responses: responses,\n            lazyResponses: lazyResponses,\n            updateCount: updateBatch.length,\n            lazyCount: lazyBatch.length,\n        });\n    } catch (networkError) {\n        // Network failure: reject all\n        for (var i = 0; i < updateBatch.length; i++) {\n            updateBatch[i].reject(networkError);\n        }\n        for (var i = 0; i < lazyBatch.length; i++) {\n            lazyBatch[i].reject(networkError);\n        }\n\n        // Trigger request.finished hook with error\n        trigger('request.finished', {\n            url: url,\n            success: false,\n            error: networkError,\n            updateCount: updateBatch.length,\n            lazyCount: lazyBatch.length,\n        });\n    } finally {\n        // Complete progress bar\n        progress.done();\n    }\n}\n\n/**\n * Send an isolated request immediately, bypassing the batch pool.\n * The payload is wrapped in a single-item updates array.\n *\n * @param {object} payload\n * @returns {Promise<object>}\n */\nasync function sendIsolated(payload) {\n    // Start progress bar\n    progress.start();\n\n    var url = buildUrl();\n    var token = getToken();\n\n    var headers = {\n        'Content-Type': 'application/json',\n        'Accept': 'application/json',\n    };\n\n    if (token) {\n        headers['X-CSRF-TOKEN'] = token;\n    }\n\n    // Strip the isolate flag from the payload sent to the server\n    var serverPayload = {\n        snapshot: payload.snapshot,\n        diffs: payload.diffs,\n        method: payload.method,\n        params: payload.params,\n    };\n\n    try {\n        var response = await fetch(url, {\n            method: 'POST',\n            headers: headers,\n            body: JSON.stringify({ updates: [serverPayload] }),\n            credentials: 'same-origin',\n        });\n\n        var data = await response.json();\n\n        if (!response.ok) {\n            var error = new Error(data.error || 'Request failed');\n            error.status = response.status;\n            error.data = data;\n            throw error;\n        }\n\n        var result = (data.responses || [])[0];\n\n        if (!result) {\n            throw new Error('No response for isolated component update');\n        }\n\n        if (result.redirect) {\n            handleRedirect(result.redirect);\n            // Return a never-resolving promise â€” page is navigating away\n            return new Promise(function () {});\n        }\n\n        if (result.error) {\n            var err = new Error(result.error);\n            err.status = result.status || 500;\n            err.data = result;\n            throw err;\n        }\n\n        if (result.errors) {\n            var err = new Error('Validation failed');\n            err.status = 422;\n            err.data = result;\n            throw err;\n        }\n\n        return result;\n    } finally {\n        // Complete progress bar\n        progress.done();\n    }\n}\n\n/**\n * Build the LiVue update endpoint URL.\n */\nfunction buildUrl() {\n    var prefix = document.querySelector('meta[name=\"livue-prefix\"]')?.getAttribute('content') || 'livue';\n    return '/' + prefix + '/update';\n}\n","/**\n * AJAX communication layer for LiVue.\n * Delegates to the request pool for automatic batching.\n */\n\nimport { poolRequest } from './pool.js';\n\n/**\n * Send an action to the server (via request pool).\n *\n * Multiple calls within the same microtask are automatically\n * batched into a single HTTP request. Isolated components\n * bypass the pool and send immediately.\n *\n * @param {object} snapshot - Current snapshot { state, memo } with server-confirmed state\n * @param {string|null} method - The method to call (null for state sync only)\n * @param {Array} params - Parameters to pass to the method\n * @param {object} diffs - Properties changed client-side (v-model) since last server response\n * @param {boolean} [isolate] - If true, bypass the pool and send immediately\n * @returns {Promise<object>} The server response with updated snapshot\n */\nexport async function sendAction(snapshot, method, params, diffs, isolate) {\n    return poolRequest({\n        snapshot: snapshot,\n        diffs: diffs || {},\n        method: method,\n        params: params || [],\n        isolate: isolate || false,\n    });\n}\n","/**\n * State management utilities for LiVue.\n */\n\nimport { reactive, toRefs } from 'vue';\n\n/**\n * Create a Vue reactive state object from a plain object.\n *\n * @param {object} initialState\n * @returns {object} Reactive state\n */\nexport function createReactiveState(initialState) {\n    return reactive(Object.assign({}, initialState));\n}\n\n/**\n * Update an existing reactive state with new values.\n * Adds new keys, updates existing ones, and removes stale keys.\n * Only updates values that have actually changed to avoid unnecessary re-renders.\n *\n * @param {object} reactiveState\n * @param {object} newState\n */\nexport function updateState(reactiveState, newState) {\n    let key;\n\n    for (key in newState) {\n        // Only update if the value has actually changed\n        // This prevents unnecessary Vue re-renders for identical values\n        let oldJson = JSON.stringify(reactiveState[key]);\n        let newJson = JSON.stringify(newState[key]);\n\n        if (oldJson !== newJson) {\n            reactiveState[key] = newState[key];\n        }\n    }\n\n    for (key in reactiveState) {\n        if (!(key in newState)) {\n            delete reactiveState[key];\n        }\n    }\n}\n\n/**\n * Serialize a reactive state to a plain JSON-safe object.\n * Strips Vue reactivity proxies.\n *\n * @param {object} reactiveState\n * @returns {object}\n */\nexport function serializeState(reactiveState) {\n    return JSON.parse(JSON.stringify(reactiveState));\n}\n\n/**\n * Convert a reactive object to refs for use in setup() return.\n *\n * @param {object} reactiveState\n * @returns {object}\n */\nexport function stateToRefs(reactiveState) {\n    return toRefs(reactiveState);\n}\n\n/**\n * Get a value from a reactive state using dot notation.\n * Supports nested paths like \"data.avatar\" or \"form.user.name\".\n *\n * @param {object} state - Reactive state object\n * @param {string} path - Dot-separated path (e.g., \"data.avatar\")\n * @returns {*} The value at the path, or undefined if not found\n */\nexport function getByPath(state, path) {\n    if (!path || typeof path !== 'string') {\n        return undefined;\n    }\n\n    let parts = path.split('.');\n    let current = state;\n\n    for (let i = 0; i < parts.length; i++) {\n        if (current === null || current === undefined) {\n            return undefined;\n        }\n        current = current[parts[i]];\n    }\n\n    return current;\n}\n\n/**\n * Set a value in a reactive state using dot notation.\n * Creates intermediate objects/arrays as needed.\n * Supports nested paths like \"data.avatar\" or \"form.user.name\".\n *\n * For Vue 3 reactivity to work properly with nested paths, we need to\n * reassign the top-level property to ensure the Proxy tracks the change.\n *\n * @param {object} state - Reactive state object\n * @param {string} path - Dot-separated path (e.g., \"data.avatar\")\n * @param {*} value - The value to set\n */\nexport function setByPath(state, path, value) {\n    if (!path || typeof path !== 'string') {\n        return;\n    }\n\n    let parts = path.split('.');\n\n    // Simple case: single level path (e.g., \"avatar\")\n    if (parts.length === 1) {\n        state[parts[0]] = value;\n        return;\n    }\n\n    // For nested paths, we need to clone and reassign to trigger reactivity\n    let topKey = parts[0];\n    let topValue = state[topKey];\n\n    // Deep clone the top-level value to ensure reactivity\n    let cloned = JSON.parse(JSON.stringify(topValue !== null && topValue !== undefined ? topValue : {}));\n\n    // Navigate to the parent of the target\n    let current = cloned;\n    for (let i = 1; i < parts.length - 1; i++) {\n        let part = parts[i];\n        if (current[part] === null || current[part] === undefined) {\n            current[part] = {};\n        }\n        current = current[part];\n    }\n\n    // Set the final value\n    let lastPart = parts[parts.length - 1];\n    current[lastPart] = value;\n\n    // Reassign the top-level property to trigger Vue reactivity\n    state[topKey] = cloned;\n}\n","/**\n * Error handling for LiVue components.\n */\n\nimport { reactive } from 'vue';\nimport { trigger } from './hooks.js';\n\n/**\n * Global error handler. Set via LiVueRuntime.onError().\n * @type {Function|null}\n */\nlet _globalErrorHandler = null;\n\n/**\n * Per-component error handlers. Set via livue.onError().\n * @type {Map<string, Function>}\n */\nlet _componentErrorHandlers = new Map();\n\n/**\n * Create a reactive errors object for a component.\n * Holds server validation errors keyed by field name.\n *\n * @returns {object} Reactive errors object with helper methods\n */\nexport function createErrors() {\n    let errors = reactive({});\n\n    return errors;\n}\n\n/**\n * Populate the errors object from a server 422 response.\n *\n * @param {object} errors - The reactive errors object\n * @param {object} serverErrors - { field: ['message', ...], ... }\n */\nexport function setErrors(errors, serverErrors) {\n    // Clear existing errors\n    clearErrors(errors);\n\n    // Set new errors\n    for (let key in serverErrors) {\n        errors[key] = serverErrors[key];\n    }\n}\n\n/**\n * Clear all errors from the reactive object.\n *\n * @param {object} errors - The reactive errors object\n */\nexport function clearErrors(errors) {\n    for (let key in errors) {\n        delete errors[key];\n    }\n}\n\n/**\n * Register a global error handler.\n *\n * @param {Function} handler - function(error, componentName)\n */\nexport function onError(handler) {\n    _globalErrorHandler = handler;\n}\n\n/**\n * Invoke error handlers: component-specific first, then global.\n * Also triggers the error.occurred hook.\n *\n * @param {Error} error\n * @param {string} componentName\n * @param {string} [componentId] - Component ID for per-component handling\n * @param {object} [context] - Additional context (state, livue, method, etc.)\n * @returns {boolean} Whether the error was handled (preventDefault was called)\n */\nexport function handleError(error, componentName, componentId, context) {\n    context = context || {};\n\n    let handled = false;\n    let preventDefault = function () {\n        handled = true;\n    };\n\n    // Trigger error.occurred hook\n    trigger('error.occurred', {\n        error: error,\n        componentName: componentName,\n        componentId: componentId,\n        context: context,\n        preventDefault: preventDefault,\n    });\n\n    if (handled) {\n        return true;\n    }\n\n    // Check for component-specific handler\n    if (componentId && _componentErrorHandlers.has(componentId)) {\n        let componentHandler = _componentErrorHandlers.get(componentId);\n        try {\n            let result = componentHandler(error, context);\n            // If handler returns true or a truthy value, consider it handled\n            if (result === true || result) {\n                return true;\n            }\n        } catch (handlerError) {\n            console.error('[LiVue] Error in component error handler:', handlerError);\n        }\n    }\n\n    // Fall back to global handler\n    if (_globalErrorHandler) {\n        _globalErrorHandler(error, componentName);\n    } else {\n        console.error('[LiVue] Unhandled error on ' + componentName + ':', error);\n    }\n\n    return false;\n}\n\n/**\n * Register an error handler for a specific component.\n *\n * @param {string} componentId - Component ID\n * @param {Function} handler - function(error, context) => boolean\n */\nexport function setComponentErrorHandler(componentId, handler) {\n    if (typeof handler === 'function') {\n        _componentErrorHandlers.set(componentId, handler);\n    }\n}\n\n/**\n * Remove a component's error handler.\n *\n * @param {string} componentId\n */\nexport function removeComponentErrorHandler(componentId) {\n    _componentErrorHandlers.delete(componentId);\n}\n\n/**\n * Get the global error handler setter (exposed on LiVueRuntime).\n */\nexport function getOnError() {\n    return onError;\n}\n","/**\n * Internal Registry for LiVue.\n *\n * This module stores built-in directives that are registered during boot()\n * and applied to every Vue app instance.\n *\n * User-facing registration APIs have been replaced by LiVue.setup().\n *\n * No imports from other LiVue modules â€” this is a leaf dependency.\n */\n\n/**\n * Built-in directives storage.\n * @type {Array<{name: string, directive: object}>}\n */\nvar _builtInDirectives = [];\n\n/**\n * Register a built-in directive.\n * Used internally by directives/index.js during boot.\n *\n * @param {string} name - Directive name (without 'v-' prefix)\n * @param {object|Function} directive - Vue directive definition\n * @param {null} _filters - Ignored, kept for backward compatibility\n */\nexport function addDirective(name, directive, _filters) {\n    _builtInDirectives.push({\n        name: name,\n        directive: directive,\n    });\n}\n\n/**\n * Get all built-in directives to register on a Vue app.\n *\n * @returns {Array<{name: string, directive: object}>}\n */\nexport function getBuiltInDirectives() {\n    return _builtInDirectives;\n}\n\n/**\n * Get all registrations (for DevTools).\n * Returns built-in directives.\n *\n * @returns {object} { plugins: [], stores: [], components: [], directives: [...] }\n */\nexport function getAllRegistrations() {\n    return {\n        plugins: [],\n        stores: [],\n        components: [],\n        directives: _builtInDirectives.map(function (d) {\n            return { name: d.name, filters: null };\n        }),\n    };\n}\n","/**\n * Laravel Echo integration for LiVue.\n *\n * Enables real-time broadcasting via WebSockets using Laravel Echo.\n * Supports public, private, and presence channels.\n *\n * Requirements:\n * - Laravel Echo must be installed and configured\n * - window.Echo must be available globally\n *\n * Channel types:\n * - public:   echo:channel,Event\n * - private:  echo-private:channel,Event\n * - presence: echo-presence:channel,Event (supports here/joining/leaving)\n */\n\n/**\n * Map of channel key -> channel instance.\n * Key format: \"type:channel\" (e.g., \"private:orders.123\")\n * @type {Map<string, object>}\n */\nconst _channels = new Map();\n\n/**\n * Map of subscription key -> { unsubscribe, listeners }\n * Key format: \"type:channel:event:componentId\"\n * @type {Map<string, object>}\n */\nconst _subscriptions = new Map();\n\n/**\n * Whether we've already warned about Echo not being available.\n * @type {boolean}\n */\nlet _warnedNoEcho = false;\n\n/**\n * Check if Laravel Echo is available.\n * @returns {boolean}\n */\nexport function isEchoAvailable() {\n    return typeof window !== 'undefined' && window.Echo;\n}\n\n/**\n * Get or create a channel instance.\n *\n * @param {string} channelName - Channel name (e.g., \"orders.123\")\n * @param {string} type - Channel type: \"public\", \"private\", or \"presence\"\n * @returns {object|null} Echo channel instance or null if Echo unavailable\n */\nfunction getOrCreateChannel(channelName, type) {\n    if (!isEchoAvailable()) {\n        console.warn('[LiVue Echo] Laravel Echo is not available. Make sure window.Echo is initialized.');\n        return null;\n    }\n\n    const key = type + ':' + channelName;\n\n    if (_channels.has(key)) {\n        return _channels.get(key);\n    }\n\n    let channel;\n\n    switch (type) {\n        case 'private':\n            channel = window.Echo.private(channelName);\n            break;\n        case 'presence':\n            channel = window.Echo.join(channelName);\n            break;\n        case 'public':\n        default:\n            channel = window.Echo.channel(channelName);\n            break;\n    }\n\n    _channels.set(key, channel);\n    return channel;\n}\n\n/**\n * Subscribe a component to Echo events.\n *\n * @param {string} componentId - Unique component ID\n * @param {Array} echoConfig - Array of listener configs from memo.echo\n * @param {Function} callMethod - Function to call component method: (method, data) => void\n * @returns {Function} Cleanup function to unsubscribe all\n */\nexport function subscribe(componentId, echoConfig, callMethod) {\n    if (!echoConfig || !echoConfig.length) {\n        return function () {};\n    }\n\n    if (!isEchoAvailable()) {\n        // Only warn once to avoid console spam\n        if (!_warnedNoEcho) {\n            _warnedNoEcho = true;\n            console.warn('[LiVue Echo] Laravel Echo not available. Broadcast events will not work. Configure window.Echo to enable real-time features.');\n        }\n        return function () {};\n    }\n\n    const subscriptionKeys = [];\n\n    for (let i = 0; i < echoConfig.length; i++) {\n        const config = echoConfig[i];\n        const { channel: channelName, type, event, method, isPresenceEvent, isCustomEvent } = config;\n\n        const echoChannel = getOrCreateChannel(channelName, type);\n        if (!echoChannel) continue;\n\n        const subKey = type + ':' + channelName + ':' + event + ':' + componentId;\n\n        // Skip if already subscribed\n        if (_subscriptions.has(subKey)) {\n            subscriptionKeys.push(subKey);\n            continue;\n        }\n\n        // Create handler\n        const handler = function (data) {\n            try {\n                callMethod(method, data);\n            } catch (e) {\n                console.error('[LiVue Echo] Error calling method \"' + method + '\":', e);\n            }\n        };\n\n        // Subscribe based on event type\n        if (type === 'presence' && isPresenceEvent) {\n            // Presence channel special events\n            subscribePresenceEvent(echoChannel, event, handler);\n        } else {\n            // Regular channel event\n            const eventName = isCustomEvent ? '.' + event : event;\n            echoChannel.listen(eventName, handler);\n        }\n\n        _subscriptions.set(subKey, {\n            channel: echoChannel,\n            channelKey: type + ':' + channelName,\n            event: event,\n            handler: handler,\n            isPresenceEvent: isPresenceEvent,\n            isCustomEvent: isCustomEvent,\n        });\n\n        subscriptionKeys.push(subKey);\n    }\n\n    // Return cleanup function\n    return function () {\n        for (let j = 0; j < subscriptionKeys.length; j++) {\n            unsubscribeSingle(subscriptionKeys[j]);\n        }\n    };\n}\n\n/**\n * Subscribe to presence channel special events.\n *\n * @param {object} channel - Presence channel instance\n * @param {string} event - \"here\", \"joining\", or \"leaving\"\n * @param {Function} handler - Event handler\n */\nfunction subscribePresenceEvent(channel, event, handler) {\n    switch (event) {\n        case 'here':\n            channel.here(handler);\n            break;\n        case 'joining':\n            channel.joining(handler);\n            break;\n        case 'leaving':\n            channel.leaving(handler);\n            break;\n    }\n}\n\n/**\n * Unsubscribe a single subscription.\n *\n * @param {string} subKey - Subscription key\n */\nfunction unsubscribeSingle(subKey) {\n    const sub = _subscriptions.get(subKey);\n    if (!sub) return;\n\n    // For regular events, stop listening\n    if (!sub.isPresenceEvent) {\n        const eventName = sub.isCustomEvent ? '.' + sub.event : sub.event;\n        try {\n            sub.channel.stopListening(eventName, sub.handler);\n        } catch (e) {\n            // Ignore errors during cleanup\n        }\n    }\n    // Note: Presence special events (here/joining/leaving) cannot be individually removed\n\n    _subscriptions.delete(subKey);\n\n    // Check if channel still has listeners\n    cleanupChannelIfEmpty(sub.channelKey);\n}\n\n/**\n * Unsubscribe all listeners for a component.\n *\n * @param {string} componentId - Component ID\n */\nexport function unsubscribeComponent(componentId) {\n    const suffix = ':' + componentId;\n    const keysToRemove = [];\n\n    _subscriptions.forEach(function (_, key) {\n        if (key.endsWith(suffix)) {\n            keysToRemove.push(key);\n        }\n    });\n\n    for (let i = 0; i < keysToRemove.length; i++) {\n        unsubscribeSingle(keysToRemove[i]);\n    }\n}\n\n/**\n * Leave and remove a channel if it has no more subscriptions.\n *\n * @param {string} channelKey - Channel key (e.g., \"private:orders.123\")\n */\nfunction cleanupChannelIfEmpty(channelKey) {\n    // Check if any subscription uses this channel\n    let hasSubscriptions = false;\n\n    _subscriptions.forEach(function (sub) {\n        if (sub.channelKey === channelKey) {\n            hasSubscriptions = true;\n        }\n    });\n\n    if (hasSubscriptions) return;\n\n    // Leave the channel\n    const channel = _channels.get(channelKey);\n    if (channel && isEchoAvailable()) {\n        const parts = channelKey.split(':');\n        const type = parts[0];\n        const channelName = parts.slice(1).join(':');\n\n        try {\n            if (type === 'presence') {\n                window.Echo.leave(channelName);\n            } else if (type === 'private') {\n                window.Echo.leaveChannel('private-' + channelName);\n            } else {\n                window.Echo.leaveChannel(channelName);\n            }\n        } catch (e) {\n            // Ignore errors during cleanup\n        }\n    }\n\n    _channels.delete(channelKey);\n}\n\n/**\n * Leave all channels and clear subscriptions.\n * Useful for cleanup on page navigation.\n */\nexport function leaveAll() {\n    _subscriptions.clear();\n\n    _channels.forEach(function (channel, key) {\n        if (isEchoAvailable()) {\n            const parts = key.split(':');\n            const type = parts[0];\n            const channelName = parts.slice(1).join(':');\n\n            try {\n                if (type === 'presence') {\n                    window.Echo.leave(channelName);\n                } else if (type === 'private') {\n                    window.Echo.leaveChannel('private-' + channelName);\n                } else {\n                    window.Echo.leaveChannel(channelName);\n                }\n            } catch (e) {\n                // Ignore\n            }\n        }\n    });\n\n    _channels.clear();\n}\n\n/**\n * Get current subscription info (for debugging).\n *\n * @returns {object} { channels: [...], subscriptions: [...] }\n */\nexport function getDebugInfo() {\n    return {\n        echoAvailable: isEchoAvailable(),\n        channels: Array.from(_channels.keys()),\n        subscriptions: Array.from(_subscriptions.keys()),\n    };\n}\n\n/**\n * Get detailed subscription info (for DevTools).\n *\n * @returns {object} { available, channels: [...], subscriptions: [...] }\n */\nexport function getDetailedSubscriptions() {\n    var channelList = [];\n    var subscriptionList = [];\n\n    _channels.forEach(function (channel, key) {\n        var parts = key.split(':');\n        channelList.push({\n            key: key,\n            type: parts[0],\n            name: parts.slice(1).join(':'),\n        });\n    });\n\n    _subscriptions.forEach(function (sub, key) {\n        var parts = key.split(':');\n        subscriptionList.push({\n            key: key,\n            channelType: parts[0],\n            channelName: parts[1],\n            event: parts[2],\n            componentId: parts[3],\n            isPresenceEvent: sub.isPresenceEvent,\n            isCustomEvent: sub.isCustomEvent,\n        });\n    });\n\n    return {\n        available: isEchoAvailable(),\n        channels: channelList,\n        subscriptions: subscriptionList,\n    };\n}\n\nexport default {\n    subscribe,\n    unsubscribeComponent,\n    leaveAll,\n    isEchoAvailable,\n    getDebugInfo,\n};\n","/**\n * LiVue DevTools - Public API\n *\n * Exposes the DevTools interface for use via LiVue.devtools.\n */\n\nimport * as panel from './panel.js';\nimport { shouldAutoOpen } from './panel.js';\nimport * as collector from './collector.js';\nimport * as tree from './tree.js';\n\n/**\n * Whether the devtools has been initialized.\n * @type {boolean}\n */\nvar _initialized = false;\n\n/**\n * LiVue runtime reference.\n * @type {object|null}\n */\nvar _runtime = null;\n\n/**\n * Initialize devtools with the LiVue runtime.\n * @param {object} runtime - The LiVueRuntime instance\n */\nexport function init(runtime) {\n    if (_initialized) {\n        return;\n    }\n    _runtime = runtime;\n    panel.setRuntime(runtime);\n    _initialized = true;\n\n    // Auto-open if was previously open (persisted in localStorage)\n    if (shouldAutoOpen()) {\n        panel.open();\n    }\n}\n\n/**\n * Open the DevTools panel.\n *\n * @example\n * LiVue.devtools.open();\n */\nexport function open() {\n    if (!_initialized) {\n        console.warn('[LiVue DevTools] Not initialized. Call LiVue.devtools.init() first.');\n        return;\n    }\n    panel.open();\n}\n\n/**\n * Close the DevTools panel.\n *\n * @example\n * LiVue.devtools.close();\n */\nexport function close() {\n    panel.close();\n}\n\n/**\n * Toggle the DevTools panel.\n *\n * @example\n * LiVue.devtools.toggle();\n */\nexport function toggle() {\n    if (!_initialized) {\n        console.warn('[LiVue DevTools] Not initialized. Call LiVue.devtools.init() first.');\n        return;\n    }\n    panel.toggle();\n}\n\n/**\n * Check if the DevTools panel is open.\n *\n * @returns {boolean}\n *\n * @example\n * if (LiVue.devtools.isOpen()) { ... }\n */\nexport function isOpen() {\n    return panel.isOpen();\n}\n\n/**\n * Get the component tree data structure.\n * Useful for programmatic access to component hierarchy.\n *\n * @returns {Array<object>} Array of root component nodes with children\n *\n * @example\n * const components = LiVue.devtools.getComponents();\n * console.log(components);\n */\nexport function getComponents() {\n    return tree.buildTree();\n}\n\n/**\n * Get the request timeline history.\n *\n * @returns {Array<object>} Array of request entries\n *\n * @example\n * const requests = LiVue.devtools.getTimeline();\n * console.log(requests);\n */\nexport function getTimeline() {\n    return collector.getRequests();\n}\n\n/**\n * Get the event history.\n *\n * @returns {Array<object>} Array of event entries\n *\n * @example\n * const events = LiVue.devtools.getEvents();\n * console.log(events);\n */\nexport function getEvents() {\n    return collector.getEvents();\n}\n\n/**\n * Get performance metrics.\n *\n * @returns {object} Performance statistics\n *\n * @example\n * const perf = LiVue.devtools.getPerf();\n * console.log('Avg request time:', perf.avgRequestTime);\n */\nexport function getPerf() {\n    return collector.getPerf();\n}\n\n/**\n * Clear the request timeline.\n *\n * @example\n * LiVue.devtools.clearTimeline();\n */\nexport function clearTimeline() {\n    collector.clearRequests();\n}\n\n/**\n * Clear the event history.\n *\n * @example\n * LiVue.devtools.clearEvents();\n */\nexport function clearEvents() {\n    collector.clearEvents();\n}\n\n/**\n * Clear all collected data (timeline, events, errors).\n *\n * @example\n * LiVue.devtools.clear();\n */\nexport function clear() {\n    collector.clearAll();\n}\n\n/**\n * Add an event to the devtools event log.\n * Called internally when events are dispatched.\n *\n * @param {object} event - Event data\n */\nexport function logEvent(event) {\n    collector.addEvent(event);\n}\n\n/**\n * Check if devtools is initialized.\n *\n * @returns {boolean}\n */\nexport function isInitialized() {\n    return _initialized;\n}\n\n/**\n * Start collecting data without opening the panel.\n * Useful for background data collection.\n *\n * @example\n * LiVue.devtools.startCollecting();\n * // ... do stuff ...\n * const data = LiVue.devtools.getTimeline();\n */\nexport function startCollecting() {\n    collector.start();\n}\n\n/**\n * Stop collecting data.\n *\n * @example\n * LiVue.devtools.stopCollecting();\n */\nexport function stopCollecting() {\n    collector.stop();\n}\n\n/**\n * Check if data collection is active.\n *\n * @returns {boolean}\n */\nexport function isCollecting() {\n    return collector.isActive();\n}\n","/**\n * Lightweight event bus for LiVue.\n *\n * Supports three delivery modes:\n *   - broadcast: deliver to all listeners\n *   - self: deliver only to the source component instance\n *   - to: deliver to all instances of a named component\n */\n\nimport * as devtools from '../devtools/index.js';\n\n/**\n * Registry: eventName â†’ Set of { componentName, componentId, handler }\n * @type {Map<string, Set<object>>}\n */\nvar _listeners = new Map();\n\n/**\n * Register a listener for an event.\n *\n * @param {string} eventName\n * @param {string} componentName - kebab-case component name\n * @param {string} componentId - unique livue instance ID\n * @param {Function} handler - function(data) called when event fires\n * @returns {Function} unsubscribe function\n */\nexport function on(eventName, componentName, componentId, handler) {\n    if (!_listeners.has(eventName)) {\n        _listeners.set(eventName, new Set());\n    }\n\n    var entry = {\n        componentName: componentName,\n        componentId: componentId,\n        handler: handler,\n    };\n\n    _listeners.get(eventName).add(entry);\n\n    return function () {\n        var set = _listeners.get(eventName);\n        if (set) {\n            set.delete(entry);\n            if (set.size === 0) {\n                _listeners.delete(eventName);\n            }\n        }\n    };\n}\n\n/**\n * Emit an event through the bus.\n *\n * @param {string} eventName\n * @param {*} data - event payload\n * @param {string} mode - 'broadcast', 'self', or 'to'\n * @param {string|null} sourceComponentName\n * @param {string|null} sourceComponentId\n * @param {string|null} target - target component name (for 'to' mode)\n */\nexport function emit(eventName, data, mode, sourceComponentName, sourceComponentId, target) {\n    // Log event to devtools\n    if (devtools.isCollecting()) {\n        devtools.logEvent({\n            name: eventName,\n            data: data,\n            mode: mode,\n            source: sourceComponentName,\n            sourceId: sourceComponentId,\n            target: target,\n        });\n    }\n\n    var set = _listeners.get(eventName);\n    if (!set) {\n        return;\n    }\n\n    set.forEach(function (entry) {\n        var shouldDeliver = false;\n\n        if (mode === 'broadcast') {\n            shouldDeliver = true;\n        } else if (mode === 'self') {\n            shouldDeliver = (entry.componentId === sourceComponentId);\n        } else if (mode === 'to') {\n            shouldDeliver = (entry.componentName === target);\n        }\n\n        if (shouldDeliver) {\n            try {\n                entry.handler(data);\n            } catch (e) {\n                console.error('[LiVue] Event handler error for \"' + eventName + '\":', e);\n            }\n        }\n    });\n}\n\n/**\n * Remove all listeners for a given component instance.\n *\n * @param {string} componentId\n */\nexport function removeByComponentId(componentId) {\n    _listeners.forEach(function (set, eventName) {\n        set.forEach(function (entry) {\n            if (entry.componentId === componentId) {\n                set.delete(entry);\n            }\n        });\n        if (set.size === 0) {\n            _listeners.delete(eventName);\n        }\n    });\n}\n\n/**\n * Process events received from a server response.\n *\n * @param {Array} events - array of { name, data, mode, target, source, sourceId }\n */\nexport function processServerEvents(events) {\n    for (var i = 0; i < events.length; i++) {\n        var evt = events[i];\n        emit(evt.name, evt.data, evt.mode, evt.source, evt.sourceId, evt.target);\n    }\n}\n","/**\n * URL query string synchronization for LiVue.\n *\n * Handles syncing component properties with browser URL parameters\n * based on #[Url] attribute configuration from the server.\n */\n\n/**\n * Read initial values from the URL query string for the given URL params config.\n *\n * @param {object} urlParams - { propName: { as, history, keep, except } }\n * @returns {object} Values to apply to the state\n */\nexport function readQueryString(urlParams) {\n    var url = new URL(window.location);\n    var values = {};\n\n    for (var prop in urlParams) {\n        var config = urlParams[prop];\n        var paramName = config.as || prop;\n        var paramValue = url.searchParams.get(paramName);\n\n        if (paramValue !== null) {\n            values[prop] = paramValue;\n        }\n    }\n\n    return values;\n}\n\n/**\n * Update the browser URL to reflect the current state of URL-bound properties.\n *\n * @param {object} urlParams - { propName: { as, history, keep, except } }\n * @param {object} state - The reactive state object\n */\nexport function updateQueryString(urlParams, state) {\n    var url = new URL(window.location);\n    var usePush = false;\n\n    for (var prop in urlParams) {\n        var config = urlParams[prop];\n        var paramName = config.as || prop;\n        var value = state[prop];\n\n        // Determine if the value should be excluded from the URL\n        var shouldExclude = false;\n\n        if (config.except !== null && config.except !== undefined) {\n            // Use loose comparison for except (string \"1\" matches int 1)\n            if (String(value) === String(config.except)) {\n                shouldExclude = true;\n            }\n        }\n\n        if (!config.keep && !shouldExclude) {\n            if (value === '' || value === null || value === undefined) {\n                shouldExclude = true;\n            }\n        }\n\n        if (shouldExclude) {\n            url.searchParams.delete(paramName);\n        } else {\n            url.searchParams.set(paramName, value);\n        }\n\n        // If any param uses history mode, we push state\n        if (config.history) {\n            usePush = true;\n        }\n    }\n\n    // Only update if the URL actually changed\n    if (url.toString() !== window.location.toString()) {\n        if (usePush) {\n            history.pushState({}, '', url);\n        } else {\n            history.replaceState({}, '', url);\n        }\n    }\n}\n","/**\n * File upload module for LiVue.\n *\n * Uploads files to the dedicated /livue/upload endpoint using FormData.\n * Uses XMLHttpRequest (not fetch) for upload progress event support.\n */\n\nimport { getToken } from '../helpers/csrf.js';\n\n/**\n * Build the upload endpoint URL from the configured prefix.\n *\n * @returns {string}\n */\nfunction buildUploadUrl() {\n    var meta = document.querySelector('meta[name=\"livue-prefix\"]');\n    var prefix = meta ? meta.getAttribute('content') : 'livue';\n\n    return '/' + prefix + '/upload';\n}\n\n/**\n * Upload a single file for a component property.\n *\n * @param {File} file - The File object from the input\n * @param {string} componentName - Component name (from memo)\n * @param {string} property - Property name this file maps to\n * @param {string} uploadToken - HMAC token from memo.uploads[property].token\n * @param {Function} [onProgress] - Progress callback receiving 0-100\n * @returns {Promise<object>} Server response with ref + display metadata\n */\nexport function uploadFile(file, componentName, property, uploadToken, onProgress) {\n    return new Promise(function (resolve, reject) {\n        var formData = new FormData();\n        formData.append('file', file);\n        formData.append('component', componentName);\n        formData.append('property', property);\n        formData.append('checksum', uploadToken);\n\n        var xhr = new XMLHttpRequest();\n        var url = buildUploadUrl();\n\n        xhr.open('POST', url, true);\n\n        // CSRF token\n        var token = getToken();\n        if (token) {\n            xhr.setRequestHeader('X-CSRF-TOKEN', token);\n        }\n\n        xhr.setRequestHeader('Accept', 'application/json');\n\n        // Progress tracking\n        if (onProgress && xhr.upload) {\n            xhr.upload.addEventListener('progress', function (e) {\n                if (e.lengthComputable) {\n                    var percent = Math.round((e.loaded / e.total) * 100);\n                    onProgress(percent);\n                }\n            });\n        }\n\n        xhr.onload = function () {\n            var data;\n\n            try {\n                data = JSON.parse(xhr.responseText);\n            } catch (e) {\n                reject(new Error('Invalid server response'));\n                return;\n            }\n\n            if (xhr.status >= 200 && xhr.status < 300) {\n                resolve(data);\n            } else {\n                var error = new Error(data.error || data.message || 'Upload failed');\n                error.status = xhr.status;\n                error.data = data;\n                reject(error);\n            }\n        };\n\n        xhr.onerror = function () {\n            reject(new Error('Network error during upload'));\n        };\n\n        xhr.send(formData);\n    });\n}\n\n/**\n * Upload multiple files in a single batch request.\n *\n * @param {FileList|File[]} files\n * @param {string} componentName\n * @param {string} property\n * @param {string} uploadToken\n * @param {Function} [onProgress] - Called with overall progress 0-100\n * @returns {Promise<{results: object[], errors: object[]}>}\n */\nexport function uploadFiles(files, componentName, property, uploadToken, onProgress) {\n    return new Promise(function (resolve, reject) {\n        var fileArray = Array.from(files);\n        var formData = new FormData();\n\n        // Append all files as files[]\n        fileArray.forEach(function (file) {\n            formData.append('files[]', file);\n        });\n\n        formData.append('component', componentName);\n        formData.append('property', property);\n        formData.append('checksum', uploadToken);\n\n        var xhr = new XMLHttpRequest();\n        var url = buildUploadUrl();\n\n        xhr.open('POST', url, true);\n\n        // CSRF token\n        var token = getToken();\n        if (token) {\n            xhr.setRequestHeader('X-CSRF-TOKEN', token);\n        }\n\n        xhr.setRequestHeader('Accept', 'application/json');\n\n        // Progress tracking\n        if (onProgress && xhr.upload) {\n            xhr.upload.addEventListener('progress', function (e) {\n                if (e.lengthComputable) {\n                    var percent = Math.round((e.loaded / e.total) * 100);\n                    onProgress({ overall: percent });\n                }\n            });\n        }\n\n        xhr.onload = function () {\n            var data;\n\n            try {\n                data = JSON.parse(xhr.responseText);\n            } catch (e) {\n                reject(new Error('Invalid server response'));\n                return;\n            }\n\n            if (xhr.status >= 200 && xhr.status < 300) {\n                // Server returns { results: [], errors: [] }\n                resolve({\n                    results: data.results || [],\n                    errors: data.errors || [],\n                });\n            } else {\n                var error = new Error(data.error || data.message || 'Upload failed');\n                error.status = xhr.status;\n                error.data = data;\n                reject(error);\n            }\n        };\n\n        xhr.onerror = function () {\n            reject(new Error('Network error during upload'));\n        };\n\n        xhr.send(formData);\n    });\n}\n","/*!\n * pinia v3.0.4\n * (c) 2025 Eduardo San Martin Morote\n * @license MIT\n */\nimport { hasInjectionContext, inject, toRaw, watch, unref, markRaw, effectScope, ref, isRef, isReactive, getCurrentScope, onScopeDispose, getCurrentInstance, reactive, toRef, nextTick, computed, toRefs } from 'vue';\nimport { setupDevtoolsPlugin } from '@vue/devtools-api';\n\nconst IS_CLIENT = typeof window !== 'undefined';\n\n/**\n * setActivePinia must be called to handle SSR at the top of functions like\n * `fetch`, `setup`, `serverPrefetch` and others\n */\nlet activePinia;\n/**\n * Sets or unsets the active pinia. Used in SSR and internally when calling\n * actions and getters\n *\n * @param pinia - Pinia instance\n */\n// @ts-expect-error: cannot constrain the type of the return\nconst setActivePinia = (pinia) => (activePinia = pinia);\n/**\n * Get the currently active pinia if there is any.\n */\nconst getActivePinia = (process.env.NODE_ENV !== 'production')\n    ? () => {\n        const pinia = hasInjectionContext() && inject(piniaSymbol);\n        if (!pinia && !IS_CLIENT) {\n            console.error(`[ðŸ]: Pinia instance not found in context. This falls back to the global activePinia which exposes you to cross-request pollution on the server. Most of the time, it means you are calling \"useStore()\" in the wrong place.\\n` +\n                `Read https://vuejs.org/guide/reusability/composables.html to learn more`);\n        }\n        return pinia || activePinia;\n    }\n    : () => (hasInjectionContext() && inject(piniaSymbol)) || activePinia;\nconst piniaSymbol = ((process.env.NODE_ENV !== 'production') ? Symbol('pinia') : /* istanbul ignore next */ Symbol());\n\nfunction isPlainObject(\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\no) {\n    return (o &&\n        typeof o === 'object' &&\n        Object.prototype.toString.call(o) === '[object Object]' &&\n        typeof o.toJSON !== 'function');\n}\n// type DeepReadonly<T> = { readonly [P in keyof T]: DeepReadonly<T[P]> }\n// TODO: can we change these to numbers?\n/**\n * Possible types for SubscriptionCallback\n */\nvar MutationType;\n(function (MutationType) {\n    /**\n     * Direct mutation of the state:\n     *\n     * - `store.name = 'new name'`\n     * - `store.$state.name = 'new name'`\n     * - `store.list.push('new item')`\n     */\n    MutationType[\"direct\"] = \"direct\";\n    /**\n     * Mutated the state with `$patch` and an object\n     *\n     * - `store.$patch({ name: 'newName' })`\n     */\n    MutationType[\"patchObject\"] = \"patch object\";\n    /**\n     * Mutated the state with `$patch` and a function\n     *\n     * - `store.$patch(state => state.name = 'newName')`\n     */\n    MutationType[\"patchFunction\"] = \"patch function\";\n    // maybe reset? for $state = {} and $reset\n})(MutationType || (MutationType = {}));\n\n/*\n * FileSaver.js A saveAs() FileSaver implementation.\n *\n * Originally by Eli Grey, adapted as an ESM module by Eduardo San Martin\n * Morote.\n *\n * License : MIT\n */\n// The one and only way of getting global scope in all environments\n// https://stackoverflow.com/q/3277182/1008999\nconst _global = /*#__PURE__*/ (() => typeof window === 'object' && window.window === window\n    ? window\n    : typeof self === 'object' && self.self === self\n        ? self\n        : typeof global === 'object' && global.global === global\n            ? global\n            : typeof globalThis === 'object'\n                ? globalThis\n                : { HTMLElement: null })();\nfunction bom(blob, { autoBom = false } = {}) {\n    // prepend BOM for UTF-8 XML and text/* types (including HTML)\n    // note: your browser will automatically convert UTF-16 U+FEFF to EF BB BF\n    if (autoBom &&\n        /^\\s*(?:text\\/\\S*|application\\/xml|\\S*\\/\\S*\\+xml)\\s*;.*charset\\s*=\\s*utf-8/i.test(blob.type)) {\n        return new Blob([String.fromCharCode(0xfeff), blob], { type: blob.type });\n    }\n    return blob;\n}\nfunction download(url, name, opts) {\n    const xhr = new XMLHttpRequest();\n    xhr.open('GET', url);\n    xhr.responseType = 'blob';\n    xhr.onload = function () {\n        saveAs(xhr.response, name, opts);\n    };\n    xhr.onerror = function () {\n        console.error('could not download file');\n    };\n    xhr.send();\n}\nfunction corsEnabled(url) {\n    const xhr = new XMLHttpRequest();\n    // use sync to avoid popup blocker\n    xhr.open('HEAD', url, false);\n    try {\n        xhr.send();\n    }\n    catch (e) { }\n    return xhr.status >= 200 && xhr.status <= 299;\n}\n// `a.click()` doesn't work for all browsers (#465)\nfunction click(node) {\n    try {\n        node.dispatchEvent(new MouseEvent('click'));\n    }\n    catch (e) {\n        const evt = new MouseEvent('click', {\n            bubbles: true,\n            cancelable: true,\n            view: window,\n            detail: 0,\n            screenX: 80,\n            screenY: 20,\n            clientX: 80,\n            clientY: 20,\n            ctrlKey: false,\n            altKey: false,\n            shiftKey: false,\n            metaKey: false,\n            button: 0,\n            relatedTarget: null,\n        });\n        node.dispatchEvent(evt);\n    }\n}\nconst _navigator = typeof navigator === 'object' ? navigator : { userAgent: '' };\n// Detect WebView inside a native macOS app by ruling out all browsers\n// We just need to check for 'Safari' because all other browsers (besides Firefox) include that too\n// https://www.whatismybrowser.com/guides/the-latest-user-agent/macos\nconst isMacOSWebView = /*#__PURE__*/ (() => /Macintosh/.test(_navigator.userAgent) &&\n    /AppleWebKit/.test(_navigator.userAgent) &&\n    !/Safari/.test(_navigator.userAgent))();\nconst saveAs = !IS_CLIENT\n    ? () => { } // noop\n    : // Use download attribute first if possible (#193 Lumia mobile) unless this is a macOS WebView or mini program\n        typeof HTMLAnchorElement !== 'undefined' &&\n            'download' in HTMLAnchorElement.prototype &&\n            !isMacOSWebView\n            ? downloadSaveAs\n            : // Use msSaveOrOpenBlob as a second approach\n                'msSaveOrOpenBlob' in _navigator\n                    ? msSaveAs\n                    : // Fallback to using FileReader and a popup\n                        fileSaverSaveAs;\nfunction downloadSaveAs(blob, name = 'download', opts) {\n    const a = document.createElement('a');\n    a.download = name;\n    a.rel = 'noopener'; // tabnabbing\n    // TODO: detect chrome extensions & packaged apps\n    // a.target = '_blank'\n    if (typeof blob === 'string') {\n        // Support regular links\n        a.href = blob;\n        if (a.origin !== location.origin) {\n            if (corsEnabled(a.href)) {\n                download(blob, name, opts);\n            }\n            else {\n                a.target = '_blank';\n                click(a);\n            }\n        }\n        else {\n            click(a);\n        }\n    }\n    else {\n        // Support blobs\n        a.href = URL.createObjectURL(blob);\n        setTimeout(function () {\n            URL.revokeObjectURL(a.href);\n        }, 4e4); // 40s\n        setTimeout(function () {\n            click(a);\n        }, 0);\n    }\n}\nfunction msSaveAs(blob, name = 'download', opts) {\n    if (typeof blob === 'string') {\n        if (corsEnabled(blob)) {\n            download(blob, name, opts);\n        }\n        else {\n            const a = document.createElement('a');\n            a.href = blob;\n            a.target = '_blank';\n            setTimeout(function () {\n                click(a);\n            });\n        }\n    }\n    else {\n        // @ts-ignore: works on windows\n        navigator.msSaveOrOpenBlob(bom(blob, opts), name);\n    }\n}\nfunction fileSaverSaveAs(blob, name, opts, popup) {\n    // Open a popup immediately do go around popup blocker\n    // Mostly only available on user interaction and the fileReader is async so...\n    popup = popup || open('', '_blank');\n    if (popup) {\n        popup.document.title = popup.document.body.innerText = 'downloading...';\n    }\n    if (typeof blob === 'string')\n        return download(blob, name, opts);\n    const force = blob.type === 'application/octet-stream';\n    const isSafari = /constructor/i.test(String(_global.HTMLElement)) || 'safari' in _global;\n    const isChromeIOS = /CriOS\\/[\\d]+/.test(navigator.userAgent);\n    if ((isChromeIOS || (force && isSafari) || isMacOSWebView) &&\n        typeof FileReader !== 'undefined') {\n        // Safari doesn't allow downloading of blob URLs\n        const reader = new FileReader();\n        reader.onloadend = function () {\n            let url = reader.result;\n            if (typeof url !== 'string') {\n                popup = null;\n                throw new Error('Wrong reader.result type');\n            }\n            url = isChromeIOS\n                ? url\n                : url.replace(/^data:[^;]*;/, 'data:attachment/file;');\n            if (popup) {\n                popup.location.href = url;\n            }\n            else {\n                location.assign(url);\n            }\n            popup = null; // reverse-tabnabbing #460\n        };\n        reader.readAsDataURL(blob);\n    }\n    else {\n        const url = URL.createObjectURL(blob);\n        if (popup)\n            popup.location.assign(url);\n        else\n            location.href = url;\n        popup = null; // reverse-tabnabbing #460\n        setTimeout(function () {\n            URL.revokeObjectURL(url);\n        }, 4e4); // 40s\n    }\n}\n\n/**\n * Shows a toast or console.log\n *\n * @param message - message to log\n * @param type - different color of the tooltip\n */\nfunction toastMessage(message, type) {\n    const piniaMessage = 'ðŸ ' + message;\n    if (typeof __VUE_DEVTOOLS_TOAST__ === 'function') {\n        // No longer available :(\n        __VUE_DEVTOOLS_TOAST__(piniaMessage, type);\n    }\n    else if (type === 'error') {\n        console.error(piniaMessage);\n    }\n    else if (type === 'warn') {\n        console.warn(piniaMessage);\n    }\n    else {\n        console.log(piniaMessage);\n    }\n}\nfunction isPinia(o) {\n    return '_a' in o && 'install' in o;\n}\n\n/**\n * This file contain devtools actions, they are not Pinia actions.\n */\n// ---\nfunction checkClipboardAccess() {\n    if (!('clipboard' in navigator)) {\n        toastMessage(`Your browser doesn't support the Clipboard API`, 'error');\n        return true;\n    }\n}\nfunction checkNotFocusedError(error) {\n    if (error instanceof Error &&\n        error.message.toLowerCase().includes('document is not focused')) {\n        toastMessage('You need to activate the \"Emulate a focused page\" setting in the \"Rendering\" panel of devtools.', 'warn');\n        return true;\n    }\n    return false;\n}\nasync function actionGlobalCopyState(pinia) {\n    if (checkClipboardAccess())\n        return;\n    try {\n        await navigator.clipboard.writeText(JSON.stringify(pinia.state.value));\n        toastMessage('Global state copied to clipboard.');\n    }\n    catch (error) {\n        if (checkNotFocusedError(error))\n            return;\n        toastMessage(`Failed to serialize the state. Check the console for more details.`, 'error');\n        console.error(error);\n    }\n}\nasync function actionGlobalPasteState(pinia) {\n    if (checkClipboardAccess())\n        return;\n    try {\n        loadStoresState(pinia, JSON.parse(await navigator.clipboard.readText()));\n        toastMessage('Global state pasted from clipboard.');\n    }\n    catch (error) {\n        if (checkNotFocusedError(error))\n            return;\n        toastMessage(`Failed to deserialize the state from clipboard. Check the console for more details.`, 'error');\n        console.error(error);\n    }\n}\nasync function actionGlobalSaveState(pinia) {\n    try {\n        saveAs(new Blob([JSON.stringify(pinia.state.value)], {\n            type: 'text/plain;charset=utf-8',\n        }), 'pinia-state.json');\n    }\n    catch (error) {\n        toastMessage(`Failed to export the state as JSON. Check the console for more details.`, 'error');\n        console.error(error);\n    }\n}\nlet fileInput;\nfunction getFileOpener() {\n    if (!fileInput) {\n        fileInput = document.createElement('input');\n        fileInput.type = 'file';\n        fileInput.accept = '.json';\n    }\n    function openFile() {\n        return new Promise((resolve, reject) => {\n            fileInput.onchange = async () => {\n                const files = fileInput.files;\n                if (!files)\n                    return resolve(null);\n                const file = files.item(0);\n                if (!file)\n                    return resolve(null);\n                return resolve({ text: await file.text(), file });\n            };\n            // @ts-ignore: TODO: changed from 4.3 to 4.4\n            fileInput.oncancel = () => resolve(null);\n            fileInput.onerror = reject;\n            fileInput.click();\n        });\n    }\n    return openFile;\n}\nasync function actionGlobalOpenStateFile(pinia) {\n    try {\n        const open = getFileOpener();\n        const result = await open();\n        if (!result)\n            return;\n        const { text, file } = result;\n        loadStoresState(pinia, JSON.parse(text));\n        toastMessage(`Global state imported from \"${file.name}\".`);\n    }\n    catch (error) {\n        toastMessage(`Failed to import the state from JSON. Check the console for more details.`, 'error');\n        console.error(error);\n    }\n}\nfunction loadStoresState(pinia, state) {\n    for (const key in state) {\n        const storeState = pinia.state.value[key];\n        // store is already instantiated, patch it\n        if (storeState) {\n            Object.assign(storeState, state[key]);\n        }\n        else {\n            // store is not instantiated, set the initial state\n            pinia.state.value[key] = state[key];\n        }\n    }\n}\n\nfunction formatDisplay(display) {\n    return {\n        _custom: {\n            display,\n        },\n    };\n}\nconst PINIA_ROOT_LABEL = 'ðŸ Pinia (root)';\nconst PINIA_ROOT_ID = '_root';\nfunction formatStoreForInspectorTree(store) {\n    return isPinia(store)\n        ? {\n            id: PINIA_ROOT_ID,\n            label: PINIA_ROOT_LABEL,\n        }\n        : {\n            id: store.$id,\n            label: store.$id,\n        };\n}\nfunction formatStoreForInspectorState(store) {\n    if (isPinia(store)) {\n        const storeNames = Array.from(store._s.keys());\n        const storeMap = store._s;\n        const state = {\n            state: storeNames.map((storeId) => ({\n                editable: true,\n                key: storeId,\n                value: store.state.value[storeId],\n            })),\n            getters: storeNames\n                .filter((id) => storeMap.get(id)._getters)\n                .map((id) => {\n                const store = storeMap.get(id);\n                return {\n                    editable: false,\n                    key: id,\n                    value: store._getters.reduce((getters, key) => {\n                        getters[key] = store[key];\n                        return getters;\n                    }, {}),\n                };\n            }),\n        };\n        return state;\n    }\n    const state = {\n        state: Object.keys(store.$state).map((key) => ({\n            editable: true,\n            key,\n            value: store.$state[key],\n        })),\n    };\n    // avoid adding empty getters\n    if (store._getters && store._getters.length) {\n        state.getters = store._getters.map((getterName) => ({\n            editable: false,\n            key: getterName,\n            value: store[getterName],\n        }));\n    }\n    if (store._customProperties.size) {\n        state.customProperties = Array.from(store._customProperties).map((key) => ({\n            editable: true,\n            key,\n            value: store[key],\n        }));\n    }\n    return state;\n}\nfunction formatEventData(events) {\n    if (!events)\n        return {};\n    if (Array.isArray(events)) {\n        // TODO: handle add and delete for arrays and objects\n        return events.reduce((data, event) => {\n            data.keys.push(event.key);\n            data.operations.push(event.type);\n            data.oldValue[event.key] = event.oldValue;\n            data.newValue[event.key] = event.newValue;\n            return data;\n        }, {\n            oldValue: {},\n            keys: [],\n            operations: [],\n            newValue: {},\n        });\n    }\n    else {\n        return {\n            operation: formatDisplay(events.type),\n            key: formatDisplay(events.key),\n            oldValue: events.oldValue,\n            newValue: events.newValue,\n        };\n    }\n}\nfunction formatMutationType(type) {\n    switch (type) {\n        case MutationType.direct:\n            return 'mutation';\n        case MutationType.patchFunction:\n            return '$patch';\n        case MutationType.patchObject:\n            return '$patch';\n        default:\n            return 'unknown';\n    }\n}\n\n// timeline can be paused when directly changing the state\nlet isTimelineActive = true;\nconst componentStateTypes = [];\nconst MUTATIONS_LAYER_ID = 'pinia:mutations';\nconst INSPECTOR_ID = 'pinia';\nconst { assign: assign$1 } = Object;\n/**\n * Gets the displayed name of a store in devtools\n *\n * @param id - id of the store\n * @returns a formatted string\n */\nconst getStoreType = (id) => 'ðŸ ' + id;\n/**\n * Add the pinia plugin without any store. Allows displaying a Pinia plugin tab\n * as soon as it is added to the application.\n *\n * @param app - Vue application\n * @param pinia - pinia instance\n */\nfunction registerPiniaDevtools(app, pinia) {\n    setupDevtoolsPlugin({\n        id: 'dev.esm.pinia',\n        label: 'Pinia ðŸ',\n        logo: 'https://pinia.vuejs.org/logo.svg',\n        packageName: 'pinia',\n        homepage: 'https://pinia.vuejs.org',\n        componentStateTypes,\n        app,\n    }, (api) => {\n        if (typeof api.now !== 'function') {\n            toastMessage('You seem to be using an outdated version of Vue Devtools. Are you still using the Beta release instead of the stable one? You can find the links at https://devtools.vuejs.org/guide/installation.html.');\n        }\n        api.addTimelineLayer({\n            id: MUTATIONS_LAYER_ID,\n            label: `Pinia ðŸ`,\n            color: 0xe5df88,\n        });\n        api.addInspector({\n            id: INSPECTOR_ID,\n            label: 'Pinia ðŸ',\n            icon: 'storage',\n            treeFilterPlaceholder: 'Search stores',\n            actions: [\n                {\n                    icon: 'content_copy',\n                    action: () => {\n                        actionGlobalCopyState(pinia);\n                    },\n                    tooltip: 'Serialize and copy the state',\n                },\n                {\n                    icon: 'content_paste',\n                    action: async () => {\n                        await actionGlobalPasteState(pinia);\n                        api.sendInspectorTree(INSPECTOR_ID);\n                        api.sendInspectorState(INSPECTOR_ID);\n                    },\n                    tooltip: 'Replace the state with the content of your clipboard',\n                },\n                {\n                    icon: 'save',\n                    action: () => {\n                        actionGlobalSaveState(pinia);\n                    },\n                    tooltip: 'Save the state as a JSON file',\n                },\n                {\n                    icon: 'folder_open',\n                    action: async () => {\n                        await actionGlobalOpenStateFile(pinia);\n                        api.sendInspectorTree(INSPECTOR_ID);\n                        api.sendInspectorState(INSPECTOR_ID);\n                    },\n                    tooltip: 'Import the state from a JSON file',\n                },\n            ],\n            nodeActions: [\n                {\n                    icon: 'restore',\n                    tooltip: 'Reset the state (with \"$reset\")',\n                    action: (nodeId) => {\n                        const store = pinia._s.get(nodeId);\n                        if (!store) {\n                            toastMessage(`Cannot reset \"${nodeId}\" store because it wasn't found.`, 'warn');\n                        }\n                        else if (typeof store.$reset !== 'function') {\n                            toastMessage(`Cannot reset \"${nodeId}\" store because it doesn't have a \"$reset\" method implemented.`, 'warn');\n                        }\n                        else {\n                            store.$reset();\n                            toastMessage(`Store \"${nodeId}\" reset.`);\n                        }\n                    },\n                },\n            ],\n        });\n        api.on.inspectComponent((payload) => {\n            const proxy = (payload.componentInstance &&\n                payload.componentInstance.proxy);\n            if (proxy && proxy._pStores) {\n                const piniaStores = payload.componentInstance.proxy._pStores;\n                Object.values(piniaStores).forEach((store) => {\n                    payload.instanceData.state.push({\n                        type: getStoreType(store.$id),\n                        key: 'state',\n                        editable: true,\n                        value: store._isOptionsAPI\n                            ? {\n                                _custom: {\n                                    value: toRaw(store.$state),\n                                    actions: [\n                                        {\n                                            icon: 'restore',\n                                            tooltip: 'Reset the state of this store',\n                                            action: () => store.$reset(),\n                                        },\n                                    ],\n                                },\n                            }\n                            : // NOTE: workaround to unwrap transferred refs\n                                Object.keys(store.$state).reduce((state, key) => {\n                                    state[key] = store.$state[key];\n                                    return state;\n                                }, {}),\n                    });\n                    if (store._getters && store._getters.length) {\n                        payload.instanceData.state.push({\n                            type: getStoreType(store.$id),\n                            key: 'getters',\n                            editable: false,\n                            value: store._getters.reduce((getters, key) => {\n                                try {\n                                    getters[key] = store[key];\n                                }\n                                catch (error) {\n                                    // @ts-expect-error: we just want to show it in devtools\n                                    getters[key] = error;\n                                }\n                                return getters;\n                            }, {}),\n                        });\n                    }\n                });\n            }\n        });\n        api.on.getInspectorTree((payload) => {\n            if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {\n                let stores = [pinia];\n                stores = stores.concat(Array.from(pinia._s.values()));\n                payload.rootNodes = (payload.filter\n                    ? stores.filter((store) => '$id' in store\n                        ? store.$id\n                            .toLowerCase()\n                            .includes(payload.filter.toLowerCase())\n                        : PINIA_ROOT_LABEL.toLowerCase().includes(payload.filter.toLowerCase()))\n                    : stores).map(formatStoreForInspectorTree);\n            }\n        });\n        // Expose pinia instance as $pinia to window\n        globalThis.$pinia = pinia;\n        api.on.getInspectorState((payload) => {\n            if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {\n                const inspectedStore = payload.nodeId === PINIA_ROOT_ID\n                    ? pinia\n                    : pinia._s.get(payload.nodeId);\n                if (!inspectedStore) {\n                    // this could be the selected store restored for a different project\n                    // so it's better not to say anything here\n                    return;\n                }\n                if (inspectedStore) {\n                    // Expose selected store as $store to window\n                    if (payload.nodeId !== PINIA_ROOT_ID)\n                        globalThis.$store = toRaw(inspectedStore);\n                    payload.state = formatStoreForInspectorState(inspectedStore);\n                }\n            }\n        });\n        api.on.editInspectorState((payload) => {\n            if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {\n                const inspectedStore = payload.nodeId === PINIA_ROOT_ID\n                    ? pinia\n                    : pinia._s.get(payload.nodeId);\n                if (!inspectedStore) {\n                    return toastMessage(`store \"${payload.nodeId}\" not found`, 'error');\n                }\n                const { path } = payload;\n                if (!isPinia(inspectedStore)) {\n                    // access only the state\n                    if (path.length !== 1 ||\n                        !inspectedStore._customProperties.has(path[0]) ||\n                        path[0] in inspectedStore.$state) {\n                        path.unshift('$state');\n                    }\n                }\n                else {\n                    // Root access, we can omit the `.value` because the devtools API does it for us\n                    path.unshift('state');\n                }\n                isTimelineActive = false;\n                payload.set(inspectedStore, path, payload.state.value);\n                isTimelineActive = true;\n            }\n        });\n        api.on.editComponentState((payload) => {\n            if (payload.type.startsWith('ðŸ')) {\n                const storeId = payload.type.replace(/^ðŸ\\s*/, '');\n                const store = pinia._s.get(storeId);\n                if (!store) {\n                    return toastMessage(`store \"${storeId}\" not found`, 'error');\n                }\n                const { path } = payload;\n                if (path[0] !== 'state') {\n                    return toastMessage(`Invalid path for store \"${storeId}\":\\n${path}\\nOnly state can be modified.`);\n                }\n                // rewrite the first entry to be able to directly set the state as\n                // well as any other path\n                path[0] = '$state';\n                isTimelineActive = false;\n                payload.set(store, path, payload.state.value);\n                isTimelineActive = true;\n            }\n        });\n    });\n}\nfunction addStoreToDevtools(app, store) {\n    if (!componentStateTypes.includes(getStoreType(store.$id))) {\n        componentStateTypes.push(getStoreType(store.$id));\n    }\n    setupDevtoolsPlugin({\n        id: 'dev.esm.pinia',\n        label: 'Pinia ðŸ',\n        logo: 'https://pinia.vuejs.org/logo.svg',\n        packageName: 'pinia',\n        homepage: 'https://pinia.vuejs.org',\n        componentStateTypes,\n        app,\n        settings: {\n            logStoreChanges: {\n                label: 'Notify about new/deleted stores',\n                type: 'boolean',\n                defaultValue: true,\n            },\n            // useEmojis: {\n            //   label: 'Use emojis in messages âš¡ï¸',\n            //   type: 'boolean',\n            //   defaultValue: true,\n            // },\n        },\n    }, (api) => {\n        // gracefully handle errors\n        const now = typeof api.now === 'function' ? api.now.bind(api) : Date.now;\n        store.$onAction(({ after, onError, name, args }) => {\n            const groupId = runningActionId++;\n            api.addTimelineEvent({\n                layerId: MUTATIONS_LAYER_ID,\n                event: {\n                    time: now(),\n                    title: 'ðŸ›« ' + name,\n                    subtitle: 'start',\n                    data: {\n                        store: formatDisplay(store.$id),\n                        action: formatDisplay(name),\n                        args,\n                    },\n                    groupId,\n                },\n            });\n            after((result) => {\n                activeAction = undefined;\n                api.addTimelineEvent({\n                    layerId: MUTATIONS_LAYER_ID,\n                    event: {\n                        time: now(),\n                        title: 'ðŸ›¬ ' + name,\n                        subtitle: 'end',\n                        data: {\n                            store: formatDisplay(store.$id),\n                            action: formatDisplay(name),\n                            args,\n                            result,\n                        },\n                        groupId,\n                    },\n                });\n            });\n            onError((error) => {\n                activeAction = undefined;\n                api.addTimelineEvent({\n                    layerId: MUTATIONS_LAYER_ID,\n                    event: {\n                        time: now(),\n                        logType: 'error',\n                        title: 'ðŸ’¥ ' + name,\n                        subtitle: 'end',\n                        data: {\n                            store: formatDisplay(store.$id),\n                            action: formatDisplay(name),\n                            args,\n                            error,\n                        },\n                        groupId,\n                    },\n                });\n            });\n        }, true);\n        store._customProperties.forEach((name) => {\n            watch(() => unref(store[name]), (newValue, oldValue) => {\n                api.notifyComponentUpdate();\n                api.sendInspectorState(INSPECTOR_ID);\n                if (isTimelineActive) {\n                    api.addTimelineEvent({\n                        layerId: MUTATIONS_LAYER_ID,\n                        event: {\n                            time: now(),\n                            title: 'Change',\n                            subtitle: name,\n                            data: {\n                                newValue,\n                                oldValue,\n                            },\n                            groupId: activeAction,\n                        },\n                    });\n                }\n            }, { deep: true });\n        });\n        store.$subscribe(({ events, type }, state) => {\n            api.notifyComponentUpdate();\n            api.sendInspectorState(INSPECTOR_ID);\n            if (!isTimelineActive)\n                return;\n            // rootStore.state[store.id] = state\n            const eventData = {\n                time: now(),\n                title: formatMutationType(type),\n                data: assign$1({ store: formatDisplay(store.$id) }, formatEventData(events)),\n                groupId: activeAction,\n            };\n            if (type === MutationType.patchFunction) {\n                eventData.subtitle = 'â¤µï¸';\n            }\n            else if (type === MutationType.patchObject) {\n                eventData.subtitle = 'ðŸ§©';\n            }\n            else if (events && !Array.isArray(events)) {\n                eventData.subtitle = events.type;\n            }\n            if (events) {\n                eventData.data['rawEvent(s)'] = {\n                    _custom: {\n                        display: 'DebuggerEvent',\n                        type: 'object',\n                        tooltip: 'raw DebuggerEvent[]',\n                        value: events,\n                    },\n                };\n            }\n            api.addTimelineEvent({\n                layerId: MUTATIONS_LAYER_ID,\n                event: eventData,\n            });\n        }, { detached: true, flush: 'sync' });\n        const hotUpdate = store._hotUpdate;\n        store._hotUpdate = markRaw((newStore) => {\n            hotUpdate(newStore);\n            api.addTimelineEvent({\n                layerId: MUTATIONS_LAYER_ID,\n                event: {\n                    time: now(),\n                    title: 'ðŸ”¥ ' + store.$id,\n                    subtitle: 'HMR update',\n                    data: {\n                        store: formatDisplay(store.$id),\n                        info: formatDisplay(`HMR update`),\n                    },\n                },\n            });\n            // update the devtools too\n            api.notifyComponentUpdate();\n            api.sendInspectorTree(INSPECTOR_ID);\n            api.sendInspectorState(INSPECTOR_ID);\n        });\n        const { $dispose } = store;\n        store.$dispose = () => {\n            $dispose();\n            api.notifyComponentUpdate();\n            api.sendInspectorTree(INSPECTOR_ID);\n            api.sendInspectorState(INSPECTOR_ID);\n            api.getSettings().logStoreChanges &&\n                toastMessage(`Disposed \"${store.$id}\" store ðŸ—‘`);\n        };\n        // trigger an update so it can display new registered stores\n        api.notifyComponentUpdate();\n        api.sendInspectorTree(INSPECTOR_ID);\n        api.sendInspectorState(INSPECTOR_ID);\n        api.getSettings().logStoreChanges &&\n            toastMessage(`\"${store.$id}\" store installed ðŸ†•`);\n    });\n}\nlet runningActionId = 0;\nlet activeAction;\n/**\n * Patches a store to enable action grouping in devtools by wrapping the store with a Proxy that is passed as the\n * context of all actions, allowing us to set `runningAction` on each access and effectively associating any state\n * mutation to the action.\n *\n * @param store - store to patch\n * @param actionNames - list of actionst to patch\n */\nfunction patchActionForGrouping(store, actionNames, wrapWithProxy) {\n    // original actions of the store as they are given by pinia. We are going to override them\n    const actions = actionNames.reduce((storeActions, actionName) => {\n        // use toRaw to avoid tracking #541\n        storeActions[actionName] = toRaw(store)[actionName];\n        return storeActions;\n    }, {});\n    for (const actionName in actions) {\n        store[actionName] = function () {\n            // the running action id is incremented in a before action hook\n            const _actionId = runningActionId;\n            const trackedStore = wrapWithProxy\n                ? new Proxy(store, {\n                    get(...args) {\n                        activeAction = _actionId;\n                        return Reflect.get(...args);\n                    },\n                    set(...args) {\n                        activeAction = _actionId;\n                        return Reflect.set(...args);\n                    },\n                })\n                : store;\n            // For Setup Stores we need https://github.com/tc39/proposal-async-context\n            activeAction = _actionId;\n            const retValue = actions[actionName].apply(trackedStore, arguments);\n            // this is safer as async actions in Setup Stores would associate mutations done outside of the action\n            activeAction = undefined;\n            return retValue;\n        };\n    }\n}\n/**\n * pinia.use(devtoolsPlugin)\n */\nfunction devtoolsPlugin({ app, store, options }) {\n    // HMR module\n    if (store.$id.startsWith('__hot:')) {\n        return;\n    }\n    // detect option api vs setup api\n    store._isOptionsAPI = !!options.state;\n    // Do not overwrite actions mocked by @pinia/testing (#2298)\n    if (!store._p._testing) {\n        patchActionForGrouping(store, Object.keys(options.actions), store._isOptionsAPI);\n        // Upgrade the HMR to also update the new actions\n        const originalHotUpdate = store._hotUpdate;\n        toRaw(store)._hotUpdate = function (newStore) {\n            originalHotUpdate.apply(this, arguments);\n            patchActionForGrouping(store, Object.keys(newStore._hmrPayload.actions), !!store._isOptionsAPI);\n        };\n    }\n    addStoreToDevtools(app, \n    // FIXME: is there a way to allow the assignment from Store<Id, S, G, A> to StoreGeneric?\n    store);\n}\n\n/**\n * Creates a Pinia instance to be used by the application\n */\nfunction createPinia() {\n    const scope = effectScope(true);\n    // NOTE: here we could check the window object for a state and directly set it\n    // if there is anything like it with Vue 3 SSR\n    const state = scope.run(() => ref({}));\n    let _p = [];\n    // plugins added before calling app.use(pinia)\n    let toBeInstalled = [];\n    const pinia = markRaw({\n        install(app) {\n            // this allows calling useStore() outside of a component setup after\n            // installing pinia's plugin\n            setActivePinia(pinia);\n            pinia._a = app;\n            app.provide(piniaSymbol, pinia);\n            app.config.globalProperties.$pinia = pinia;\n            /* istanbul ignore else */\n            if ((((process.env.NODE_ENV !== 'production') || (typeof __VUE_PROD_DEVTOOLS__ !== 'undefined' && __VUE_PROD_DEVTOOLS__)) && !(process.env.NODE_ENV === 'test')) && IS_CLIENT) {\n                registerPiniaDevtools(app, pinia);\n            }\n            toBeInstalled.forEach((plugin) => _p.push(plugin));\n            toBeInstalled = [];\n        },\n        use(plugin) {\n            if (!this._a) {\n                toBeInstalled.push(plugin);\n            }\n            else {\n                _p.push(plugin);\n            }\n            return this;\n        },\n        _p,\n        // it's actually undefined here\n        // @ts-expect-error\n        _a: null,\n        _e: scope,\n        _s: new Map(),\n        state,\n    });\n    // pinia devtools rely on dev only features so they cannot be forced unless\n    // the dev build of Vue is used. Avoid old browsers like IE11.\n    if ((((process.env.NODE_ENV !== 'production') || (typeof __VUE_PROD_DEVTOOLS__ !== 'undefined' && __VUE_PROD_DEVTOOLS__)) && !(process.env.NODE_ENV === 'test')) && IS_CLIENT && typeof Proxy !== 'undefined') {\n        pinia.use(devtoolsPlugin);\n    }\n    return pinia;\n}\n/**\n * Dispose a Pinia instance by stopping its effectScope and removing the state, plugins and stores. This is mostly\n * useful in tests, with both a testing pinia or a regular pinia and in applications that use multiple pinia instances.\n * Once disposed, the pinia instance cannot be used anymore.\n *\n * @param pinia - pinia instance\n */\nfunction disposePinia(pinia) {\n    pinia._e.stop();\n    pinia._s.clear();\n    pinia._p.splice(0);\n    pinia.state.value = {};\n    // @ts-expect-error: non valid\n    pinia._a = null;\n}\n\n/**\n * Checks if a function is a `StoreDefinition`.\n *\n * @param fn - object to test\n * @returns true if `fn` is a StoreDefinition\n */\nconst isUseStore = (fn) => {\n    return typeof fn === 'function' && typeof fn.$id === 'string';\n};\n/**\n * Mutates in place `newState` with `oldState` to _hot update_ it. It will\n * remove any key not existing in `newState` and recursively merge plain\n * objects.\n *\n * @param newState - new state object to be patched\n * @param oldState - old state that should be used to patch newState\n * @returns - newState\n */\nfunction patchObject(newState, oldState) {\n    // no need to go through symbols because they cannot be serialized anyway\n    for (const key in oldState) {\n        const subPatch = oldState[key];\n        // skip the whole sub tree\n        if (!(key in newState)) {\n            continue;\n        }\n        const targetValue = newState[key];\n        if (isPlainObject(targetValue) &&\n            isPlainObject(subPatch) &&\n            !isRef(subPatch) &&\n            !isReactive(subPatch)) {\n            newState[key] = patchObject(targetValue, subPatch);\n        }\n        else {\n            // objects are either a bit more complex (e.g. refs) or primitives, so we\n            // just set the whole thing\n            newState[key] = subPatch;\n        }\n    }\n    return newState;\n}\n/**\n * Creates an _accept_ function to pass to `import.meta.hot` in Vite applications.\n *\n * @example\n * ```js\n * const useUser = defineStore(...)\n * if (import.meta.hot) {\n *   import.meta.hot.accept(acceptHMRUpdate(useUser, import.meta.hot))\n * }\n * ```\n *\n * @param initialUseStore - return of the defineStore to hot update\n * @param hot - `import.meta.hot`\n */\nfunction acceptHMRUpdate(initialUseStore, hot) {\n    // strip as much as possible from iife.prod\n    if (!(process.env.NODE_ENV !== 'production')) {\n        return () => { };\n    }\n    return (newModule) => {\n        const pinia = hot.data.pinia || initialUseStore._pinia;\n        if (!pinia) {\n            // this store is still not used\n            return;\n        }\n        // preserve the pinia instance across loads\n        hot.data.pinia = pinia;\n        // console.log('got data', newStore)\n        for (const exportName in newModule) {\n            const useStore = newModule[exportName];\n            // console.log('checking for', exportName)\n            if (isUseStore(useStore) && pinia._s.has(useStore.$id)) {\n                // console.log('Accepting update for', useStore.$id)\n                const id = useStore.$id;\n                if (id !== initialUseStore.$id) {\n                    console.warn(`The id of the store changed from \"${initialUseStore.$id}\" to \"${id}\". Reloading.`);\n                    // return import.meta.hot.invalidate()\n                    return hot.invalidate();\n                }\n                const existingStore = pinia._s.get(id);\n                if (!existingStore) {\n                    console.log(`[Pinia]: skipping hmr because store doesn't exist yet`);\n                    return;\n                }\n                useStore(pinia, existingStore);\n            }\n        }\n    };\n}\n\nconst noop = () => { };\nfunction addSubscription(subscriptions, callback, detached, onCleanup = noop) {\n    subscriptions.add(callback);\n    const removeSubscription = () => {\n        const isDel = subscriptions.delete(callback);\n        isDel && onCleanup();\n    };\n    if (!detached && getCurrentScope()) {\n        onScopeDispose(removeSubscription);\n    }\n    return removeSubscription;\n}\nfunction triggerSubscriptions(subscriptions, ...args) {\n    subscriptions.forEach((callback) => {\n        callback(...args);\n    });\n}\n\nconst fallbackRunWithContext = (fn) => fn();\n/**\n * Marks a function as an action for `$onAction`\n * @internal\n */\nconst ACTION_MARKER = Symbol();\n/**\n * Action name symbol. Allows to add a name to an action after defining it\n * @internal\n */\nconst ACTION_NAME = Symbol();\nfunction mergeReactiveObjects(target, patchToApply) {\n    // Handle Map instances\n    if (target instanceof Map && patchToApply instanceof Map) {\n        patchToApply.forEach((value, key) => target.set(key, value));\n    }\n    else if (target instanceof Set && patchToApply instanceof Set) {\n        // Handle Set instances\n        patchToApply.forEach(target.add, target);\n    }\n    // no need to go through symbols because they cannot be serialized anyway\n    for (const key in patchToApply) {\n        if (!patchToApply.hasOwnProperty(key))\n            continue;\n        const subPatch = patchToApply[key];\n        const targetValue = target[key];\n        if (isPlainObject(targetValue) &&\n            isPlainObject(subPatch) &&\n            target.hasOwnProperty(key) &&\n            !isRef(subPatch) &&\n            !isReactive(subPatch)) {\n            // NOTE: here I wanted to warn about inconsistent types but it's not possible because in setup stores one might\n            // start the value of a property as a certain type e.g. a Map, and then for some reason, during SSR, change that\n            // to `undefined`. When trying to hydrate, we want to override the Map with `undefined`.\n            target[key] = mergeReactiveObjects(targetValue, subPatch);\n        }\n        else {\n            // @ts-expect-error: subPatch is a valid value\n            target[key] = subPatch;\n        }\n    }\n    return target;\n}\nconst skipHydrateSymbol = (process.env.NODE_ENV !== 'production')\n    ? Symbol('pinia:skipHydration')\n    : /* istanbul ignore next */ Symbol();\n/**\n * Tells Pinia to skip the hydration process of a given object. This is useful in setup stores (only) when you return a\n * stateful object in the store but it isn't really state. e.g. returning a router instance in a setup store.\n *\n * @param obj - target object\n * @returns obj\n */\nfunction skipHydrate(obj) {\n    return Object.defineProperty(obj, skipHydrateSymbol, {});\n}\n/**\n * Returns whether a value should be hydrated\n *\n * @param obj - target variable\n * @returns true if `obj` should be hydrated\n */\nfunction shouldHydrate(obj) {\n    return (!isPlainObject(obj) ||\n        !Object.prototype.hasOwnProperty.call(obj, skipHydrateSymbol));\n}\nconst { assign } = Object;\nfunction isComputed(o) {\n    return !!(isRef(o) && o.effect);\n}\nfunction createOptionsStore(id, options, pinia, hot) {\n    const { state, actions, getters } = options;\n    const initialState = pinia.state.value[id];\n    let store;\n    function setup() {\n        if (!initialState && (!(process.env.NODE_ENV !== 'production') || !hot)) {\n            /* istanbul ignore if */\n            pinia.state.value[id] = state ? state() : {};\n        }\n        // avoid creating a state in pinia.state.value\n        const localState = (process.env.NODE_ENV !== 'production') && hot\n            ? // use ref() to unwrap refs inside state TODO: check if this is still necessary\n                toRefs(ref(state ? state() : {}).value)\n            : toRefs(pinia.state.value[id]);\n        return assign(localState, actions, Object.keys(getters || {}).reduce((computedGetters, name) => {\n            if ((process.env.NODE_ENV !== 'production') && name in localState) {\n                console.warn(`[ðŸ]: A getter cannot have the same name as another state property. Rename one of them. Found with \"${name}\" in store \"${id}\".`);\n            }\n            computedGetters[name] = markRaw(computed(() => {\n                setActivePinia(pinia);\n                // it was created just before\n                const store = pinia._s.get(id);\n                // allow cross using stores\n                // @ts-expect-error\n                // return getters![name].call(context, context)\n                // TODO: avoid reading the getter while assigning with a global variable\n                return getters[name].call(store, store);\n            }));\n            return computedGetters;\n        }, {}));\n    }\n    store = createSetupStore(id, setup, options, pinia, hot, true);\n    return store;\n}\nfunction createSetupStore($id, setup, options = {}, pinia, hot, isOptionsStore) {\n    let scope;\n    const optionsForPlugin = assign({ actions: {} }, options);\n    /* istanbul ignore if */\n    if ((process.env.NODE_ENV !== 'production') && !pinia._e.active) {\n        throw new Error('Pinia destroyed');\n    }\n    // watcher options for $subscribe\n    const $subscribeOptions = { deep: true };\n    /* istanbul ignore else */\n    if ((process.env.NODE_ENV !== 'production')) {\n        $subscribeOptions.onTrigger = (event) => {\n            /* istanbul ignore else */\n            if (isListening) {\n                debuggerEvents = event;\n                // avoid triggering this while the store is being built and the state is being set in pinia\n            }\n            else if (isListening == false && !store._hotUpdating) {\n                // let patch send all the events together later\n                /* istanbul ignore else */\n                if (Array.isArray(debuggerEvents)) {\n                    debuggerEvents.push(event);\n                }\n                else {\n                    console.error('ðŸ debuggerEvents should be an array. This is most likely an internal Pinia bug.');\n                }\n            }\n        };\n    }\n    // internal state\n    let isListening; // set to true at the end\n    let isSyncListening; // set to true at the end\n    let subscriptions = new Set();\n    let actionSubscriptions = new Set();\n    let debuggerEvents;\n    const initialState = pinia.state.value[$id];\n    // avoid setting the state for option stores if it is set\n    // by the setup\n    if (!isOptionsStore && !initialState && (!(process.env.NODE_ENV !== 'production') || !hot)) {\n        /* istanbul ignore if */\n        pinia.state.value[$id] = {};\n    }\n    const hotState = ref({});\n    // avoid triggering too many listeners\n    // https://github.com/vuejs/pinia/issues/1129\n    let activeListener;\n    function $patch(partialStateOrMutator) {\n        let subscriptionMutation;\n        isListening = isSyncListening = false;\n        // reset the debugger events since patches are sync\n        /* istanbul ignore else */\n        if ((process.env.NODE_ENV !== 'production')) {\n            debuggerEvents = [];\n        }\n        if (typeof partialStateOrMutator === 'function') {\n            partialStateOrMutator(pinia.state.value[$id]);\n            subscriptionMutation = {\n                type: MutationType.patchFunction,\n                storeId: $id,\n                events: debuggerEvents,\n            };\n        }\n        else {\n            mergeReactiveObjects(pinia.state.value[$id], partialStateOrMutator);\n            subscriptionMutation = {\n                type: MutationType.patchObject,\n                payload: partialStateOrMutator,\n                storeId: $id,\n                events: debuggerEvents,\n            };\n        }\n        const myListenerId = (activeListener = Symbol());\n        nextTick().then(() => {\n            if (activeListener === myListenerId) {\n                isListening = true;\n            }\n        });\n        isSyncListening = true;\n        // because we paused the watcher, we need to manually call the subscriptions\n        triggerSubscriptions(subscriptions, subscriptionMutation, pinia.state.value[$id]);\n    }\n    const $reset = isOptionsStore\n        ? function $reset() {\n            const { state } = options;\n            const newState = state ? state() : {};\n            // we use a patch to group all changes into one single subscription\n            this.$patch(($state) => {\n                // @ts-expect-error: FIXME: shouldn't error?\n                assign($state, newState);\n            });\n        }\n        : /* istanbul ignore next */\n            (process.env.NODE_ENV !== 'production')\n                ? () => {\n                    throw new Error(`ðŸ: Store \"${$id}\" is built using the setup syntax and does not implement $reset().`);\n                }\n                : noop;\n    function $dispose() {\n        scope.stop();\n        subscriptions.clear();\n        actionSubscriptions.clear();\n        pinia._s.delete($id);\n    }\n    /**\n     * Helper that wraps function so it can be tracked with $onAction\n     * @param fn - action to wrap\n     * @param name - name of the action\n     */\n    const action = (fn, name = '') => {\n        if (ACTION_MARKER in fn) {\n            fn[ACTION_NAME] = name;\n            return fn;\n        }\n        const wrappedAction = function () {\n            setActivePinia(pinia);\n            const args = Array.from(arguments);\n            const afterCallbackSet = new Set();\n            const onErrorCallbackSet = new Set();\n            function after(callback) {\n                afterCallbackSet.add(callback);\n            }\n            function onError(callback) {\n                onErrorCallbackSet.add(callback);\n            }\n            // @ts-expect-error\n            triggerSubscriptions(actionSubscriptions, {\n                args,\n                name: wrappedAction[ACTION_NAME],\n                store,\n                after,\n                onError,\n            });\n            let ret;\n            try {\n                ret = fn.apply(this && this.$id === $id ? this : store, args);\n                // handle sync errors\n            }\n            catch (error) {\n                triggerSubscriptions(onErrorCallbackSet, error);\n                throw error;\n            }\n            if (ret instanceof Promise) {\n                return ret\n                    .then((value) => {\n                    triggerSubscriptions(afterCallbackSet, value);\n                    return value;\n                })\n                    .catch((error) => {\n                    triggerSubscriptions(onErrorCallbackSet, error);\n                    return Promise.reject(error);\n                });\n            }\n            // trigger after callbacks\n            triggerSubscriptions(afterCallbackSet, ret);\n            return ret;\n        };\n        wrappedAction[ACTION_MARKER] = true;\n        wrappedAction[ACTION_NAME] = name; // will be set later\n        // @ts-expect-error: we are intentionally limiting the returned type to just Fn\n        // because all the added properties are internals that are exposed through `$onAction()` only\n        return wrappedAction;\n    };\n    const _hmrPayload = /*#__PURE__*/ markRaw({\n        actions: {},\n        getters: {},\n        state: [],\n        hotState,\n    });\n    const partialStore = {\n        _p: pinia,\n        // _s: scope,\n        $id,\n        $onAction: addSubscription.bind(null, actionSubscriptions),\n        $patch,\n        $reset,\n        $subscribe(callback, options = {}) {\n            const removeSubscription = addSubscription(subscriptions, callback, options.detached, () => stopWatcher());\n            const stopWatcher = scope.run(() => watch(() => pinia.state.value[$id], (state) => {\n                if (options.flush === 'sync' ? isSyncListening : isListening) {\n                    callback({\n                        storeId: $id,\n                        type: MutationType.direct,\n                        events: debuggerEvents,\n                    }, state);\n                }\n            }, assign({}, $subscribeOptions, options)));\n            return removeSubscription;\n        },\n        $dispose,\n    };\n    const store = reactive((process.env.NODE_ENV !== 'production') || ((((process.env.NODE_ENV !== 'production') || (typeof __VUE_PROD_DEVTOOLS__ !== 'undefined' && __VUE_PROD_DEVTOOLS__)) && !(process.env.NODE_ENV === 'test')) && IS_CLIENT)\n        ? assign({\n            _hmrPayload,\n            _customProperties: markRaw(new Set()), // devtools custom properties\n        }, partialStore\n        // must be added later\n        // setupStore\n        )\n        : partialStore);\n    // store the partial store now so the setup of stores can instantiate each other before they are finished without\n    // creating infinite loops.\n    pinia._s.set($id, store);\n    const runWithContext = (pinia._a && pinia._a.runWithContext) || fallbackRunWithContext;\n    // TODO: idea create skipSerialize that marks properties as non serializable and they are skipped\n    const setupStore = runWithContext(() => pinia._e.run(() => (scope = effectScope()).run(() => setup({ action }))));\n    // overwrite existing actions to support $onAction\n    for (const key in setupStore) {\n        const prop = setupStore[key];\n        if ((isRef(prop) && !isComputed(prop)) || isReactive(prop)) {\n            // mark it as a piece of state to be serialized\n            if ((process.env.NODE_ENV !== 'production') && hot) {\n                hotState.value[key] = toRef(setupStore, key);\n                // createOptionStore directly sets the state in pinia.state.value so we\n                // can just skip that\n            }\n            else if (!isOptionsStore) {\n                // in setup stores we must hydrate the state and sync pinia state tree with the refs the user just created\n                if (initialState && shouldHydrate(prop)) {\n                    if (isRef(prop)) {\n                        prop.value = initialState[key];\n                    }\n                    else {\n                        // probably a reactive object, lets recursively assign\n                        // @ts-expect-error: prop is unknown\n                        mergeReactiveObjects(prop, initialState[key]);\n                    }\n                }\n                // transfer the ref to the pinia state to keep everything in sync\n                pinia.state.value[$id][key] = prop;\n            }\n            /* istanbul ignore else */\n            if ((process.env.NODE_ENV !== 'production')) {\n                _hmrPayload.state.push(key);\n            }\n            // action\n        }\n        else if (typeof prop === 'function') {\n            const actionValue = (process.env.NODE_ENV !== 'production') && hot ? prop : action(prop, key);\n            // this a hot module replacement store because the hotUpdate method needs\n            // to do it with the right context\n            // @ts-expect-error\n            setupStore[key] = actionValue;\n            /* istanbul ignore else */\n            if ((process.env.NODE_ENV !== 'production')) {\n                _hmrPayload.actions[key] = prop;\n            }\n            // list actions so they can be used in plugins\n            // @ts-expect-error\n            optionsForPlugin.actions[key] = prop;\n        }\n        else if ((process.env.NODE_ENV !== 'production')) {\n            // add getters for devtools\n            if (isComputed(prop)) {\n                _hmrPayload.getters[key] = isOptionsStore\n                    ? // @ts-expect-error\n                        options.getters[key]\n                    : prop;\n                if (IS_CLIENT) {\n                    const getters = setupStore._getters ||\n                        // @ts-expect-error: same\n                        (setupStore._getters = markRaw([]));\n                    getters.push(key);\n                }\n            }\n        }\n    }\n    // add the state, getters, and action properties\n    /* istanbul ignore if */\n    assign(store, setupStore);\n    // allows retrieving reactive objects with `storeToRefs()`. Must be called after assigning to the reactive object.\n    // Make `storeToRefs()` work with `reactive()` #799\n    assign(toRaw(store), setupStore);\n    // use this instead of a computed with setter to be able to create it anywhere\n    // without linking the computed lifespan to wherever the store is first\n    // created.\n    Object.defineProperty(store, '$state', {\n        get: () => ((process.env.NODE_ENV !== 'production') && hot ? hotState.value : pinia.state.value[$id]),\n        set: (state) => {\n            /* istanbul ignore if */\n            if ((process.env.NODE_ENV !== 'production') && hot) {\n                throw new Error('cannot set hotState');\n            }\n            $patch(($state) => {\n                // @ts-expect-error: FIXME: shouldn't error?\n                assign($state, state);\n            });\n        },\n    });\n    // add the hotUpdate before plugins to allow them to override it\n    /* istanbul ignore else */\n    if ((process.env.NODE_ENV !== 'production')) {\n        store._hotUpdate = markRaw((newStore) => {\n            store._hotUpdating = true;\n            newStore._hmrPayload.state.forEach((stateKey) => {\n                if (stateKey in store.$state) {\n                    const newStateTarget = newStore.$state[stateKey];\n                    const oldStateSource = store.$state[stateKey];\n                    if (typeof newStateTarget === 'object' &&\n                        isPlainObject(newStateTarget) &&\n                        isPlainObject(oldStateSource)) {\n                        patchObject(newStateTarget, oldStateSource);\n                    }\n                    else {\n                        // transfer the ref\n                        newStore.$state[stateKey] = oldStateSource;\n                    }\n                }\n                // patch direct access properties to allow store.stateProperty to work as\n                // store.$state.stateProperty\n                // @ts-expect-error: any type\n                store[stateKey] = toRef(newStore.$state, stateKey);\n            });\n            // remove deleted state properties\n            Object.keys(store.$state).forEach((stateKey) => {\n                if (!(stateKey in newStore.$state)) {\n                    // @ts-expect-error: noop if doesn't exist\n                    delete store[stateKey];\n                }\n            });\n            // avoid devtools logging this as a mutation\n            isListening = false;\n            isSyncListening = false;\n            pinia.state.value[$id] = toRef(newStore._hmrPayload, 'hotState');\n            isSyncListening = true;\n            nextTick().then(() => {\n                isListening = true;\n            });\n            for (const actionName in newStore._hmrPayload.actions) {\n                const actionFn = newStore[actionName];\n                // @ts-expect-error: actionName is a string\n                store[actionName] =\n                    //\n                    action(actionFn, actionName);\n            }\n            // TODO: does this work in both setup and option store?\n            for (const getterName in newStore._hmrPayload.getters) {\n                const getter = newStore._hmrPayload.getters[getterName];\n                const getterValue = isOptionsStore\n                    ? // special handling of options api\n                        computed(() => {\n                            setActivePinia(pinia);\n                            return getter.call(store, store);\n                        })\n                    : getter;\n                // @ts-expect-error: getterName is a string\n                store[getterName] =\n                    //\n                    getterValue;\n            }\n            // remove deleted getters\n            Object.keys(store._hmrPayload.getters).forEach((key) => {\n                if (!(key in newStore._hmrPayload.getters)) {\n                    // @ts-expect-error: noop if doesn't exist\n                    delete store[key];\n                }\n            });\n            // remove old actions\n            Object.keys(store._hmrPayload.actions).forEach((key) => {\n                if (!(key in newStore._hmrPayload.actions)) {\n                    // @ts-expect-error: noop if doesn't exist\n                    delete store[key];\n                }\n            });\n            // update the values used in devtools and to allow deleting new properties later on\n            store._hmrPayload = newStore._hmrPayload;\n            store._getters = newStore._getters;\n            store._hotUpdating = false;\n        });\n    }\n    if ((((process.env.NODE_ENV !== 'production') || (typeof __VUE_PROD_DEVTOOLS__ !== 'undefined' && __VUE_PROD_DEVTOOLS__)) && !(process.env.NODE_ENV === 'test')) && IS_CLIENT) {\n        const nonEnumerable = {\n            writable: true,\n            configurable: true,\n            // avoid warning on devtools trying to display this property\n            enumerable: false,\n        };\n        ['_p', '_hmrPayload', '_getters', '_customProperties'].forEach((p) => {\n            Object.defineProperty(store, p, assign({ value: store[p] }, nonEnumerable));\n        });\n    }\n    // apply all plugins\n    pinia._p.forEach((extender) => {\n        /* istanbul ignore else */\n        if ((((process.env.NODE_ENV !== 'production') || (typeof __VUE_PROD_DEVTOOLS__ !== 'undefined' && __VUE_PROD_DEVTOOLS__)) && !(process.env.NODE_ENV === 'test')) && IS_CLIENT) {\n            const extensions = scope.run(() => extender({\n                store: store,\n                app: pinia._a,\n                pinia,\n                options: optionsForPlugin,\n            }));\n            Object.keys(extensions || {}).forEach((key) => store._customProperties.add(key));\n            assign(store, extensions);\n        }\n        else {\n            assign(store, scope.run(() => extender({\n                store: store,\n                app: pinia._a,\n                pinia,\n                options: optionsForPlugin,\n            })));\n        }\n    });\n    if ((process.env.NODE_ENV !== 'production') &&\n        store.$state &&\n        typeof store.$state === 'object' &&\n        typeof store.$state.constructor === 'function' &&\n        !store.$state.constructor.toString().includes('[native code]')) {\n        console.warn(`[ðŸ]: The \"state\" must be a plain object. It cannot be\\n` +\n            `\\tstate: () => new MyClass()\\n` +\n            `Found in store \"${store.$id}\".`);\n    }\n    // only apply hydrate to option stores with an initial state in pinia\n    if (initialState &&\n        isOptionsStore &&\n        options.hydrate) {\n        options.hydrate(store.$state, initialState);\n    }\n    isListening = true;\n    isSyncListening = true;\n    return store;\n}\n// allows unused stores to be tree shaken\n/*! #__NO_SIDE_EFFECTS__ */\nfunction defineStore(\n// TODO: add proper types from above\nid, setup, setupOptions) {\n    let options;\n    const isSetupStore = typeof setup === 'function';\n    // the option store setup will contain the actual options in this case\n    options = isSetupStore ? setupOptions : setup;\n    function useStore(pinia, hot) {\n        const hasContext = hasInjectionContext();\n        pinia =\n            // in test mode, ignore the argument provided as we can always retrieve a\n            // pinia instance with getActivePinia()\n            ((process.env.NODE_ENV === 'test') && activePinia && activePinia._testing ? null : pinia) ||\n                (hasContext ? inject(piniaSymbol, null) : null);\n        if (pinia)\n            setActivePinia(pinia);\n        if ((process.env.NODE_ENV !== 'production') && !activePinia) {\n            throw new Error(`[ðŸ]: \"getActivePinia()\" was called but there was no active Pinia. Are you trying to use a store before calling \"app.use(pinia)\"?\\n` +\n                `See https://pinia.vuejs.org/core-concepts/outside-component-usage.html for help.\\n` +\n                `This will fail in production.`);\n        }\n        pinia = activePinia;\n        if (!pinia._s.has(id)) {\n            // creating the store registers it in `pinia._s`\n            if (isSetupStore) {\n                createSetupStore(id, setup, options, pinia);\n            }\n            else {\n                createOptionsStore(id, options, pinia);\n            }\n            /* istanbul ignore else */\n            if ((process.env.NODE_ENV !== 'production')) {\n                // @ts-expect-error: not the right inferred type\n                useStore._pinia = pinia;\n            }\n        }\n        const store = pinia._s.get(id);\n        if ((process.env.NODE_ENV !== 'production') && hot) {\n            const hotId = '__hot:' + id;\n            const newStore = isSetupStore\n                ? createSetupStore(hotId, setup, options, pinia, true)\n                : createOptionsStore(hotId, assign({}, options), pinia, true);\n            hot._hotUpdate(newStore);\n            // cleanup the state properties and the store from the cache\n            delete pinia.state.value[hotId];\n            pinia._s.delete(hotId);\n        }\n        if ((process.env.NODE_ENV !== 'production') && IS_CLIENT) {\n            const currentInstance = getCurrentInstance();\n            // save stores in instances to access them devtools\n            if (currentInstance &&\n                currentInstance.proxy &&\n                // avoid adding stores that are just built for hot module replacement\n                !hot) {\n                const vm = currentInstance.proxy;\n                const cache = '_pStores' in vm ? vm._pStores : (vm._pStores = {});\n                cache[id] = store;\n            }\n        }\n        // StoreGeneric cannot be casted towards Store\n        return store;\n    }\n    useStore.$id = id;\n    return useStore;\n}\n\nlet mapStoreSuffix = 'Store';\n/**\n * Changes the suffix added by `mapStores()`. Can be set to an empty string.\n * Defaults to `\"Store\"`. Make sure to extend the MapStoresCustomization\n * interface if you are using TypeScript.\n *\n * @param suffix - new suffix\n */\nfunction setMapStoreSuffix(suffix // could be 'Store' but that would be annoying for JS\n) {\n    mapStoreSuffix = suffix;\n}\n/**\n * Allows using stores without the composition API (`setup()`) by generating an\n * object to be spread in the `computed` field of a component. It accepts a list\n * of store definitions.\n *\n * @example\n * ```js\n * export default {\n *   computed: {\n *     // other computed properties\n *     ...mapStores(useUserStore, useCartStore)\n *   },\n *\n *   created() {\n *     this.userStore // store with id \"user\"\n *     this.cartStore // store with id \"cart\"\n *   }\n * }\n * ```\n *\n * @param stores - list of stores to map to an object\n */\nfunction mapStores(...stores) {\n    if ((process.env.NODE_ENV !== 'production') && Array.isArray(stores[0])) {\n        console.warn(`[ðŸ]: Directly pass all stores to \"mapStores()\" without putting them in an array:\\n` +\n            `Replace\\n` +\n            `\\tmapStores([useAuthStore, useCartStore])\\n` +\n            `with\\n` +\n            `\\tmapStores(useAuthStore, useCartStore)\\n` +\n            `This will fail in production if not fixed.`);\n        stores = stores[0];\n    }\n    return stores.reduce((reduced, useStore) => {\n        // @ts-expect-error: $id is added by defineStore\n        reduced[useStore.$id + mapStoreSuffix] = function () {\n            return useStore(this.$pinia);\n        };\n        return reduced;\n    }, {});\n}\n/**\n * Allows using state and getters from one store without using the composition\n * API (`setup()`) by generating an object to be spread in the `computed` field\n * of a component.\n *\n * @param useStore - store to map from\n * @param keysOrMapper - array or object\n */\nfunction mapState(useStore, keysOrMapper) {\n    return Array.isArray(keysOrMapper)\n        ? keysOrMapper.reduce((reduced, key) => {\n            reduced[key] = function () {\n                // @ts-expect-error: FIXME: should work?\n                return useStore(this.$pinia)[key];\n            };\n            return reduced;\n        }, {})\n        : Object.keys(keysOrMapper).reduce((reduced, key) => {\n            // @ts-expect-error\n            reduced[key] = function () {\n                const store = useStore(this.$pinia);\n                const storeKey = keysOrMapper[key];\n                // for some reason TS is unable to infer the type of storeKey to be a\n                // function\n                return typeof storeKey === 'function'\n                    ? storeKey.call(this, store)\n                    : // @ts-expect-error: FIXME: should work?\n                        store[storeKey];\n            };\n            return reduced;\n        }, {});\n}\n/**\n * Alias for `mapState()`. You should use `mapState()` instead.\n * @deprecated use `mapState()` instead.\n */\nconst mapGetters = mapState;\n/**\n * Allows directly using actions from your store without using the composition\n * API (`setup()`) by generating an object to be spread in the `methods` field\n * of a component.\n *\n * @param useStore - store to map from\n * @param keysOrMapper - array or object\n */\nfunction mapActions(useStore, keysOrMapper) {\n    return Array.isArray(keysOrMapper)\n        ? keysOrMapper.reduce((reduced, key) => {\n            // @ts-expect-error\n            reduced[key] = function (...args) {\n                // @ts-expect-error: FIXME: should work?\n                return useStore(this.$pinia)[key](...args);\n            };\n            return reduced;\n        }, {})\n        : Object.keys(keysOrMapper).reduce((reduced, key) => {\n            // @ts-expect-error\n            reduced[key] = function (...args) {\n                // @ts-expect-error: FIXME: should work?\n                return useStore(this.$pinia)[keysOrMapper[key]](...args);\n            };\n            return reduced;\n        }, {});\n}\n/**\n * Allows using state and getters from one store without using the composition\n * API (`setup()`) by generating an object to be spread in the `computed` field\n * of a component.\n *\n * @param useStore - store to map from\n * @param keysOrMapper - array or object\n */\nfunction mapWritableState(useStore, keysOrMapper) {\n    return Array.isArray(keysOrMapper)\n        ? keysOrMapper.reduce((reduced, key) => {\n            reduced[key] = {\n                get() {\n                    return useStore(this.$pinia)[key];\n                },\n                set(value) {\n                    return (useStore(this.$pinia)[key] = value);\n                },\n            };\n            return reduced;\n        }, {})\n        : Object.keys(keysOrMapper).reduce((reduced, key) => {\n            reduced[key] = {\n                get() {\n                    return useStore(this.$pinia)[keysOrMapper[key]];\n                },\n                set(value) {\n                    return (useStore(this.$pinia)[keysOrMapper[key]] = value);\n                },\n            };\n            return reduced;\n        }, {});\n}\n\n/**\n * Creates an object of references with all the state, getters, and plugin-added\n * state properties of the store. Similar to `toRefs()` but specifically\n * designed for Pinia stores so methods and non reactive properties are\n * completely ignored.\n *\n * @param store - store to extract the refs from\n */\nfunction storeToRefs(store) {\n    const rawStore = toRaw(store);\n    const refs = {};\n    for (const key in rawStore) {\n        const value = rawStore[key];\n        // There is no native method to check for a computed\n        // https://github.com/vuejs/core/pull/4165\n        if (value.effect) {\n            // @ts-expect-error: too hard to type correctly\n            refs[key] =\n                // ...\n                computed({\n                    get: () => store[key],\n                    set(value) {\n                        store[key] = value;\n                    },\n                });\n        }\n        else if (isRef(value) || isReactive(value)) {\n            // @ts-expect-error: the key is state or getter\n            refs[key] =\n                // ---\n                toRef(store, key);\n        }\n    }\n    return refs;\n}\n\nexport { MutationType, acceptHMRUpdate, createPinia, defineStore, disposePinia, getActivePinia, mapActions, mapGetters, mapState, mapStores, mapWritableState, setActivePinia, setMapStoreSuffix, shouldHydrate, skipHydrate, storeToRefs };\n","/**\n * Vue component for lazy loading LiVue components.\n *\n * Usage in server-rendered HTML:\n * <livue-lazy :config='{\"name\":\"component-name\",\"props\":{},\"onLoad\":false}'>\n *   placeholder content\n * </livue-lazy>\n *\n * When the element enters the viewport (or on page load if onLoad is true),\n * fetches the full component from the server and renders it in place of the placeholder.\n */\n\nimport {\n    ref, shallowRef, onMounted, onUnmounted, h, defineComponent,\n} from 'vue';\nimport { setErrors } from '../helpers/errors.js';\nimport { on } from './events.js';\nimport { poolLazyLoad } from './request/pool.js';\n\nlet _lazyCounter = 0;\n\n/**\n * Unwrap inline tuples from a state object.\n */\nfunction unwrapState(state) {\n    let flat = {};\n    for (let key in state) {\n        let val = state[key];\n        if (Array.isArray(val) && val.length === 2 && val[1] && typeof val[1] === 'object' && val[1].s) {\n            flat[key] = val[0];\n        } else {\n            flat[key] = val;\n        }\n    }\n    return flat;\n}\n\n/**\n * Create the livue-lazy component definition.\n *\n * @param {object} rootComponent - The LiVueComponent that owns the Vue app\n * @returns {object} Vue component definition\n */\nexport function createLazyComponent(rootComponent) {\n    return defineComponent({\n        name: 'LivueLazy',\n        props: {\n            config: {\n                type: Object,\n                required: true,\n            },\n        },\n        setup: function (props, ctx) {\n            let loaded = ref(false);\n            let loadedComponentDef = shallowRef(null);\n            let observer = null;\n            let wrapperEl = ref(null);\n\n            /**\n             * Load the lazy component via pooled request.\n             * Multiple lazy loads within the same microtask are batched together.\n             */\n            async function loadComponent() {\n                if (loaded.value) return;\n\n                try {\n                    let data = await poolLazyLoad({\n                        component: props.config.name,\n                        props: props.config.props || {},\n                    });\n\n                    if (data.html && data.snapshot) {\n                        mountLoadedContent(data);\n                    }\n                } catch (err) {\n                    console.error('[LiVue] Lazy load failed:', err);\n                }\n            }\n\n            /**\n             * Mount the loaded content as a Vue component.\n             */\n            function mountLoadedContent(data) {\n                // Parse snapshot\n                let snapshot = JSON.parse(data.snapshot);\n                _lazyCounter++;\n                let componentId = 'lazy-' + _lazyCounter + '-' + Date.now();\n                let name = snapshot.memo ? snapshot.memo.name : '';\n                let initialState = unwrapState(snapshot.state || {});\n                let memo = snapshot.memo || {};\n\n                // Get helpers from root component\n                let { createLivueHelper, buildComponentDef, processTemplate, createReactiveState } = rootComponent._lazyHelpers;\n\n                // Create reactive state\n                let childState = createReactiveState(initialState);\n                let childServerState = JSON.parse(JSON.stringify(initialState));\n\n                // Create component ref\n                let childComponentRef = { _updateTemplate: null };\n\n                // Create livue helper\n                let livue = createLivueHelper(\n                    componentId,\n                    childState,\n                    memo,\n                    childComponentRef,\n                    childServerState,\n                    data.snapshot\n                );\n\n                // Set initial errors\n                if (memo.errors) {\n                    setErrors(livue.errors, memo.errors);\n                }\n\n                // Generate unique tag name\n                let tagName = 'livue-lazy-child-' + _lazyCounter;\n\n                // Process the HTML for nested children\n                let processed = processTemplate(data.html, rootComponent);\n\n                // Build wrapper template\n                let template = '<div data-livue-id=\"' + componentId + '\">' + processed.template + '</div>';\n\n                // Create component definition\n                let componentDef = buildComponentDef(template, childState, livue, rootComponent._versions, name);\n\n                // Register child in the registry\n                rootComponent._childRegistry[componentId] = {\n                    tagName: tagName,\n                    state: childState,\n                    memo: memo,\n                    livue: livue,\n                    componentRef: childComponentRef,\n                    name: name,\n                    id: componentId,\n                };\n\n                // Set up template update function\n                childComponentRef._updateTemplate = function (newInnerHtml) {\n                    let childProcessed = processTemplate(newInnerHtml, rootComponent);\n                    let newTemplate = '<div data-livue-id=\"' + componentId + '\">' + childProcessed.template + '</div>';\n\n                    // Register any nested children (only if not already registered)\n                    for (let ct in childProcessed.childDefs) {\n                        if (!rootComponent.vueApp._context.components[ct]) {\n                            rootComponent.vueApp.component(ct, childProcessed.childDefs[ct]);\n                        }\n                    }\n\n                    // Build the new component definition\n                    let newComponentDef = buildComponentDef(newTemplate, childState, livue, rootComponent._versions, name);\n\n                    // Update component definition directly to avoid \"already registered\" warning\n                    rootComponent.vueApp._context.components[tagName] = newComponentDef;\n                    rootComponent._versions[tagName] = (rootComponent._versions[tagName] || 0) + 1;\n\n                    // Update the shallowRef so Vue re-renders the lazy wrapper\n                    loadedComponentDef.value = newComponentDef;\n                };\n\n                // Register event listeners\n                let listeners = memo.listeners || null;\n                if (listeners) {\n                    for (let eventName in listeners) {\n                        (function (method, childLivue) {\n                            on(eventName, name, componentId, function (eventData) {\n                                childLivue.call(method, eventData);\n                            });\n                        })(listeners[eventName], livue);\n                    }\n                }\n\n                // Register any nested children in the app\n                // Only register if not already registered to avoid Vue warnings\n                for (let ct in processed.childDefs) {\n                    if (!rootComponent.vueApp._context.components[ct]) {\n                        rootComponent.vueApp.component(ct, processed.childDefs[ct]);\n                    }\n                }\n\n                // Initialize version\n                rootComponent._versions[tagName] = 0;\n\n                // Register the component in the Vue app\n                // Only register if not already registered to avoid Vue warnings\n                if (!rootComponent.vueApp._context.components[tagName]) {\n                    rootComponent.vueApp.component(tagName, componentDef);\n                }\n\n                // Store the component definition and mark as loaded\n                loadedComponentDef.value = componentDef;\n                loaded.value = true;\n            }\n\n            onMounted(function () {\n                if (props.config.onLoad) {\n                    // Load immediately after mount (deferred)\n                    requestAnimationFrame(function () {\n                        loadComponent();\n                    });\n                } else {\n                    // Use IntersectionObserver\n                    observer = new IntersectionObserver(function (entries) {\n                        if (entries[0].isIntersecting) {\n                            observer.disconnect();\n                            observer = null;\n                            loadComponent();\n                        }\n                    }, { rootMargin: '50px' });\n\n                    if (wrapperEl.value) {\n                        observer.observe(wrapperEl.value);\n                    }\n                }\n            });\n\n            onUnmounted(function () {\n                if (observer) {\n                    observer.disconnect();\n                    observer = null;\n                }\n            });\n\n            return function () {\n                if (loaded.value && loadedComponentDef.value) {\n                    // Render the loaded component\n                    return h(loadedComponentDef.value);\n                } else {\n                    // Render placeholder (slot content wrapped in a div for the observer)\n                    return h('div', { ref: wrapperEl }, ctx.slots.default ? ctx.slots.default() : null);\n                }\n            };\n        },\n    });\n}\n","/**\n * Debounce and throttle utilities for LiVue action modifiers.\n *\n * Provides cached debounced/throttled versions of functions per method+delay,\n * so that repeated calls with the same modifier reuse the same timer.\n */\n\n/**\n * Cache for debounced functions.\n * Key: \"componentId:method:ms\"\n * @type {Map<string, Function>}\n */\nlet _debounceMap = new Map();\n\n/**\n * Cache for throttled functions.\n * Key: \"componentId:method:ms\"\n * @type {Map<string, Function>}\n */\nlet _throttleMap = new Map();\n\n/**\n * Get or create a debounced executor.\n * The actual function to execute is passed as an argument each time.\n * This allows the debouncer to always execute the latest function.\n *\n * @param {string} key - Unique key (e.g., \"livue-123:search\")\n * @param {number} ms - Delay in milliseconds\n * @returns {Function} - Debounced executor: (fn) => Promise\n */\nexport function getDebounced(key, ms) {\n    let cacheKey = key + ':debounce:' + ms;\n\n    if (!_debounceMap.has(cacheKey)) {\n        let timer = null;\n        let latestFn = null;\n        let latestResolve = null;\n        let latestReject = null;\n\n        let debounced = function (fn) {\n            // Always capture the latest function to execute\n            latestFn = fn;\n\n            clearTimeout(timer);\n\n            return new Promise(function (resolve, reject) {\n                // Store the latest promise callbacks\n                latestResolve = resolve;\n                latestReject = reject;\n\n                timer = setTimeout(function () {\n                    // Use the latest captured function\n                    let fnToRun = latestFn;\n                    let resolveToUse = latestResolve;\n                    let rejectToUse = latestReject;\n\n                    // Reset state\n                    latestFn = null;\n                    latestResolve = null;\n                    latestReject = null;\n\n                    Promise.resolve(fnToRun())\n                        .then(resolveToUse)\n                        .catch(rejectToUse);\n                }, ms);\n            });\n        };\n\n        _debounceMap.set(cacheKey, debounced);\n    }\n\n    return _debounceMap.get(cacheKey);\n}\n\n/**\n * Get or create a throttled executor.\n * The actual function to execute is passed as an argument each time.\n * Calls during the cooldown period are dropped.\n *\n * @param {string} key - Unique key (e.g., \"livue-123:increment\")\n * @param {number} ms - Minimum interval in milliseconds\n * @returns {Function} - Throttled executor: (fn) => Promise (or null if dropped)\n */\nexport function getThrottled(key, ms) {\n    let cacheKey = key + ':throttle:' + ms;\n\n    if (!_throttleMap.has(cacheKey)) {\n        let lastRun = 0;\n\n        let throttled = function (fn) {\n            let now = Date.now();\n\n            if (now - lastRun < ms) {\n                // Still in cooldown, drop this call\n                return Promise.resolve(null);\n            }\n\n            lastRun = now;\n            return Promise.resolve(fn());\n        };\n\n        _throttleMap.set(cacheKey, throttled);\n    }\n\n    return _throttleMap.get(cacheKey);\n}\n\n/**\n * Clear all modifiers for a specific component (on destroy).\n *\n * @param {string} componentId - The component ID prefix to clear\n */\nexport function clearModifiers(componentId) {\n    let prefix = componentId + ':';\n\n    for (let key of _debounceMap.keys()) {\n        if (key.startsWith(prefix)) {\n            _debounceMap.delete(key);\n        }\n    }\n\n    for (let key of _throttleMap.keys()) {\n        if (key.startsWith(prefix)) {\n            _throttleMap.delete(key);\n        }\n    }\n}\n\nexport default {\n    getDebounced,\n    getThrottled,\n    clearModifiers,\n};\n","/**\n * Cross-tab state synchronization for LiVue.\n *\n * Uses BroadcastChannel API (modern browsers) with localStorage fallback\n * (older browsers). Components with #[TabSync] attribute will automatically\n * sync their state across browser tabs.\n */\n\nconst CHANNEL_NAME = 'livue-tab-sync';\n\n/**\n * Unique identifier for this tab to avoid processing own messages.\n * @type {string}\n */\nlet _tabId = Date.now() + '-' + Math.random().toString(36).substr(2, 9);\n\n/**\n * BroadcastChannel instance (null if not supported).\n * @type {BroadcastChannel|null}\n */\nlet _channel = null;\n\n/**\n * Map of component name -> callback for receiving updates.\n * @type {Map<string, Function>}\n */\nlet _listeners = new Map();\n\n/**\n * Whether the broadcast system has been initialized.\n * @type {boolean}\n */\nlet _initialized = false;\n\n/**\n * Initialize the broadcast system.\n * Called automatically on first register/broadcast.\n */\nfunction init() {\n    if (_initialized) return;\n    _initialized = true;\n\n    if (typeof BroadcastChannel !== 'undefined') {\n        // Modern browsers: use BroadcastChannel\n        _channel = new BroadcastChannel(CHANNEL_NAME);\n        _channel.onmessage = handleMessage;\n    } else {\n        // Fallback: use localStorage events\n        window.addEventListener('storage', handleStorageEvent);\n    }\n}\n\n/**\n * Handle incoming BroadcastChannel message.\n *\n * @param {MessageEvent} event\n */\nfunction handleMessage(event) {\n    let data = event.data;\n\n    // Ignore own messages\n    if (data.tabId === _tabId) return;\n\n    processIncoming(data);\n}\n\n/**\n * Handle localStorage storage event (fallback for older browsers).\n *\n * @param {StorageEvent} event\n */\nfunction handleStorageEvent(event) {\n    if (event.key !== CHANNEL_NAME) return;\n    if (!event.newValue) return;\n\n    try {\n        let data = JSON.parse(event.newValue);\n\n        // Ignore own messages\n        if (data.tabId === _tabId) return;\n\n        processIncoming(data);\n    } catch (e) {\n        // Ignore parse errors\n    }\n}\n\n/**\n * Process an incoming sync message.\n *\n * @param {object} data - { tabId, component, state, properties, config }\n */\nfunction processIncoming(data) {\n    let callback = _listeners.get(data.component);\n\n    if (callback) {\n        callback(data.state, data.properties, data.config);\n    }\n}\n\n/**\n * Register a component to receive tab sync updates.\n *\n * @param {string} componentName - The component name (e.g., 'shopping-cart')\n * @param {Function} callback - function(state, properties, config)\n */\nexport function register(componentName, callback) {\n    init();\n    _listeners.set(componentName, callback);\n}\n\n/**\n * Unregister a component from tab sync.\n *\n * @param {string} componentName\n */\nexport function unregister(componentName) {\n    _listeners.delete(componentName);\n}\n\n/**\n * Broadcast a state change to other tabs.\n *\n * @param {string} componentName - The component name\n * @param {object} state - The state to broadcast (already filtered by config)\n * @param {string[]} properties - Which properties changed\n * @param {object} config - TabSync config { enabled, only, except }\n */\nexport function broadcast(componentName, state, properties, config) {\n    init();\n\n    let message = {\n        tabId: _tabId,\n        component: componentName,\n        state: state,\n        properties: properties,\n        config: config,\n    };\n\n    if (_channel) {\n        // BroadcastChannel\n        _channel.postMessage(message);\n    } else {\n        // localStorage fallback\n        // Set the value, then immediately remove it.\n        // Other tabs will catch the 'storage' event.\n        try {\n            localStorage.setItem(CHANNEL_NAME, JSON.stringify(message));\n            localStorage.removeItem(CHANNEL_NAME);\n        } catch (e) {\n            // localStorage might be full or disabled\n        }\n    }\n}\n\n/**\n * Filter state based on TabSync configuration.\n *\n * @param {object} state - Full state object\n * @param {string[]} properties - Properties that changed\n * @param {object} config - { only?: string[], except?: string[] }\n * @returns {object} Filtered state with only allowed properties\n */\nexport function filterState(state, properties, config) {\n    let filtered = {};\n\n    for (let prop of properties) {\n        // Skip if 'only' is set and prop not in it\n        if (config.only && !config.only.includes(prop)) {\n            continue;\n        }\n\n        // Skip if 'except' is set and prop is in it\n        if (config.except && config.except.includes(prop)) {\n            continue;\n        }\n\n        if (prop in state) {\n            filtered[prop] = state[prop];\n        }\n    }\n\n    return filtered;\n}\n\n/**\n * Get the current tab ID (useful for debugging).\n *\n * @returns {string}\n */\nexport function getTabId() {\n    return _tabId;\n}\n\nexport default {\n    register,\n    unregister,\n    broadcast,\n    filterState,\n    getTabId,\n};\n","/**\n * v-transition Directive\n *\n * Enables smooth animations using the browser's View Transitions API.\n * Uses the browser's View Transitions API for smooth updates.\n *\n * Usage:\n *   <div v-transition>...</div>                   <!-- Auto-generated name -->\n *   <div v-transition=\"'sidebar'\">...</div>       <!-- Custom transition name -->\n *   <div v-transition.skip>...</div>              <!-- Skip transition for this element -->\n *\n * The directive sets CSS view-transition-name on the element.\n * The LiVue runtime automatically uses startViewTransition() when updating\n * components that contain elements with v-transition.\n *\n * CSS customization:\n *   ::view-transition-old(sidebar) { animation: fade-out 0.2s; }\n *   ::view-transition-new(sidebar) { animation: fade-in 0.2s; }\n *\n * Browser support:\n *   Chrome 111+, Edge 111+, Safari 18+\n *   Firefox 144+ (basic support)\n *   Falls back gracefully in unsupported browsers.\n */\n\n/**\n * Counter for auto-generated transition names.\n */\nlet _transitionCounter = 0;\n\n/**\n * Check if View Transitions API is supported.\n *\n * @returns {boolean}\n */\nexport function isViewTransitionsSupported() {\n    return typeof document !== 'undefined' && 'startViewTransition' in document;\n}\n\n/**\n * WeakMap to store transition state.\n * @type {WeakMap<HTMLElement, object>}\n */\nconst transitionState = new WeakMap();\n\n/**\n * Global flag to track if any component has v-transition elements.\n * Used by the component update system to decide whether to use startViewTransition.\n */\nlet _hasTransitions = false;\n\n/**\n * Check if there are any elements with v-transition in the document.\n *\n * @returns {boolean}\n */\nexport function hasActiveTransitions() {\n    return _hasTransitions;\n}\n\n/**\n * Set the global transitions flag.\n *\n * @param {boolean} value\n */\nfunction updateTransitionsFlag(value) {\n    _hasTransitions = value;\n}\n\n/**\n * Recount active transitions in the document.\n */\nfunction recountTransitions() {\n    let count = document.querySelectorAll('[data-livue-transition]').length;\n    updateTransitionsFlag(count > 0);\n}\n\nexport default {\n    created(el, binding) {\n        let modifiers = binding.modifiers || {};\n\n        // Skip modifier - don't apply transition to this element\n        if (modifiers.skip) {\n            el.setAttribute('data-livue-transition-skip', '');\n            return;\n        }\n\n        // Determine transition name\n        let transitionName = binding.value;\n\n        if (!transitionName) {\n            // Auto-generate a unique name\n            _transitionCounter++;\n            transitionName = 'livue-transition-' + _transitionCounter;\n        }\n\n        // Store state\n        transitionState.set(el, {\n            name: transitionName,\n        });\n\n        // Mark element for transition detection\n        el.setAttribute('data-livue-transition', transitionName);\n\n        // Apply CSS view-transition-name\n        if (isViewTransitionsSupported()) {\n            el.style.viewTransitionName = transitionName;\n        }\n    },\n\n    mounted(el, binding) {\n        // Update global flag\n        recountTransitions();\n    },\n\n    updated(el, binding) {\n        let state = transitionState.get(el);\n\n        // Check if value changed\n        if (binding.value !== binding.oldValue && binding.value) {\n            let newName = binding.value;\n\n            if (state) {\n                state.name = newName;\n            }\n\n            el.setAttribute('data-livue-transition', newName);\n\n            if (isViewTransitionsSupported()) {\n                el.style.viewTransitionName = newName;\n            }\n        }\n    },\n\n    unmounted(el) {\n        transitionState.delete(el);\n        el.removeAttribute('data-livue-transition');\n\n        // Update global flag\n        recountTransitions();\n    },\n};\n\n/**\n * Execute a callback with View Transitions if supported.\n * Falls back to direct execution if not supported.\n * The View Transitions API automatically handles only elements with view-transition-name set.\n *\n * @param {Function} callback - The DOM mutation callback\n * @param {object} [options] - Options\n * @param {string} [options.type] - Transition type (e.g., 'forward', 'backward')\n * @returns {Promise<void>}\n */\nexport function withViewTransition(callback, options = {}) {\n    // Check for reduced motion preference\n    if (typeof window !== 'undefined' && window.matchMedia) {\n        let reducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)');\n        if (reducedMotion.matches) {\n            callback();\n            return Promise.resolve();\n        }\n    }\n\n    // Set transition type class if provided\n    if (options.type) {\n        document.documentElement.classList.add('livue-transition-' + options.type);\n    }\n\n    // Use View Transitions API\n    let transition = document.startViewTransition(callback);\n\n    return transition.finished.then(function () {\n        // Clean up type class\n        if (options.type) {\n            document.documentElement.classList.remove('livue-transition-' + options.type);\n        }\n    }).catch(function () {\n        // Clean up on error too\n        if (options.type) {\n            document.documentElement.classList.remove('livue-transition-' + options.type);\n        }\n    });\n}\n","/**\n * LiVue Streaming Module\n *\n * Handles HTTP streaming requests using fetch with ReadableStream.\n * Processes NDJSON (newline-delimited JSON) chunks from the server.\n */\n\nimport { getToken } from '../../helpers/csrf.js';\n\n/**\n * Registry of stream targets.\n * Maps target IDs to DOM elements with v-stream directive.\n *\n * @type {Map<string, { el: HTMLElement, replace: boolean }>}\n */\nexport const streamTargets = new Map();\n\n/**\n * Current streaming state.\n * Used by components to track streaming status.\n */\nexport let streamingState = {\n    active: false,\n    method: null,\n    componentId: null,\n};\n\n/**\n * Send a streaming request to the server.\n *\n * @param {Object} payload - Request payload\n * @param {string} payload.snapshot - Component snapshot JSON string\n * @param {Object} payload.diffs - Client-side state changes\n * @param {string} payload.method - Method to call\n * @param {Array} payload.params - Method parameters\n * @param {Object} callbacks - Callback functions\n * @param {Function} callbacks.onChunk - Called for each stream chunk\n * @param {Function} callbacks.onComplete - Called when streaming completes\n * @param {Function} callbacks.onError - Called on error\n * @returns {Promise<Object>} Final response from server\n */\nexport async function streamRequest(payload, callbacks = {}) {\n    const {\n        onChunk = () => {},\n        onComplete = () => {},\n        onError = () => {},\n    } = callbacks;\n\n    // Update streaming state\n    streamingState = {\n        active: true,\n        method: payload.method,\n        componentId: payload.componentId || null,\n    };\n\n    try {\n        const response = await fetch('/livue/stream', {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n                'Accept': 'application/x-ndjson',\n                'X-CSRF-TOKEN': getToken(),\n                'X-Requested-With': 'XMLHttpRequest',\n            },\n            body: JSON.stringify({\n                snapshot: payload.snapshot,\n                diffs: payload.diffs || {},\n                method: payload.method,\n                params: payload.params || [],\n            }),\n        });\n\n        if (!response.ok) {\n            throw new Error(`HTTP error: ${response.status}`);\n        }\n\n        const reader = response.body.getReader();\n        const decoder = new TextDecoder();\n        let buffer = '';\n        let finalResponse = null;\n\n        while (true) {\n            const { done, value } = await reader.read();\n\n            if (done) {\n                break;\n            }\n\n            // Decode and append to buffer\n            buffer += decoder.decode(value, { stream: true });\n\n            // Process complete lines (NDJSON format)\n            const lines = buffer.split('\\n');\n            buffer = lines.pop() || ''; // Keep incomplete line in buffer\n\n            for (const line of lines) {\n                if (!line.trim()) {\n                    continue;\n                }\n\n                try {\n                    const data = JSON.parse(line);\n\n                    if (data.stream) {\n                        // Stream chunk - apply to DOM\n                        applyStreamChunk(data.stream);\n                        onChunk(data.stream);\n                    } else if (data.error) {\n                        // Error response\n                        throw new Error(data.error);\n                    } else if (data.snapshot) {\n                        // Final response\n                        finalResponse = data;\n                    }\n                } catch (parseError) {\n                    console.error('[LiVue Stream] Parse error:', parseError, line);\n                }\n            }\n        }\n\n        // Process any remaining data in buffer\n        if (buffer.trim()) {\n            try {\n                const data = JSON.parse(buffer);\n\n                if (data.snapshot) {\n                    finalResponse = data;\n                } else if (data.error) {\n                    throw new Error(data.error);\n                }\n            } catch (parseError) {\n                console.error('[LiVue Stream] Final parse error:', parseError, buffer);\n            }\n        }\n\n        onComplete(finalResponse);\n\n        return finalResponse;\n    } catch (error) {\n        onError(error);\n        throw error;\n    } finally {\n        // Reset streaming state\n        streamingState = {\n            active: false,\n            method: null,\n            componentId: null,\n        };\n    }\n}\n\n/**\n * Apply a stream chunk to the DOM.\n *\n * @param {Object} chunk - Stream chunk data\n * @param {string} chunk.to - Target element ID\n * @param {string} chunk.content - Content to apply\n * @param {boolean} chunk.replace - Replace or append\n */\nexport function applyStreamChunk(chunk) {\n    const { to, content, replace } = chunk;\n\n    const target = streamTargets.get(to);\n\n    if (!target) {\n        console.warn(`[LiVue Stream] Target not found: ${to}`);\n        return;\n    }\n\n    const { el } = target;\n\n    if (replace) {\n        el.innerHTML = content;\n    } else {\n        el.innerHTML += content;\n    }\n}\n\n/**\n * Register a stream target element.\n *\n * @param {string} targetId - Target identifier\n * @param {HTMLElement} el - DOM element\n * @param {boolean} replace - Default replace mode\n */\nexport function registerStreamTarget(targetId, el, replace = false) {\n    streamTargets.set(targetId, { el, replace });\n}\n\n/**\n * Unregister a stream target element.\n *\n * @param {string} targetId - Target identifier\n */\nexport function unregisterStreamTarget(targetId) {\n    streamTargets.delete(targetId);\n}\n\n/**\n * Clear all stream targets.\n * Called when component unmounts or template swaps.\n */\nexport function clearStreamTargets() {\n    streamTargets.clear();\n}\n\n/**\n * Check if streaming is currently active.\n *\n * @returns {boolean}\n */\nexport function isStreaming() {\n    return streamingState.active;\n}\n\n/**\n * Get current streaming method name.\n *\n * @returns {string|null}\n */\nexport function getStreamingMethod() {\n    return streamingState.method;\n}\n","/**\n * PHP Composables support for LiVue JavaScript runtime.\n *\n * Composables are trait methods on PHP components that return arrays of\n * data and actions. This module handles:\n * - Unwrapping synthesized composable data from the server\n * - Creating reactive Vue objects for each composable namespace\n * - Wrapping composable actions as callable methods\n * - Updating composable data on server responses\n */\n\nimport { reactive } from 'vue';\n\n/**\n * Check if a value is a synthesizer tuple [value, {s: '...'}].\n * @param {*} val\n * @returns {boolean}\n */\nfunction isTuple(val) {\n    return Array.isArray(val)\n        && val.length === 2\n        && val[1] !== null\n        && typeof val[1] === 'object'\n        && 's' in val[1];\n}\n\n/**\n * Unwrap synthesized values in composable data.\n * Converts [value, {s: 'mdl', ...}] tuples to plain values.\n * @param {object} data - Composable data with potential tuples\n * @returns {object} Plain unwrapped data\n */\nfunction unwrapComposableData(data) {\n    let result = {};\n\n    for (let key in data) {\n        let val = data[key];\n\n        if (isTuple(val)) {\n            result[key] = val[0];\n        } else if (val && typeof val === 'object' && !Array.isArray(val)) {\n            // Recursively unwrap nested objects\n            result[key] = unwrapComposableData(val);\n        } else {\n            result[key] = val;\n        }\n    }\n\n    return result;\n}\n\n/**\n * Create reactive composable objects from memo data.\n *\n * Returns an object where each key is a composable namespace (auth, cart, etc.)\n * with reactive data and methods wrapped to call the server.\n *\n * @param {object} memo - Component memo containing composables and composableActions\n * @param {Function} callFn - Function to call server methods (livue.call)\n * @returns {object} Object with reactive composable namespaces\n */\nexport function createComposables(memo, callFn) {\n    let composablesData = memo.composables || {};\n    let composableActions = memo.composableActions || {};\n    let result = {};\n\n    // Get all unique namespaces from both data and actions\n    let namespaces = new Set([\n        ...Object.keys(composablesData),\n        ...Object.keys(composableActions),\n    ]);\n\n    for (let namespace of namespaces) {\n        let data = composablesData[namespace] || {};\n        let actions = composableActions[namespace] || {};\n\n        // Unwrap synthesized values\n        let unwrappedData = unwrapComposableData(data);\n\n        // Create methods for each action\n        let methods = {};\n        for (let action in actions) {\n            // Create a method that calls the server\n            methods[action] = (function (ns, act) {\n                return function () {\n                    let args = Array.prototype.slice.call(arguments);\n                    return callFn(ns + '.' + act, args);\n                };\n            })(namespace, action);\n        }\n\n        // Combine data and methods into a reactive object\n        result[namespace] = reactive(Object.assign({}, unwrappedData, methods));\n    }\n\n    return result;\n}\n\n/**\n * Update composable data from a new server response.\n *\n * This updates existing reactive composable objects in place,\n * preserving Vue reactivity while updating values.\n *\n * @param {object} composables - Existing reactive composable objects\n * @param {object} newMemo - New memo from server response\n */\nexport function updateComposables(composables, newMemo) {\n    let newData = newMemo.composables || {};\n    let newActions = newMemo.composableActions || {};\n\n    // Update existing namespaces with new data\n    for (let namespace in newData) {\n        let unwrapped = unwrapComposableData(newData[namespace]);\n\n        if (composables[namespace]) {\n            // Update existing reactive object in place\n            for (let key in unwrapped) {\n                // Only update data properties, not action methods\n                if (typeof composables[namespace][key] !== 'function') {\n                    composables[namespace][key] = unwrapped[key];\n                }\n            }\n        }\n    }\n\n    // Note: We don't need to update action methods because they're\n    // just wrappers around callFn, which doesn't change.\n}\n\n/**\n * Check if a memo contains composable data.\n * @param {object} memo\n * @returns {boolean}\n */\nexport function hasComposables(memo) {\n    return (memo.composables && Object.keys(memo.composables).length > 0)\n        || (memo.composableActions && Object.keys(memo.composableActions).length > 0);\n}\n","/**\n * Client-side LiVue component.\n *\n * Mounts a single Vue app on a root element. Nested LiVue components\n * (children) are registered as Vue components within the same app,\n * so the entire tree shares one Vue instance.\n *\n * Components marked with data-livue-island are treated as separate\n * Vue apps and are NOT absorbed into the parent.\n *\n * Architecture: the Vue app is a thin shell that renders the root\n * component via <component :is>. Both root and children are dynamic\n * Vue components whose templates can be swapped independently when\n * the server returns updated HTML â€” no DOM morphing needed.\n *\n * Data model: each component's data lives in a \"snapshot\" containing\n * { state, memo }. The snapshot travels as an opaque JSON string:\n * the client stores it intact and sends it back to the server as-is.\n * Synthesized properties (models, enums, Carbon, collections) are\n * stored as inline tuples [value, {s: 'type', ...}] within the state.\n * The client unwraps tuples for Vue reactivity and rewraps them for diffs.\n *\n * Checksum model: the checksum covers the entire\n * state (including inline tuples). The client keeps the raw snapshot\n * JSON string and sends it back for checksum verification. Changes\n * from v-model are sent separately as \"diffs\".\n */\n\nimport * as Vue from 'vue';\nimport {\n    createApp, reactive, shallowRef,\n    ref, computed, watch, watchEffect, readonly,\n    onMounted, onUnmounted, onBeforeMount, onBeforeUnmount,\n    nextTick, provide, inject,\n} from 'vue';\nimport { sendAction } from '../features/request/request.js';\nimport { createReactiveState, updateState, serializeState, stateToRefs, getByPath, setByPath } from './state.js';\nimport { createErrors, setErrors, clearErrors, handleError, setComponentErrorHandler, removeComponentErrorHandler } from '../helpers/errors.js';\nimport { on, emit, removeByComponentId, processServerEvents } from '../features/events.js';\nimport { handleRedirect, navigateTo } from '../features/navigation.js';\nimport { updateQueryString } from '../features/url.js';\nimport { uploadFile, uploadFiles } from '../features/upload.js';\nimport { createPinia } from 'pinia';\nimport { createLazyComponent } from '../features/lazy.js';\nimport { getDebounced, getThrottled, clearModifiers } from '../helpers/modifiers.js';\nimport { register as registerTabSync, unregister as unregisterTabSync, broadcast as broadcastTabSync, filterState as filterTabSyncState } from '../features/broadcast.js';\nimport { getBuiltInDirectives } from './registry.js';\nimport { subscribe as subscribeEcho, unsubscribeComponent as unsubscribeEcho } from '../features/echo.js';\nimport { withViewTransition, isViewTransitionsSupported } from '../directives/transition.js';\nimport { streamRequest, isStreaming as isStreamingActive, getStreamingMethod, clearStreamTargets } from '../features/request/stream.js';\nimport { trigger, createCleanupCollector } from '../helpers/hooks.js';\nimport { createComposables, updateComposables, hasComposables } from '../features/composables.js';\n\n/**\n * Global counter for generating unique child component tag names.\n */\nlet _childCounter = 0;\n\n/**\n * Storage for v-ignore preserved content.\n * Maps ignore-id to { html, isSelf, inputs }\n * @type {Map<string, object>}\n */\nlet _ignoredContent = new Map();\n\n/**\n * Capture input values from an element and its descendants.\n * @param {HTMLElement} el\n * @returns {Array} Array of { selector, value, checked } objects\n */\nfunction captureInputValues(el) {\n    let inputs = [];\n    let formElements = el.querySelectorAll('input, textarea, select');\n\n    formElements.forEach(function (input, index) {\n        let data = { index: index };\n\n        if (input.type === 'checkbox' || input.type === 'radio') {\n            data.checked = input.checked;\n        } else if (input.tagName === 'SELECT') {\n            data.value = input.value;\n            if (input.multiple) {\n                data.selectedOptions = Array.from(input.selectedOptions).map(function(opt) {\n                    return opt.value;\n                });\n            }\n        } else {\n            data.value = input.value;\n        }\n\n        inputs.push(data);\n    });\n\n    return inputs;\n}\n\n/**\n * Restore input values to an element and its descendants.\n * @param {HTMLElement} el\n * @param {Array} inputs - Array from captureInputValues\n */\nfunction restoreInputValues(el, inputs) {\n    let formElements = el.querySelectorAll('input, textarea, select');\n\n    inputs.forEach(function (data) {\n        let input = formElements[data.index];\n        if (!input) return;\n\n        if (input.type === 'checkbox' || input.type === 'radio') {\n            input.checked = data.checked;\n        } else if (input.tagName === 'SELECT' && input.multiple && data.selectedOptions) {\n            Array.from(input.options).forEach(function(opt) {\n                opt.selected = data.selectedOptions.includes(opt.value);\n            });\n        } else if (data.value !== undefined) {\n            input.value = data.value;\n        }\n    });\n}\n\n/**\n * Capture content from v-ignore elements before template swap.\n * Call this BEFORE updating the template.\n *\n * @param {HTMLElement} container - The container element to search in\n */\nfunction captureIgnoredContent(container) {\n    let ignored = container.querySelectorAll('[data-livue-ignore-id]');\n\n    ignored.forEach(function (el) {\n        let ignoreId = el.getAttribute('data-livue-ignore-id');\n        let isSelf = el.hasAttribute('data-livue-ignore-self');\n\n        _ignoredContent.set(ignoreId, {\n            html: el.innerHTML,\n            isSelf: isSelf,\n            inputs: captureInputValues(el),\n        });\n    });\n}\n\n/**\n * Restore content to v-ignore elements after template swap.\n * Call this AFTER Vue has updated the DOM.\n *\n * @param {HTMLElement} container - The container element to search in\n */\nfunction restoreIgnoredContent(container) {\n    let ignored = container.querySelectorAll('[data-livue-ignore-id]');\n\n    ignored.forEach(function (el) {\n        let ignoreId = el.getAttribute('data-livue-ignore-id');\n        let preserved = _ignoredContent.get(ignoreId);\n\n        if (preserved) {\n            if (!preserved.isSelf) {\n                // Restore entire content\n                el.innerHTML = preserved.html;\n            }\n            // Restore input values (works for both modes)\n            if (preserved.inputs && preserved.inputs.length > 0) {\n                restoreInputValues(el, preserved.inputs);\n            }\n        }\n    });\n}\n\n/**\n * Compute the diff between the server-confirmed state and the current\n * reactive state. Only includes keys whose serialized values differ.\n *\n * @param {object} serverState - Plain object (last acknowledged by server)\n * @param {object} currentState - Reactive Vue state\n * @returns {object} Keys that changed with their new values\n */\nfunction computeDiffs(serverState, currentState) {\n    let diffs = {};\n    let current = serializeState(currentState);\n\n    for (let key in current) {\n        if (JSON.stringify(current[key]) !== JSON.stringify(serverState[key])) {\n            diffs[key] = current[key];\n        }\n    }\n\n    return diffs;\n}\n\n/**\n * Check if a value is a synthesizer inline tuple [value, {s: '...'}].\n *\n * @param {*} val\n * @returns {boolean}\n */\nfunction isTuple(val) {\n    return Array.isArray(val) && val.length === 2\n        && val[1] && typeof val[1] === 'object' && !Array.isArray(val[1])\n        && val[1].s;\n}\n\n/**\n * Unwrap inline tuples from a state object.\n * Returns a plain object with the raw values extracted from tuples.\n * Non-tuple values are passed through as-is.\n *\n * @param {object} state - State that may contain inline tuples\n * @returns {object} Plain state with unwrapped values\n */\nfunction unwrapState(state) {\n    let flat = {};\n    for (let key in state) {\n        let val = state[key];\n        if (isTuple(val)) {\n            flat[key] = val[0];\n        } else {\n            flat[key] = val;\n        }\n    }\n    return flat;\n}\n\n/**\n * Vue Composition APIs available inside @script blocks.\n */\nlet _vueApis = {\n    ref: ref,\n    computed: computed,\n    watch: watch,\n    watchEffect: watchEffect,\n    reactive: reactive,\n    readonly: readonly,\n    onMounted: onMounted,\n    onUnmounted: onUnmounted,\n    onBeforeMount: onBeforeMount,\n    onBeforeUnmount: onBeforeUnmount,\n    nextTick: nextTick,\n    provide: provide,\n    inject: inject,\n};\n\nlet _vueApiNames = Object.keys(_vueApis);\nlet _vueApiValues = _vueApiNames.map(function (k) { return _vueApis[k]; });\n\n/**\n * Extract a <script type=\"application/livue-setup\"> block from an HTML string.\n * Returns the cleaned HTML and the setup code (or null).\n *\n * Supports optional inner <script> tags for IDE support. Users can write:\n *   @script\n *   <script>\n *   // code with full IDE support (highlighting, autocomplete, etc.)\n *   </script>\n *   @endscript\n *\n * The inner <script> tags are automatically stripped.\n *\n * @param {string} html\n * @returns {{ html: string, setupCode: string|null }}\n */\nfunction extractSetupScript(html) {\n    let match = html.match(/<script\\s+type=\"application\\/livue-setup\"[^>]*>([\\s\\S]*?)<\\/script>/);\n    if (match) {\n        let code = match[1].trim();\n\n        // Strip optional inner <script> tags (for IDE support)\n        // Matches <script>, <script lang=\"js\">, <script type=\"text/javascript\">, etc.\n        code = code.replace(/^<script[^>]*>\\s*/i, '');\n        code = code.replace(/\\s*<\\/script>$/i, '');\n\n        return {\n            html: html.replace(match[0], ''),\n            setupCode: code.trim(),\n        };\n    }\n    return { html: html, setupCode: null };\n}\n\n/**\n * Execute user-provided @script setup code within the Vue setup context.\n * The code receives Vue Composition APIs, server state refs, and the livue helper\n * as named variables. It must return an object with additional template bindings.\n *\n * @param {string} code - The JS code from the @script block\n * @param {object} stateRefs - Result of stateToRefs(state)\n * @param {object} livue - The livue helper\n * @returns {object|null} Additional bindings to merge into setup return\n */\nfunction executeSetupCode(code, stateRefs, livue) {\n    let stateKeys = Object.keys(stateRefs);\n    let stateValues = stateKeys.map(function (k) { return stateRefs[k]; });\n\n    let paramNames = _vueApiNames.concat(stateKeys).concat(['livue']);\n    let paramValues = _vueApiValues.concat(stateValues).concat([livue]);\n\n    try {\n        let fn = new (Function.prototype.bind.apply(\n            Function,\n            [null].concat(paramNames).concat([code])\n        ))();\n        let result = fn.apply(null, paramValues);\n        return (result && typeof result === 'object') ? result : null;\n    } catch (e) {\n        console.error('[LiVue] Error executing @script setup code:', e);\n        return null;\n    }\n}\n\n/**\n * Transform v-model with custom LiVue modifiers into v-model + separate directives.\n *\n * This allows users to write:\n *   <input v-model.debounce.500ms=\"search\">\n *   <v-text-field v-model.debounce.500ms=\"search\">\n *\n * Which gets transformed to:\n *   <input v-model=\"search\" v-debounce:search.500ms>\n *   <v-text-field v-model=\"search\" v-debounce:search.500ms>\n *\n * This way Vue's native v-model handles the binding (works with all components),\n * and our custom directives handle the modifier behavior.\n *\n * @param {string} html - Template HTML\n * @returns {string} - Transformed HTML\n */\nfunction transformVModelModifiers(html) {\n    // Transform v-model.debounce.Xms=\"prop\" -> v-model=\"prop\" v-debounce:prop.Xms\n    let debouncePattern = /v-model\\.debounce(?:\\.(\\d+)(ms)?)?=[\"']([^\"']+)[\"']/g;\n    html = html.replace(debouncePattern, function (match, timing, msUnit, propName) {\n        let modifiers = timing ? '.' + timing + (msUnit || 'ms') : '';\n        return 'v-model=\"' + propName + '\" v-debounce:' + propName + modifiers;\n    });\n\n    // Transform v-model.throttle.Xms=\"prop\" -> v-model=\"prop\" v-throttle:prop.Xms\n    let throttlePattern = /v-model\\.throttle(?:\\.(\\d+)(ms)?)?=[\"']([^\"']+)[\"']/g;\n    html = html.replace(throttlePattern, function (match, timing, msUnit, propName) {\n        let modifiers = timing ? '.' + timing + (msUnit || 'ms') : '';\n        return 'v-model=\"' + propName + '\" v-throttle:' + propName + modifiers;\n    });\n\n    // Transform v-model.blur=\"prop\" -> v-model=\"prop\" v-blur:prop\n    let blurPattern = /v-model\\.blur=[\"']([^\"']+)[\"']/g;\n    html = html.replace(blurPattern, function (match, propName) {\n        return 'v-model=\"' + propName + '\" v-blur:' + propName;\n    });\n\n    // Transform v-model.enter=\"prop\" -> v-model=\"prop\" v-enter:prop\n    let enterPattern = /v-model\\.enter=[\"']([^\"']+)[\"']/g;\n    html = html.replace(enterPattern, function (match, propName) {\n        return 'v-model=\"' + propName + '\" v-enter:' + propName;\n    });\n\n    return html;\n}\n\n/**\n * Build a Vue component definition with optional @script setup code.\n * Extracts the setup script from the template HTML, strips it, and\n * creates a definition whose setup() merges server state, livue helper,\n * and any user-defined bindings from the @script block.\n *\n * @param {string} templateHtml - The component template (may contain <script type=\"application/livue-setup\">)\n * @param {object} state - Reactive state object\n * @param {object} livue - The livue helper\n * @param {object} composables - Composable objects to expose at top level (auth, cart, etc.)\n * @param {object} versions - Reactive version counters for child key-swapping\n * @param {string} [name] - Component name for Vue DevTools\n * @returns {{ name: string, template: string, setup: function }}\n */\nfunction buildComponentDef(templateHtml, state, livue, composables, versions, name) {\n    // Transform v-model.debounce etc. into v-model + v-debounce directive\n    let transformedHtml = transformVModelModifiers(templateHtml);\n    let extracted = extractSetupScript(transformedHtml);\n\n    return {\n        name: name || 'LiVueComponent',\n        template: extracted.html,\n        setup: function () {\n            let refs = stateToRefs(state);\n            // Spread composables (auth, cart, etc.) at top level for template access\n            let base = Object.assign({}, refs, composables, { livue: livue, livueV: versions });\n\n            if (extracted.setupCode) {\n                let extra = executeSetupCode(extracted.setupCode, refs, livue);\n                if (extra) {\n                    Object.assign(base, extra);\n                }\n            }\n\n            return base;\n        },\n    };\n}\n\n/**\n * Create a livue helper object for a component (root or child).\n *\n * @param {string} componentId - Unique livue instance ID\n * @param {object} state - Reactive state object (unwrapped, no tuples)\n * @param {object} memo - Object with name (for event dispatch / error context)\n * @param {object} componentRef - Reference with a _updateTemplate method\n * @param {object} initialServerState - Plain unwrapped copy of the initial state (for diff tracking)\n * @param {string} initialServerSnapshot - Opaque JSON string of the full snapshot (sent back to server as-is)\n * @param {object} [context] - Additional context { el, rootComponent, isChild, parentLivue }\n * @returns {object} Reactive livue helper\n */\nfunction createLivueHelper(componentId, state, memo, componentRef, initialServerState, initialServerSnapshot, context) {\n    context = context || {};\n    let errors = createErrors();\n    let name = memo.name;\n\n    // #[Vue] methods: JS code that runs client-side without server round-trip\n    let vueMethods = memo.vueMethods || {};\n\n    // #[Confirm] methods: require user confirmation before execution\n    let confirms = memo.confirms || {};\n\n    // #[Isolate]: send requests independently, bypassing the pool\n    let isolate = memo.isolate || false;\n\n    // #[Url]: query string synchronization config\n    let urlParams = memo.urlParams || null;\n\n    // File upload configuration from WithFileUploads feature hook\n    let uploads = memo.uploads || null;\n\n    // #[TabSync]: cross-tab state synchronization config\n    let tabSync = memo.tabSync || null;\n\n    // Flag to skip broadcast after sync triggered by tab sync (avoid loops)\n    let _skipNextBroadcast = false;\n\n    // Last unwrapped state confirmed by the server (for computing diffs).\n    // Kept as a plain (non-reactive) object. Updated after each server response.\n    let serverState = initialServerState;\n\n    // The full snapshot as an opaque JSON string. Sent back to the server as-is\n    // for checksum verification. Updated after each server response.\n    let serverSnapshot = initialServerSnapshot;\n\n    /**\n     * Handle a download response by creating a temporary link and clicking it.\n     * @param {object} download - { token: string, name: string }\n     */\n    function handleDownload(download) {\n        let prefix = document.querySelector('meta[name=\"livue-prefix\"]');\n        let prefixValue = prefix ? prefix.getAttribute('content') : 'livue';\n        let url = '/' + prefixValue + '/download?token=' + encodeURIComponent(download.token);\n\n        let link = document.createElement('a');\n        link.href = url;\n        link.download = download.name;\n        link.style.display = 'none';\n        document.body.appendChild(link);\n        link.click();\n        document.body.removeChild(link);\n    }\n\n    /**\n     * Build the payload for an AJAX request.\n     * The snapshot is sent as an opaque JSON string (server parses it).\n     * Changes from v-model are sent as separate \"diffs\".\n     */\n    function buildPayload() {\n        let diffs = computeDiffs(serverState, state);\n\n        return {\n            snapshot: serverSnapshot,\n            diffs: diffs,\n        };\n    }\n\n    /**\n     * Apply a server response: update state, memo, errors, template, and events.\n     * The snapshot in the response is an opaque JSON string.\n     *\n     * @param {object} response - Server response\n     * @param {object} [sentDiffs] - Diffs that were sent with this request (client changes to exclude from broadcast)\n     */\n    function applyResponse(response, sentDiffs) {\n        // Handle redirect if present (defense-in-depth; primary handling is in pool.js)\n        if (response.redirect) {\n            handleRedirect(response.redirect);\n            return;\n        }\n\n        // Handle error boundary response from server\n        if (response.errorBoundary) {\n            let eb = response.errorBoundary;\n            livue.errorState.hasError = eb.hasError;\n            livue.errorState.errorMessage = eb.errorMessage;\n            livue.errorState.errorDetails = eb.errorDetails;\n            livue.errorState.recover = eb.recover;\n\n            // If error was handled server-side and we should recover,\n            // continue processing the response normally\n            if (!eb.errorHandled || !eb.recover) {\n                // Trigger error.occurred hook\n                trigger('error.occurred', {\n                    error: new Error(eb.errorMessage || 'Component error'),\n                    componentName: name,\n                    componentId: componentId,\n                    context: { method: eb.errorMethod, serverHandled: eb.errorHandled },\n                    preventDefault: function () {},\n                });\n            }\n\n            // If there's a fallback view and we're not recovering,\n            // the server should have sent it in response.html\n        }\n\n        // Handle download if present - trigger file download via hidden link\n        if (response.download) {\n            handleDownload(response.download);\n            // Continue processing snapshot update (don't return)\n        }\n\n        if (response.snapshot) {\n            // Parse the opaque snapshot string to extract state and memo\n            let parsed = JSON.parse(response.snapshot);\n\n            if (parsed.state) {\n                let newState = unwrapState(parsed.state);\n                updateState(state, newState);\n                serverState = JSON.parse(JSON.stringify(newState));\n            }\n\n            // Store the raw snapshot string for next request\n            serverSnapshot = response.snapshot;\n\n            if (parsed.memo) {\n                // Sync validation errors from memo\n                if (parsed.memo.errors) {\n                    setErrors(livue.errors, parsed.memo.errors);\n                } else {\n                    clearErrors(livue.errors);\n                }\n\n                // Update #[Vue] methods from new memo\n                if (parsed.memo.vueMethods) {\n                    vueMethods = parsed.memo.vueMethods;\n                }\n\n                // Update URL params config from new memo\n                if (parsed.memo.urlParams) {\n                    urlParams = parsed.memo.urlParams;\n                }\n\n                // Update upload config from new memo (tokens may rotate)\n                if (parsed.memo.uploads) {\n                    uploads = parsed.memo.uploads;\n                }\n\n                // Update #[Confirm] methods config from new memo\n                if (parsed.memo.confirms) {\n                    confirms = parsed.memo.confirms;\n                }\n\n                // Update composable data from new memo\n                if (parsed.memo.composables || parsed.memo.composableActions) {\n                    updateComposables(composables, parsed.memo);\n                }\n            }\n        }\n\n        // Sync URL query string after state update\n        if (urlParams) {\n            updateQueryString(urlParams, state);\n        }\n        if (response.html && componentRef && componentRef._updateTemplate) {\n            // Extract transition options from memo (#[Transition])\n            let transitionOpts = {};\n            if (response.snapshot) {\n                let parsedSnap = JSON.parse(response.snapshot);\n                if (parsedSnap.memo) {\n                    if (parsedSnap.memo.transitionType) {\n                        transitionOpts.transitionType = parsedSnap.memo.transitionType;\n                    }\n                    if (parsedSnap.memo.skipTransition) {\n                        transitionOpts.skipTransition = true;\n                    }\n                }\n            }\n            componentRef._updateTemplate(response.html, transitionOpts);\n        }\n        if (response.events && response.events.length > 0) {\n            for (var i = 0; i < response.events.length; i++) {\n                response.events[i].sourceId = componentId;\n            }\n            processServerEvents(response.events);\n        }\n\n        // Execute pending JavaScript from ->vue() calls\n        if (response.js && response.js.length > 0) {\n            for (var j = 0; j < response.js.length; j++) {\n                try {\n                    new Function('state', 'livue', response.js[j])(state, livue);\n                } catch (jsError) {\n                    console.error('[LiVue] Error executing ->vue() JS:', jsError);\n                }\n            }\n        }\n\n        // TabSync: broadcast state changes to other tabs\n        // Skip if this response is from a sync triggered by tab sync (avoid loops)\n        // Only broadcast SERVER changes, not client diffs (v-model changes)\n        if (tabSync && tabSync.enabled && response.snapshot && !_skipNextBroadcast) {\n            let parsed = JSON.parse(response.snapshot);\n            if (parsed.state) {\n                let currentState = serializeState(state);\n\n                // Exclude properties that were in client diffs (v-model changes)\n                // We only want to broadcast what the SERVER changed\n                let serverChangedProps = [];\n                for (let prop in currentState) {\n                    // If this property was NOT in the client diffs, it's a server change\n                    if (!sentDiffs || !(prop in sentDiffs)) {\n                        serverChangedProps.push(prop);\n                    }\n                }\n\n                if (serverChangedProps.length > 0) {\n                    let filteredState = filterTabSyncState(currentState, serverChangedProps, tabSync);\n\n                    if (Object.keys(filteredState).length > 0) {\n                        broadcastTabSync(name, filteredState, serverChangedProps, tabSync);\n                    }\n                }\n            }\n        }\n\n        // Reset the skip flag\n        _skipNextBroadcast = false;\n\n        // Return JSON result if present (#[Json] methods)\n        if (response.jsonResult !== undefined) {\n            return response.jsonResult;\n        }\n    }\n\n    // Reactive object tracking loading state per method\n    let loadingTargets = reactive({});\n\n    // PHP Composables: create reactive objects for each composable namespace.\n    // The callFn wrapper allows composable actions to use livue.call which is defined below.\n    let composables = {};\n    let callFn = function (method, params) {\n        return livue.call(method, params);\n    };\n\n    if (hasComposables(memo)) {\n        composables = createComposables(memo, callFn);\n    }\n\n    let livue = reactive({\n        loading: false,\n        processing: null,\n        errors: errors,\n        uploading: false,\n        uploadProgress: 0,\n        streaming: false,\n        streamingMethod: null,\n        loadingTargets: loadingTargets,\n        refs: {},\n\n        /**\n         * Check if any property (or a specific property) has changed since last sync.\n         * @param {string} [property] - Property name to check, or omit for any\n         * @returns {boolean}\n         */\n        isDirty: function (property) {\n            let diffs = computeDiffs(serverState, state);\n            if (property === undefined) {\n                return Object.keys(diffs).length > 0;\n            }\n            return property in diffs;\n        },\n\n        /**\n         * Get the set of dirty (changed) property names.\n         * This is a getter that returns a new Set on each access.\n         * @returns {Set<string>}\n         */\n        get dirtyFields() {\n            let diffs = computeDiffs(serverState, state);\n            return new Set(Object.keys(diffs));\n        },\n\n        /**\n         * Get the original (server-confirmed) value of a property.\n         * @param {string} [property] - Property name, or omit for entire state\n         * @returns {*}\n         */\n        getOriginal: function (property) {\n            if (property === undefined) {\n                return JSON.parse(JSON.stringify(serverState));\n            }\n            return serverState[property] !== undefined\n                ? JSON.parse(JSON.stringify(serverState[property]))\n                : undefined;\n        },\n\n        /**\n         * Reset a property to its original (server-confirmed) value.\n         * @param {string} property - Property name to reset\n         */\n        resetProperty: function (property) {\n            if (property in serverState) {\n                state[property] = JSON.parse(JSON.stringify(serverState[property]));\n            }\n        },\n\n        /**\n         * Reset all properties to their original (server-confirmed) values.\n         */\n        resetAll: function () {\n            for (let key in serverState) {\n                if (key in state) {\n                    state[key] = JSON.parse(JSON.stringify(serverState[key]));\n                }\n            }\n        },\n\n        /**\n         * Check if a specific action (or any action) is loading.\n         * @param {string} [action] - Method name to check, or omit for any\n         * @returns {boolean}\n         */\n        isLoading: function (action) {\n            if (!action) return livue.loading;\n            return loadingTargets[action] || false;\n        },\n\n        /**\n         * Get loading-related attributes for binding to elements.\n         * @param {string} [action] - Method name to check, or omit for any\n         * @returns {object} Attributes object with aria-busy and disabled\n         */\n        loadingAttrs: function (action) {\n            let isActive = action ? (loadingTargets[action] || false) : livue.loading;\n            return {\n                'aria-busy': isActive,\n                'disabled': isActive,\n            };\n        },\n\n        /**\n         * Call a method. If the method is a #[Vue] method, execute JS\n         * client-side without a server round-trip. Otherwise, send AJAX.\n         * Checks for #[Confirm] attribute before execution.\n         *\n         * Supports action modifiers via options object:\n         *   livue.call('search', ['query'], { debounce: 300 })\n         *   livue.call('increment', [], { throttle: 500 })\n         *\n         * Backward compatible with old API:\n         *   livue.call('save')\n         *   livue.call('search', 'query')\n         *\n         * @param {string} method\n         * @param {Array|*} paramsOrFirst - Array of params (new API) or first param (old API)\n         * @param {object} [options] - { debounce?: number, throttle?: number }\n         */\n        call: async function (method, paramsOrFirst, options) {\n            // Detect API style and extract params/options\n            let params;\n            let modifiers = null;\n\n            if (arguments.length === 1) {\n                // livue.call('method')\n                params = [];\n            } else if (arguments.length === 2) {\n                // Could be: livue.call('method', 'param') OR livue.call('method', [params])\n                if (Array.isArray(paramsOrFirst)) {\n                    params = paramsOrFirst;\n                } else {\n                    params = [paramsOrFirst];\n                }\n            } else if (arguments.length >= 3) {\n                // Could be:\n                // - livue.call('method', [params], { debounce: 300 }) - new API\n                // - livue.call('method', 'p1', 'p2', ...) - old API with multiple params\n                if (Array.isArray(paramsOrFirst) && options && typeof options === 'object' && (options.debounce || options.throttle)) {\n                    // New API with modifiers\n                    params = paramsOrFirst;\n                    modifiers = options;\n                } else {\n                    // Old API with multiple params: livue.call('method', p1, p2, ...)\n                    params = Array.prototype.slice.call(arguments, 1);\n                }\n            }\n\n            // #[Vue] methods: execute client-side JS directly\n            if (vueMethods[method]) {\n                try {\n                    new Function('state', 'livue', vueMethods[method])(state, livue);\n                } catch (jsError) {\n                    console.error('[LiVue] Error executing #[Vue] method \"' + method + '\":', jsError);\n                }\n                return;\n            }\n\n            // The actual AJAX call logic\n            let doCall = async function () {\n                // #[Confirm] methods: require user confirmation before execution\n                if (confirms[method]) {\n                    let confirmed = await livue._showConfirm(confirms[method]);\n                    if (!confirmed) {\n                        return;\n                    }\n                }\n\n                livue.loading = true;\n                livue.processing = method;\n                loadingTargets[method] = true;\n\n                let result;\n                try {\n                    let payload = buildPayload();\n                    let response = await sendAction(payload.snapshot, method, params, payload.diffs, isolate);\n                    result = applyResponse(response, payload.diffs);\n                } catch (error) {\n                    if (error.status === 422 && error.data && error.data.errors) {\n                        setErrors(livue.errors, error.data.errors);\n                    } else {\n                        handleError(error, name);\n                    }\n                } finally {\n                    livue.loading = false;\n                    livue.processing = null;\n                    delete loadingTargets[method];\n                }\n                return result;\n            };\n\n            // Apply modifiers if present\n            if (modifiers && modifiers.debounce) {\n                let debounced = getDebounced(componentId + ':' + method, modifiers.debounce);\n                return debounced(doCall);\n            }\n\n            if (modifiers && modifiers.throttle) {\n                let throttled = getThrottled(componentId + ':' + method, modifiers.throttle);\n                return throttled(doCall);\n            }\n\n            // No modifiers, execute directly\n            return doCall();\n        },\n\n        /**\n         * Call a method with inline confirmation (bypasses #[Confirm] attribute).\n         * Useful when you want confirmation only in specific contexts.\n         * @param {string} method\n         * @param {string} message - Confirmation message\n         * @param {...*} args - Method arguments\n         */\n        callWithConfirm: async function (method, message) {\n            let args = Array.prototype.slice.call(arguments, 2);\n            let config = { message: message || 'Are you sure?' };\n            let confirmed = await livue._showConfirm(config);\n\n            if (confirmed) {\n                return livue.call.apply(livue, [method].concat(args));\n            }\n        },\n\n        /**\n         * Show confirmation dialog (native or custom).\n         * @param {object} config - { message, title, confirmText, cancelText }\n         * @returns {Promise<boolean>}\n         * @private\n         */\n        _showConfirm: function (config) {\n            // Check for custom confirm handler\n            if (window.LiVue && window.LiVue.confirmHandler) {\n                return window.LiVue.confirmHandler(config);\n            }\n\n            // Default: native browser confirm\n            return Promise.resolve(window.confirm(config.message));\n        },\n\n        /**\n         * Set a local state property without server call.\n         * @param {string} key\n         * @param {*} value\n         */\n        set: function (key, value) {\n            state[key] = value;\n        },\n\n        /**\n         * Sync current state to the server without calling any method.\n         * Useful after local changes via set() or v-model.\n         */\n        sync: async function () {\n            livue.loading = true;\n            livue.processing = '$sync';\n\n            try {\n                let payload = buildPayload();\n                let response = await sendAction(payload.snapshot, null, [], payload.diffs, isolate);\n                applyResponse(response, payload.diffs);\n            } catch (error) {\n                if (error.status === 422 && error.data && error.data.errors) {\n                    setErrors(livue.errors, error.data.errors);\n                } else {\n                    handleError(error, name);\n                }\n            } finally {\n                livue.loading = false;\n                livue.processing = null;\n            }\n        },\n\n        /**\n         * Clear all validation errors.\n         */\n        clearErrors: function () {\n            clearErrors(livue.errors);\n        },\n\n        /**\n         * Dispatch an event to all listening components (broadcast).\n         * @param {string} eventName\n         * @param {*} [data]\n         */\n        dispatch: function (eventName, data) {\n            emit(eventName, data, 'broadcast', name, componentId, null);\n        },\n\n        /**\n         * Dispatch an event to a specific component by name.\n         * @param {string} targetName\n         * @param {string} eventName\n         * @param {*} [data]\n         */\n        dispatchTo: function (targetName, eventName, data) {\n            emit(eventName, data, 'to', name, componentId, targetName);\n        },\n\n        /**\n         * Dispatch an event to this component only.\n         * @param {string} eventName\n         * @param {*} [data]\n         */\n        dispatchSelf: function (eventName, data) {\n            emit(eventName, data, 'self', name, componentId, null);\n        },\n\n        /**\n         * Navigate to a URL using SPA navigation.\n         * @param {string} url - Target URL\n         */\n        navigate: function (url) {\n            navigateTo(url, true);\n        },\n\n        /**\n         * Upload a single file for a component property.\n         * The file is sent to /livue/upload, and on success the property\n         * is set to an upload reference that the server can hydrate.\n         *\n         * Supports nested paths like \"data.avatar\" or \"form.profile.photo\".\n         *\n         * @param {string} property - The component property name or dot-notated path\n         * @param {File} file - The File object from the input\n         */\n        upload: async function (property, file) {\n            if (!uploads || !uploads[property]) {\n                console.error('[LiVue] Property \"' + property + '\" is not configured for uploads.');\n                return;\n            }\n\n            livue.uploading = true;\n            livue.uploadProgress = 0;\n\n            try {\n                var result = await uploadFile(file, name, property, uploads[property].token, function (percent) {\n                    livue.uploadProgress = percent;\n                });\n\n                setByPath(state, property, {\n                    __livue_upload: true,\n                    ref: result.ref,\n                    originalName: result.originalName,\n                    mimeType: result.mimeType,\n                    size: result.size,\n                    previewUrl: result.previewUrl,\n                });\n            } catch (error) {\n                if (error.status === 422 && error.data && error.data.errors) {\n                    setErrors(livue.errors, error.data.errors);\n                } else {\n                    handleError(error, name);\n                }\n            } finally {\n                livue.uploading = false;\n                livue.uploadProgress = 0;\n            }\n        },\n\n        /**\n         * Upload multiple files for an array property.\n         * Each file is uploaded sequentially, and the property is set\n         * to an array of upload references.\n         *\n         * Supports nested paths like \"data.documents\" or \"form.attachments\".\n         *\n         * @param {string} property - The component property name or dot-notated path\n         * @param {FileList|File[]} files - The File objects from the input\n         */\n        uploadMultiple: async function (property, files) {\n            if (!uploads || !uploads[property]) {\n                console.error('[LiVue] Property \"' + property + '\" is not configured for uploads.');\n                return;\n            }\n\n            livue.uploading = true;\n            livue.uploadProgress = 0;\n\n            try {\n                var response = await uploadFiles(files, name, property, uploads[property].token, function (progress) {\n                    livue.uploadProgress = progress.overall;\n                });\n\n                var results = response.results || [];\n                var errors = response.errors || [];\n\n                // Get current value and append successful uploads\n                var currentValue = getByPath(state, property);\n                var existingFiles = Array.isArray(currentValue) ? currentValue : [];\n\n                if (results.length > 0) {\n                    var newFiles = results.map(function (result) {\n                        return {\n                            __livue_upload: true,\n                            ref: result.ref,\n                            originalName: result.originalName,\n                            mimeType: result.mimeType,\n                            size: result.size,\n                            previewUrl: result.previewUrl,\n                        };\n                    });\n\n                    setByPath(state, property, existingFiles.concat(newFiles));\n                }\n\n                // Show errors for failed uploads\n                if (errors.length > 0) {\n                    var errorMessages = {};\n                    errors.forEach(function (err) {\n                        var key = property + '.' + err.index;\n                        // Store as object for richer display in templates\n                        errorMessages[key] = {\n                            file: err.file,\n                            message: err.error,\n                        };\n                    });\n                    setErrors(livue.errors, errorMessages);\n                }\n            } catch (error) {\n                if (error.status === 422 && error.data && error.data.errors) {\n                    setErrors(livue.errors, error.data.errors);\n                } else {\n                    handleError(error, name);\n                }\n            } finally {\n                livue.uploading = false;\n                livue.uploadProgress = 0;\n            }\n        },\n\n        /**\n         * Remove an uploaded file from a property.\n         * For single file properties, sets to null.\n         * For array properties, removes by index.\n         *\n         * Supports nested paths like \"data.avatar\" or \"form.documents\".\n         *\n         * @param {string} property - The property name or dot-notated path\n         * @param {number} [index] - For array properties, the index to remove\n         */\n        removeUpload: function (property, index) {\n            var currentValue = getByPath(state, property);\n\n            if (index !== undefined && Array.isArray(currentValue)) {\n                currentValue.splice(index, 1);\n                // Trigger reactivity by setting the modified array\n                setByPath(state, property, currentValue.slice());\n            } else {\n                setByPath(state, property, null);\n            }\n        },\n\n        /**\n         * Call a method using HTTP streaming.\n         * Streams content in real-time to elements with v-stream directive.\n         *\n         * @param {string} method - Method name to call\n         * @param {Array} [params] - Method parameters\n         * @returns {Promise<*>} Final result after streaming completes\n         */\n        stream: async function (method, params) {\n            params = params || [];\n\n            livue.loading = true;\n            livue.streaming = true;\n            livue.processing = method;\n            livue.streamingMethod = method;\n            loadingTargets[method] = true;\n\n            let result;\n            try {\n                let payload = buildPayload();\n                payload.method = method;\n                payload.params = params;\n                payload.componentId = componentId;\n\n                let response = await streamRequest(payload, {\n                    onChunk: function (chunk) {\n                        // Chunks are applied automatically by stream.js\n                    },\n                    onComplete: function (finalResponse) {\n                        // Final response will be processed below\n                    },\n                    onError: function (error) {\n                        console.error('[LiVue Stream] Error:', error);\n                    },\n                });\n\n                if (response) {\n                    result = applyResponse(response, payload.diffs);\n                }\n            } catch (error) {\n                if (error.status === 422 && error.data && error.data.errors) {\n                    setErrors(livue.errors, error.data.errors);\n                } else {\n                    handleError(error, name);\n                }\n            } finally {\n                livue.loading = false;\n                livue.streaming = false;\n                livue.processing = null;\n                livue.streamingMethod = null;\n                delete loadingTargets[method];\n            }\n\n            return result;\n        },\n\n        /**\n         * Toggle a boolean property.\n         * @param {string} property - Property name to toggle\n         */\n        toggle: function (property) {\n            if (property in state) {\n                state[property] = !state[property];\n            }\n        },\n\n        /**\n         * Watch a property for changes.\n         * Executes callback when the property value changes.\n         *\n         * @param {string} property - Property name to watch\n         * @param {Function} callback - function(newValue, oldValue)\n         * @returns {Function} Unwatch function\n         *\n         * @example\n         * livue.watch('count', (newVal, oldVal) => {\n         *     console.log('Count changed from', oldVal, 'to', newVal);\n         * });\n         */\n        watch: function (property, callback) {\n            if (typeof callback !== 'function') {\n                console.warn('[LiVue] watch callback must be a function');\n                return function () {};\n            }\n\n            // Use Vue's watch on the reactive state\n            return watch(\n                function () { return state[property]; },\n                function (newVal, oldVal) {\n                    callback(newVal, oldVal);\n                }\n            );\n        },\n\n        /**\n         * Get the component's root DOM element.\n         * @returns {HTMLElement|null}\n         */\n        get $el() {\n            if (context.el) {\n                return context.el;\n            }\n            // Fallback: query by component ID\n            return document.querySelector('[data-livue-id=\"' + componentId + '\"]');\n        },\n\n        /**\n         * Get the component's unique ID.\n         * @returns {string}\n         */\n        get $id() {\n            return componentId;\n        },\n\n        /**\n         * Get the parent component's livue helper (if nested).\n         * Returns null for root components.\n         * @returns {object|null}\n         */\n        get $parent() {\n            return context.parentLivue || null;\n        },\n\n        /**\n         * Get the component name.\n         * @returns {string}\n         */\n        get $name() {\n            return name;\n        },\n\n        /**\n         * Register an error handler for this component.\n         * The handler receives (error, context) and can return true to prevent\n         * the error from propagating to the global handler.\n         *\n         * @param {Function} handler - function(error, context) => boolean\n         * @returns {Function} Unsubscribe function\n         *\n         * @example\n         * livue.onError((error, context) => {\n         *     console.error('Error in', context.method, ':', error);\n         *     livue.set('errorMessage', 'Something went wrong');\n         *     return true; // Prevent global handler\n         * });\n         */\n        onError: function (handler) {\n            if (typeof handler !== 'function') {\n                console.warn('[LiVue] onError handler must be a function');\n                return function () {};\n            }\n\n            setComponentErrorHandler(componentId, handler);\n\n            // Return unsubscribe function\n            return function () {\n                removeComponentErrorHandler(componentId);\n            };\n        },\n\n        /**\n         * Reactive error state from server (#[ErrorBoundary]).\n         * Contains: hasError, errorMessage, errorDetails, recover\n         */\n        errorState: reactive({\n            hasError: false,\n            errorMessage: null,\n            errorDetails: null,\n            recover: true,\n        }),\n\n        /**\n         * Clear the error state (used for recovery).\n         */\n        clearError: function () {\n            livue.errorState.hasError = false;\n            livue.errorState.errorMessage = null;\n            livue.errorState.errorDetails = null;\n        },\n\n        /**\n         * Update the server-side state baseline and snapshot.\n         * Used internally when a parent re-renders and reactive props are synced.\n         * @param {object} newServerState - New plain state (unwrapped)\n         * @param {string} newSnapshot - New opaque snapshot JSON string\n         * @private\n         */\n        _updateServerState: function (newServerState, newSnapshot) {\n            serverState = JSON.parse(JSON.stringify(newServerState));\n            serverSnapshot = newSnapshot;\n        },\n\n        /**\n         * Store cleanup collector for hooks.\n         * @private\n         */\n        _cleanups: context.cleanups || null,\n\n        /**\n         * Get debugging information for DevTools.\n         * @private\n         * @returns {object}\n         */\n        _getDevToolsInfo: function () {\n            let diffs = computeDiffs(serverState, state);\n\n            // Extract composables data for DevTools\n            let composablesData = {};\n            for (let ns in composables) {\n                let comp = composables[ns];\n                let data = {};\n                let actions = [];\n                for (let key in comp) {\n                    if (typeof comp[key] === 'function') {\n                        actions.push(key);\n                    } else {\n                        try {\n                            data[key] = JSON.parse(JSON.stringify(comp[key]));\n                        } catch (e) {\n                            data[key] = '[Unserializable]';\n                        }\n                    }\n                }\n                composablesData[ns] = { data: data, actions: actions };\n            }\n\n            return {\n                serverState: JSON.parse(JSON.stringify(serverState)),\n                clientState: JSON.parse(JSON.stringify(state)),\n                dirtyFields: Object.keys(diffs),\n                diffs: diffs,\n                memo: {\n                    name: name,\n                    isolate: isolate,\n                    urlParams: urlParams,\n                    tabSync: tabSync,\n                    hasUploads: !!uploads,\n                    uploadProps: uploads ? Object.keys(uploads) : [],\n                    vueMethods: Object.keys(vueMethods),\n                    confirmMethods: Object.keys(confirms),\n                    composableNames: Object.keys(composables),\n                },\n                composables: composablesData,\n                uploading: livue.uploading,\n                uploadProgress: livue.uploadProgress,\n                streaming: livue.streaming,\n                streamingMethod: livue.streamingMethod,\n                errorState: {\n                    hasError: livue.errorState.hasError,\n                    errorMessage: livue.errorState.errorMessage,\n                },\n            };\n        },\n    });\n\n    // Add composables to livue object (auth, cart, etc.)\n    // These are reactive objects with data and action methods.\n    for (let ns in composables) {\n        livue[ns] = composables[ns];\n    }\n\n    // TabSync: register to receive updates from other tabs\n    if (tabSync && tabSync.enabled) {\n        registerTabSync(name, function (incomingState, properties, config) {\n            // Check if any changed property requires a server refresh (reactive)\n            let needsServerRefresh = false;\n\n            if (config.reactive === true) {\n                // All properties trigger server refresh\n                needsServerRefresh = true;\n            } else if (Array.isArray(config.reactive) && config.reactive.length > 0) {\n                // Check if any changed property is in the reactive list\n                for (let prop in incomingState) {\n                    if (config.reactive.includes(prop)) {\n                        needsServerRefresh = true;\n                        break;\n                    }\n                }\n            }\n\n            if (needsServerRefresh) {\n                // First, apply incoming state so sync() sends the new values\n                for (let prop in incomingState) {\n                    if (config.only && !config.only.includes(prop)) continue;\n                    if (config.except && config.except.includes(prop)) continue;\n\n                    if (prop in state) {\n                        state[prop] = incomingState[prop];\n                    }\n                }\n\n                // Set flag to avoid broadcast loop, then sync to server\n                _skipNextBroadcast = true;\n                livue.sync();\n                return;\n            }\n\n            // Vue-only update: apply incoming state directly\n            for (let prop in incomingState) {\n                // Skip if 'only' is set and prop not in it\n                if (config.only && !config.only.includes(prop)) continue;\n                // Skip if 'except' is set and prop is in it\n                if (config.except && config.except.includes(prop)) continue;\n\n                if (prop in state) {\n                    state[prop] = incomingState[prop];\n                }\n            }\n\n            // Update serverState to match so dirty tracking stays consistent\n            for (let prop in incomingState) {\n                if (config.only && !config.only.includes(prop)) continue;\n                if (config.except && config.except.includes(prop)) continue;\n\n                serverState[prop] = JSON.parse(JSON.stringify(incomingState[prop]));\n            }\n        });\n    }\n\n    return { livue: livue, composables: composables };\n}\n\n/**\n * Process an HTML string, extracting nested LiVue child components\n * and replacing them with Vue component tags.\n *\n * Processes deepest children first (bottom-up) so that deeply nested\n * trees are correctly handled: a child's template will already contain\n * the component tags of its own children.\n *\n * Children already in the root's registry keep their existing state\n * and livue helper â€” only new children get fresh state from the DOM.\n *\n * @param {string} html - The innerHTML of a root or child element\n * @param {LiVueComponent} rootComponent - The root component that owns this Vue app\n * @returns {{ template: string, childDefs: Object }}\n */\nfunction processTemplate(html, rootComponent) {\n    let tempDiv = document.createElement('div');\n    tempDiv.innerHTML = html;\n\n    // Strip children from v-text and v-html elements.\n    // Blade renders initial values as child content for SSR,\n    // but Vue's compiler rejects v-text/v-html with children.\n    let vTextEls = tempDiv.querySelectorAll('[v-text], [v-html]');\n    for (let i = 0; i < vTextEls.length; i++) {\n        vTextEls[i].innerHTML = '';\n    }\n\n    let childDefs = {};\n\n    // Track which registry entries have been matched during this pass,\n    // so duplicate component names are handled by order of appearance.\n    let matchedIds = {};\n\n    // Find ALL nested livue components that are NOT islands.\n    // Use data-livue-id (with data-livue-snapshot) to identify livue elements.\n    // Reverse so we process deepest-first (querySelectorAll returns document order).\n    let nested = Array.from(\n        tempDiv.querySelectorAll('[data-livue-id][data-livue-snapshot]:not([data-livue-island])')\n    ).reverse();\n\n    nested.forEach(function (nestedEl) {\n        let id = nestedEl.dataset.livueId;\n        let childSnapshotJson = nestedEl.dataset.livueSnapshot || '{}';\n        let childSnapshot = JSON.parse(childSnapshotJson);\n        let name = childSnapshot.memo ? childSnapshot.memo.name : '';\n        let initialState = unwrapState(childSnapshot.state || {});\n        let childMemo = childSnapshot.memo || {};\n        let childHtml = nestedEl.innerHTML;\n\n        // Check if this child already exists in the registry.\n        // First try exact ID match, then fallback to component name.\n        // The name fallback is needed because when the server re-renders\n        // a parent template, embedded @livue() directives create fresh\n        // PHP instances with new random IDs.\n        let existing = rootComponent._childRegistry[id];\n        if (!existing) {\n            for (let regId in rootComponent._childRegistry) {\n                let entry = rootComponent._childRegistry[regId];\n                if (entry.name === name && !matchedIds[regId]) {\n                    existing = entry;\n                    break;\n                }\n            }\n        }\n        if (existing) {\n            matchedIds[existing.id] = true;\n\n            // Sync #[Reactive] properties from the re-rendered parent snapshot\n            let reactiveProps = childMemo.reactive || [];\n            if (reactiveProps.length > 0) {\n                for (var r = 0; r < reactiveProps.length; r++) {\n                    var prop = reactiveProps[r];\n                    if (prop in initialState) {\n                        existing.state[prop] = initialState[prop];\n                    }\n                }\n\n                // Update server-side baseline to match the new parent-provided values\n                existing.livue._updateServerState(initialState, childSnapshotJson);\n\n                // Re-render child template with the new server-rendered HTML\n                // (Blade content like @foreach won't update from Vue state alone)\n                if (existing.componentRef && existing.componentRef._updateTemplate) {\n                    existing.componentRef._updateTemplate(childHtml);\n                }\n            }\n        }\n        let isNew = !existing;\n\n        if (!existing) {\n            _childCounter++;\n            let tagName = 'livue-child-' + _childCounter;\n\n            let childState = createReactiveState(initialState);\n            // Plain unwrapped copy for diff tracking\n            let childServerState = JSON.parse(JSON.stringify(initialState));\n            // Pass full memo to the helper (includes vueMethods, urlParams, isolate, reactive, etc.)\n            let memo = Object.assign({ name: childMemo.name || name }, childMemo);\n            let childComponentRef = { _updateTemplate: null };\n\n            // Create cleanup collector for child hooks\n            let childCleanups = createCleanupCollector();\n\n            let helperResult = createLivueHelper(id, childState, memo, childComponentRef, childServerState, childSnapshotJson, {\n                el: nestedEl,\n                rootComponent: rootComponent,\n                isChild: true,\n                parentLivue: rootComponent._rootLivue,\n                cleanups: childCleanups,\n            });\n            let livue = helperResult.livue;\n            let childComposables = helperResult.composables;\n\n            // Trigger component.init hook for child\n            trigger('component.init', {\n                component: { id: id, name: name, state: childState, livue: livue },\n                el: nestedEl,\n                cleanup: childCleanups.cleanup,\n                isChild: true,\n            });\n\n            // Populate initial validation errors from snapshot memo\n            let childErrors = childMemo.errors || null;\n            if (childErrors) {\n                setErrors(livue.errors, childErrors);\n            }\n\n            existing = {\n                tagName: tagName,\n                state: childState,\n                memo: memo,\n                livue: livue,\n                composables: childComposables,\n                componentRef: childComponentRef,\n                name: name,\n                id: id,\n            };\n\n            // Register event listeners declared via $listeners on the PHP component\n            let childListeners = childMemo.listeners || null;\n            if (childListeners) {\n                for (let eventName in childListeners) {\n                    (function (method, childLivue) {\n                        on(eventName, name, id, function (data) {\n                            childLivue.call(method, data);\n                        });\n                    })(childListeners[eventName], livue);\n                }\n            }\n\n            // Subscribe to Laravel Echo channels for child component\n            let childEchoConfig = childMemo.echo || null;\n            if (childEchoConfig && childEchoConfig.length) {\n                (function (childId, childLivue) {\n                    subscribeEcho(childId, childEchoConfig, function (method, data) {\n                        childLivue.call(method, data);\n                    });\n                })(id, livue);\n            }\n\n            // Set up the template update function.\n            // When this child receives a server response, re-register its\n            // Vue component definition with the new template and bump its\n            // version key so Vue re-creates just this component.\n            childComponentRef._updateTemplate = function (newInnerHtml) {\n                // Capture v-ignore content BEFORE the swap\n                let childEl = rootComponent.el.querySelector('[data-livue-id=\"' + id + '\"]');\n                if (childEl) {\n                    captureIgnoredContent(childEl);\n                }\n\n                // Process the new HTML (might contain nested children)\n                let childProcessed = processTemplate(newInnerHtml, rootComponent);\n\n                // Build the wrapped template\n                let newTemplate = '<div data-livue-id=\"' + id + '\">'\n                    + childProcessed.template + '</div>';\n\n                // Register any new nested children discovered in the update\n                for (let ct in childProcessed.childDefs) {\n                    if (!rootComponent.vueApp._context.components[ct]) {\n                        rootComponent.vueApp.component(ct, childProcessed.childDefs[ct]);\n                    }\n                }\n\n                // Update this child's template (direct assignment avoids Vue warning)\n                rootComponent.vueApp._context.components[existing.tagName] = buildComponentDef(newTemplate, existing.state, existing.livue, existing.composables || {}, rootComponent._versions, existing.name);\n\n                // Bump version to force Vue to re-create the component\n                rootComponent._versions[existing.tagName] = (rootComponent._versions[existing.tagName] || 0) + 1;\n\n                // Restore v-ignore content AFTER Vue updates the DOM\n                nextTick(function () {\n                    let updatedChildEl = rootComponent.el.querySelector('[data-livue-id=\"' + id + '\"]');\n                    if (updatedChildEl) {\n                        restoreIgnoredContent(updatedChildEl);\n                    }\n                });\n            };\n\n            rootComponent._childRegistry[id] = existing;\n        }\n\n        let tagName = existing.tagName;\n\n        // Register ref for parent-child communication\n        // Check for data-livue-ref attribute on the nested element\n        let refName = nestedEl.dataset.livueRef;\n        if (refName && rootComponent._rootLivue) {\n            // Create a proxy object that allows the parent to interact with the child\n            rootComponent._rootLivue.refs[refName] = {\n                /**\n                 * Call a method on the child component.\n                 * @param {string} method - Method name\n                 * @param {Array} [params] - Parameters to pass\n                 * @returns {Promise}\n                 */\n                call: function (method, params) {\n                    return existing.livue.call(method, params || []);\n                },\n                /**\n                 * Set a property on the child component.\n                 * @param {string} key - Property name\n                 * @param {*} value - Value to set\n                 */\n                set: function (key, value) {\n                    return existing.livue.set(key, value);\n                },\n                /**\n                 * Dispatch an event from the child.\n                 * @param {string} event - Event name\n                 * @param {*} [data] - Event data\n                 */\n                dispatch: function (event, data) {\n                    return existing.livue.dispatch(event, data);\n                },\n                /**\n                 * Sync the child's state with the server.\n                 * @returns {Promise}\n                 */\n                sync: function () {\n                    return existing.livue.sync();\n                },\n                /**\n                 * Access to the child's reactive state (read-only reference).\n                 */\n                get state() {\n                    return existing.state;\n                },\n                /**\n                 * Access to the child's livue helper.\n                 */\n                get livue() {\n                    return existing.livue;\n                },\n            };\n        }\n\n        // Register model binding for two-way parent-child sync (#[Modelable])\n        // Check for data-livue-model attribute on the nested element\n        let modelProp = nestedEl.dataset.livueModel;\n        if (modelProp && rootComponent._rootState) {\n            // Listen for $modelUpdate events from this child\n            on('$modelUpdate', existing.name, id, function (data) {\n                // Update the parent's property with the new value\n                if (data && data.value !== undefined) {\n                    rootComponent._rootState[modelProp] = data.value;\n                }\n            });\n        }\n\n        // Only add to childDefs if this is a new child (needs initial registration)\n        if (isNew) {\n            childDefs[tagName] = buildComponentDef(\n                '<div data-livue-id=\"' + id + '\">' + childHtml + '</div>',\n                existing.state, existing.livue, existing.composables || {}, rootComponent._versions, existing.name\n            );\n        }\n\n        // Initialize version for this child if needed\n        if (rootComponent._versions[tagName] === undefined) {\n            rootComponent._versions[tagName] = 0;\n        }\n\n        // Replace the nested element with a Vue component tag.\n        // The :key binding ties to the reactive version counter so Vue\n        // re-creates the component when its template is swapped.\n        let placeholder = document.createElement(tagName);\n        placeholder.setAttribute(':key', \"livueV['\" + tagName + \"']\");\n        nestedEl.parentNode.replaceChild(placeholder, nestedEl);\n    });\n\n    // Add v-pre to islands so Vue doesn't compile their content\n    // in the parent's context. Islands have their own Vue app.\n    let islands = tempDiv.querySelectorAll('[data-livue-island]');\n    for (let i = 0; i < islands.length; i++) {\n        islands[i].setAttribute('v-pre', '');\n    }\n\n    return {\n        template: tempDiv.innerHTML,\n        childDefs: childDefs,\n    };\n}\n\nexport default class LiVueComponent {\n    /**\n     * @param {HTMLElement} el - The root/island wrapper element\n     */\n    constructor(el) {\n        this.el = el;\n        this.componentId = el.dataset.livueId;\n\n        // Parse snapshot from DOM. The raw JSON string is stored as the\n        // opaque server snapshot for sending back to the server.\n        let snapshotJson = el.dataset.livueSnapshot || '{}';\n        let snapshot = JSON.parse(snapshotJson);\n        this.name = snapshot.memo ? snapshot.memo.name : '';\n        // Unwrap inline tuples for Vue reactivity\n        this.state = createReactiveState(unwrapState(snapshot.state || {}));\n        // Full memo for JS runtime (includes uploads, urlParams, vueMethods, isolate, etc.)\n        this.memo = snapshot.memo || { name: '' };\n        this.snapshotJson = snapshotJson;\n        this.vueApp = null;\n\n        /** @type {Object<string, object>} livue-id â†’ child info */\n        this._childRegistry = {};\n\n        /** @type {object} Reactive version counters for child key-swapping */\n        this._versions = reactive({});\n\n        /** @type {import('vue').ShallowRef|null} */\n        this._rootDefRef = null;\n\n        /** @type {object|null} */\n        this._rootLivue = null;\n        this._rootState = null; // For #[Modelable] two-way binding\n\n        /**\n         * Helper functions exposed to the lazy directive.\n         * Allows lazy.js to create child components without circular imports.\n         * @type {object}\n         */\n        this._lazyHelpers = {\n            createLivueHelper: createLivueHelper,\n            buildComponentDef: buildComponentDef,\n            processTemplate: processTemplate,\n            createReactiveState: createReactiveState,\n        };\n\n        this._mount(snapshot, snapshotJson);\n    }\n\n    /**\n     * Mount the Vue app shell. The root component is rendered via\n     * <component :is> so its template can be swapped independently\n     * without unmounting the Vue app.\n     */\n    _mount(snapshot, snapshotJson) {\n        let self = this;\n\n        // Create root component ref with _updateTemplate\n        let rootComponentRef = {\n            /**\n             * Update the component template with new HTML.\n             * @param {string} newInnerHtml - The new HTML content\n             * @param {object} [options] - Transition options\n             * @param {string} [options.transitionType] - Transition type (e.g., 'forward', 'backward')\n             * @param {boolean} [options.skipTransition] - Skip the View Transition\n             */\n            _updateTemplate: function (newInnerHtml, options) {\n                options = options || {};\n\n                // Trigger template.updating hook\n                trigger('template.updating', {\n                    component: { id: self.componentId, name: self.name, state: self.state, livue: self._rootLivue },\n                    el: self.el,\n                    html: newInnerHtml,\n                });\n\n                // Capture v-ignore content BEFORE the swap\n                captureIgnoredContent(self.el);\n\n                // Process the new HTML (may discover new children)\n                let rootProcessed = processTemplate(newInnerHtml, self);\n\n                // Register any new child components in the app\n                // Only register if not already registered to avoid Vue warnings\n                for (let tagName in rootProcessed.childDefs) {\n                    if (!self.vueApp._context.components[tagName]) {\n                        self.vueApp.component(tagName, rootProcessed.childDefs[tagName]);\n                    }\n                }\n\n                // The actual DOM swap function\n                function doSwap() {\n                    // Swap root definition â€” Vue detects the new object via\n                    // shallowRef and re-creates the root component.\n                    self._rootDefRef.value = buildComponentDef(rootProcessed.template, self.state, self._rootLivue, self._rootComposables || {}, self._versions, self.name);\n\n                    // Restore v-ignore content AFTER Vue updates the DOM\n                    nextTick(function () {\n                        restoreIgnoredContent(self.el);\n\n                        // Trigger template.updated hook after DOM is updated\n                        trigger('template.updated', {\n                            component: { id: self.componentId, name: self.name, state: self.state, livue: self._rootLivue },\n                            el: self.el,\n                        });\n                    });\n                }\n\n                // Skip View Transition if requested (#[Transition(skip: true)])\n                if (options.skipTransition) {\n                    doSwap();\n                    return;\n                }\n\n                // Use View Transitions API if available for smooth animations\n                if (isViewTransitionsSupported()) {\n                    withViewTransition(doSwap, { type: options.transitionType });\n                } else {\n                    doSwap();\n                }\n            },\n        };\n\n        // Plain unwrapped copy for diff tracking\n        let rootServerState = JSON.parse(JSON.stringify(unwrapState(snapshot.state || {})));\n\n        // Create cleanup collector for root hooks\n        this._cleanups = createCleanupCollector();\n\n        // Create the root livue helper with opaque snapshot string\n        // IMPORTANT: Must be created BEFORE processTemplate so refs can be registered\n        let helperResult = createLivueHelper(this.componentId, this.state, this.memo, rootComponentRef, rootServerState, snapshotJson, {\n            el: this.el,\n            rootComponent: this,\n            isChild: false,\n            parentLivue: null,\n            cleanups: this._cleanups,\n        });\n        let livue = helperResult.livue;\n        let rootComposables = helperResult.composables;\n        this._rootLivue = livue;\n        this._rootComposables = rootComposables;\n        this._rootState = this.state; // For #[Modelable] two-way binding\n\n        // Trigger component.init hook for root\n        trigger('component.init', {\n            component: { id: this.componentId, name: this.name, state: this.state, livue: livue },\n            el: this.el,\n            cleanup: this._cleanups.cleanup,\n            isChild: false,\n        });\n\n        // Extract nested children and transform the template\n        // Now _rootLivue is set, so child refs will be properly registered\n        let processed = processTemplate(this.el.innerHTML, this);\n\n        // Populate initial validation errors from snapshot memo (e.g., after SPA navigate)\n        let initialErrors = (snapshot.memo && snapshot.memo.errors) || null;\n        if (initialErrors) {\n            setErrors(livue.errors, initialErrors);\n        }\n\n        // Register event listeners declared via $listeners on the root PHP component\n        let rootListeners = (snapshot.memo && snapshot.memo.listeners) || null;\n        if (rootListeners) {\n            for (let eventName in rootListeners) {\n                (function (method, rootLivue, compName, compId) {\n                    on(eventName, compName, compId, function (data) {\n                        rootLivue.call(method, data);\n                    });\n                })(rootListeners[eventName], livue, self.name, self.componentId);\n            }\n        }\n\n        // Subscribe to Laravel Echo channels (broadcast events)\n        let echoConfig = (snapshot.memo && snapshot.memo.echo) || null;\n        if (echoConfig && echoConfig.length) {\n            this._echoUnsubscribe = subscribeEcho(self.componentId, echoConfig, function (method, data) {\n                livue.call(method, data);\n            });\n        }\n\n        // Create root component definition\n        let rootDef = buildComponentDef(processed.template, self.state, livue, rootComposables, self._versions, self.name);\n\n        this._rootDefRef = shallowRef(rootDef);\n\n        // Create the Vue app â€” a thin shell that delegates to the root\n        // component via <component :is>. This allows the root's template\n        // to be swapped without unmounting the entire Vue app.\n        this.vueApp = createApp({\n            setup: function () {\n                return {\n                    rootDef: self._rootDefRef,\n                };\n            },\n            template: '<component :is=\"rootDef\"></component>',\n        });\n\n        // Register all child component definitions in the same app\n        // Only register if not already registered to avoid Vue warnings\n        let tagName;\n        for (tagName in processed.childDefs) {\n            if (!this.vueApp._context.components[tagName]) {\n                this.vueApp.component(tagName, processed.childDefs[tagName]);\n            }\n        }\n\n        // Register the livue-lazy component for lazy loading child components\n        if (!this.vueApp._context.components['livue-lazy']) {\n            this.vueApp.component('livue-lazy', createLazyComponent(this));\n        }\n\n        // Apply plugins to Vue app:\n        // 1. Install Pinia (LiVue uses it internally for state management)\n        // 2. Apply user's setup callback (for Vuetify, custom plugins, etc.)\n        // 3. Mount the app\n        this._applyPluginsAndMount();\n    }\n\n    /**\n     * Apply plugins and mount the Vue app.\n     * Called once during _mount(), after createApp() and child registration.\n     *\n     * Order:\n     * 1. Install Pinia (required internally by LiVue)\n     * 2. Call LiVue.setup() callback if defined (user plugins like Vuetify)\n     * 3. Register built-in LiVue directives (v-click, v-loading, etc.)\n     * 4. Mount the Vue app\n     *\n     * @private\n     */\n    async _applyPluginsAndMount() {\n        let self = this;\n        let app = this.vueApp;\n\n        // 1. Install Pinia (LiVue uses it internally)\n        let piniaInstance = createPinia();\n        app.use(piniaInstance);\n\n        // 2. Apply user's setup callbacks AFTER Pinia\n        // This allows users to add Vuetify, custom components, directives, etc.\n        // Multiple callbacks are supported (accumulated via LiVue.setup())\n        if (window.LiVue && window.LiVue._setupCallbacks && window.LiVue._setupCallbacks.length > 0) {\n            for (let i = 0; i < window.LiVue._setupCallbacks.length; i++) {\n                try {\n                    let result = window.LiVue._setupCallbacks[i](app);\n                    // Support async setup callbacks\n                    if (result && typeof result.then === 'function') {\n                        await result;\n                    }\n                } catch (error) {\n                    console.error('[LiVue] Error in setup() callback:', error);\n                }\n            }\n        }\n\n        // 3. Register built-in LiVue directives\n        let directives = getBuiltInDirectives();\n        for (let i = 0; i < directives.length; i++) {\n            app.directive(directives[i].name, directives[i].directive);\n        }\n\n        // 4. Mount the Vue app\n        self.el.innerHTML = '';\n        self.vueApp.mount(self.el);\n    }\n\n    /**\n     * Destroy the Vue app instance and clean up event listeners.\n     */\n    destroy() {\n        // Trigger component.destroy hook for all children first\n        for (let id in this._childRegistry) {\n            let child = this._childRegistry[id];\n\n            // Trigger component.destroy hook for child\n            trigger('component.destroy', {\n                component: { id: id, name: child.name, state: child.state, livue: child.livue },\n                isChild: true,\n            });\n\n            // Run child cleanup functions from hooks\n            if (child.livue && child.livue._cleanups) {\n                child.livue._cleanups.runCleanups();\n            }\n\n            removeByComponentId(id);\n            clearModifiers(id);\n            removeComponentErrorHandler(id);\n\n            // Unregister children from TabSync\n            if (child && child.memo && child.memo.tabSync && child.memo.tabSync.enabled) {\n                unregisterTabSync(child.name);\n            }\n\n            // Unsubscribe children from Laravel Echo\n            unsubscribeEcho(id);\n        }\n\n        // Trigger component.destroy hook for root\n        trigger('component.destroy', {\n            component: { id: this.componentId, name: this.name, state: this.state, livue: this._rootLivue },\n            isChild: false,\n        });\n\n        // Run root cleanup functions from hooks\n        if (this._cleanups) {\n            this._cleanups.runCleanups();\n        }\n\n        // Remove event listeners for root component\n        removeByComponentId(this.componentId);\n\n        // Clean up debounce/throttle modifiers for root component\n        clearModifiers(this.componentId);\n\n        // Remove component error handler\n        removeComponentErrorHandler(this.componentId);\n\n        // Unregister from TabSync if enabled\n        if (this.memo && this.memo.tabSync && this.memo.tabSync.enabled) {\n            unregisterTabSync(this.name);\n        }\n\n        // Unsubscribe from Laravel Echo\n        if (this._echoUnsubscribe) {\n            this._echoUnsubscribe();\n            this._echoUnsubscribe = null;\n        }\n        unsubscribeEcho(this.componentId);\n\n        if (this.vueApp) {\n            this.vueApp.unmount();\n            this.vueApp = null;\n        }\n    }\n}\n","/**\n * v-init Directive\n *\n * Executes a function when the component mounts.\n * Useful for initial data loading or setup.\n *\n * Usage:\n *   <div v-init=\"'loadData'\">...</div>\n *   <div v-init=\"['loadData', [param1, param2]]\">...</div>\n *\n * The function is called via livue.call() which supports both\n * server methods and #[Vue] client-side methods.\n *\n * IMPORTANT: v-init only fires ONCE per component lifecycle.\n * Template swaps (from server responses) do NOT re-trigger v-init.\n * This prevents infinite loops when v-init calls a server method.\n */\n\n/**\n * Track which component IDs have already been initialized.\n * This prevents v-init from firing again after template swaps.\n * @type {Set<string>}\n */\nlet _initializedComponents = new Set();\n\n/**\n * Get the livue helper from a vnode context.\n * Traverses up the parent chain if needed.\n *\n * @param {object} vnode - Vue vnode\n * @returns {object|null} - livue helper or null\n */\nfunction getLivueFromVnode(vnode) {\n    let ctx = vnode.ctx;\n\n    // Try direct setupState first\n    if (ctx && ctx.setupState && ctx.setupState.livue) {\n        return ctx.setupState.livue;\n    }\n\n    // Try parent's setupState (for nested elements)\n    if (ctx && ctx.parent && ctx.parent.setupState && ctx.parent.setupState.livue) {\n        return ctx.parent.setupState.livue;\n    }\n\n    // Walk up the parent chain\n    let parent = ctx ? ctx.parent : null;\n    while (parent) {\n        if (parent.setupState && parent.setupState.livue) {\n            return parent.setupState.livue;\n        }\n        parent = parent.parent;\n    }\n\n    return null;\n}\n\nexport default {\n    mounted(el, binding, vnode) {\n        let livue = getLivueFromVnode(vnode);\n\n        if (!livue) {\n            console.warn('[LiVue] v-init: livue helper not found in component context');\n            return;\n        }\n\n        // Find the component ID from the closest data-livue-id element\n        let componentEl = el.closest('[data-livue-id]');\n        let componentId = componentEl ? componentEl.dataset.livueId : null;\n\n        // Create a unique key for this v-init instance\n        // Combines component ID + method name to allow multiple v-init on same component\n        let value = binding.value;\n        let method;\n        let params = [];\n\n        // Parse value: string or [method, params] array\n        if (Array.isArray(value)) {\n            method = value[0];\n            params = value[1] || [];\n        } else {\n            method = value;\n        }\n\n        if (typeof method !== 'string') {\n            console.warn('[LiVue] v-init: expected method name (string), got', typeof method);\n            return;\n        }\n\n        // Build unique key for this v-init\n        let initKey = (componentId || 'unknown') + ':' + method;\n\n        // Check if already initialized (prevents loops from template swaps)\n        if (_initializedComponents.has(initKey)) {\n            return;\n        }\n\n        // Mark as initialized\n        _initializedComponents.add(initKey);\n\n        // Call the method\n        livue.call(method, params);\n    },\n\n    // NOTE: No unmounted cleanup - v-init should only fire ONCE per component\n    // lifetime, even across template swaps. The _initializedComponents set\n    // persists for the page lifetime. This is intentional to prevent loops.\n};\n","/**\n * v-submit Directive\n *\n * Handles form submission with automatic preventDefault.\n * Calls a server method on form submission.\n *\n * Usage:\n *   <form v-submit=\"'save'\">...</form>\n *   <form v-submit=\"['save', [userId]]\">...</form>\n *\n * Automatically prevents the default form submission and calls\n * the specified method via livue.call().\n */\n\n/**\n * WeakMap to store event handlers for cleanup.\n * @type {WeakMap<HTMLElement, Function>}\n */\nconst handlers = new WeakMap();\n\n/**\n * Get the livue helper from a vnode context.\n *\n * @param {object} vnode - Vue vnode\n * @returns {object|null} - livue helper or null\n */\nfunction getLivueFromVnode(vnode) {\n    let ctx = vnode.ctx;\n\n    if (ctx && ctx.setupState && ctx.setupState.livue) {\n        return ctx.setupState.livue;\n    }\n\n    if (ctx && ctx.parent && ctx.parent.setupState && ctx.parent.setupState.livue) {\n        return ctx.parent.setupState.livue;\n    }\n\n    let parent = ctx ? ctx.parent : null;\n    while (parent) {\n        if (parent.setupState && parent.setupState.livue) {\n            return parent.setupState.livue;\n        }\n        parent = parent.parent;\n    }\n\n    return null;\n}\n\nexport default {\n    mounted(el, binding, vnode) {\n        // Warn if not used on a form element\n        if (el.tagName !== 'FORM') {\n            console.warn('[LiVue] v-submit should be used on <form> elements, got <' + el.tagName.toLowerCase() + '>');\n        }\n\n        let livue = getLivueFromVnode(vnode);\n\n        if (!livue) {\n            console.warn('[LiVue] v-submit: livue helper not found in component context');\n            return;\n        }\n\n        let value = binding.value;\n        let method;\n        let params = [];\n\n        // Parse value: string or [method, params] array\n        if (Array.isArray(value)) {\n            method = value[0];\n            params = value[1] || [];\n        } else {\n            method = value;\n        }\n\n        if (typeof method !== 'string') {\n            console.warn('[LiVue] v-submit: expected method name (string), got', typeof method);\n            return;\n        }\n\n        // Create the submit handler\n        let handler = function (e) {\n            e.preventDefault();\n            livue.call(method, params);\n        };\n\n        // Attach the handler\n        el.addEventListener('submit', handler);\n\n        // Store for cleanup\n        handlers.set(el, handler);\n    },\n\n    unmounted(el) {\n        let handler = handlers.get(el);\n\n        if (handler) {\n            el.removeEventListener('submit', handler);\n            handlers.delete(el);\n        }\n    },\n};\n","/**\n * v-intersect Directive\n *\n * Executes action when element enters/exits viewport using IntersectionObserver.\n * Uses IntersectionObserver to trigger actions on visibility.\n *\n * Usage:\n *   <div v-intersect=\"'loadMore'\">...</div>\n *   <div v-intersect.once=\"'trackView'\">...</div>\n *   <div v-intersect.leave=\"'onExit'\">...</div>\n *   <div v-intersect.half=\"'halfVisible'\">...</div>\n *   <div v-intersect.full=\"'fullyVisible'\">...</div>\n *   <div v-intersect:100=\"'withMargin'\">...</div>\n *\n * Modifiers:\n *   .once   - Only trigger once\n *   .leave  - Trigger when leaving viewport (default is enter)\n *   .half   - 50% visibility threshold\n *   .full   - 100% visibility threshold\n *   :N      - Custom margin in pixels (arg)\n */\n\n/**\n * WeakMap to store observers for cleanup.\n * @type {WeakMap<HTMLElement, IntersectionObserver>}\n */\nconst observers = new WeakMap();\n\n/**\n * Get the livue helper from a vnode context.\n *\n * @param {object} vnode - Vue vnode\n * @returns {object|null} - livue helper or null\n */\nfunction getLivueFromVnode(vnode) {\n    let ctx = vnode.ctx;\n\n    if (ctx && ctx.setupState && ctx.setupState.livue) {\n        return ctx.setupState.livue;\n    }\n\n    if (ctx && ctx.parent && ctx.parent.setupState && ctx.parent.setupState.livue) {\n        return ctx.parent.setupState.livue;\n    }\n\n    let parent = ctx ? ctx.parent : null;\n    while (parent) {\n        if (parent.setupState && parent.setupState.livue) {\n            return parent.setupState.livue;\n        }\n        parent = parent.parent;\n    }\n\n    return null;\n}\n\nexport default {\n    mounted(el, binding, vnode) {\n        let livue = getLivueFromVnode(vnode);\n\n        if (!livue) {\n            console.warn('[LiVue] v-intersect: livue helper not found in component context');\n            return;\n        }\n\n        let value = binding.value;\n        let method;\n        let params = [];\n\n        // Parse value: string or [method, params] array\n        if (Array.isArray(value)) {\n            method = value[0];\n            params = value[1] || [];\n        } else {\n            method = value;\n        }\n\n        if (typeof method !== 'string') {\n            console.warn('[LiVue] v-intersect: expected method name (string), got', typeof method);\n            return;\n        }\n\n        let modifiers = binding.modifiers || {};\n        let arg = binding.arg; // margin value\n\n        // Determine threshold\n        let threshold = 0;\n        if (modifiers.half) {\n            threshold = 0.5;\n        }\n        if (modifiers.full) {\n            threshold = 1.0;\n        }\n\n        // Determine margin\n        let rootMargin = '0px';\n        if (arg) {\n            let marginValue = parseInt(arg, 10);\n            if (!isNaN(marginValue)) {\n                rootMargin = marginValue + 'px';\n            }\n        }\n\n        // Track leave mode\n        let isLeaveMode = modifiers.leave === true;\n        let hasTriggered = false;\n\n        // Create the IntersectionObserver\n        let observer = new IntersectionObserver(\n            function (entries) {\n                let entry = entries[0];\n\n                // Determine if we should trigger\n                let shouldTrigger = isLeaveMode\n                    ? !entry.isIntersecting\n                    : entry.isIntersecting;\n\n                if (shouldTrigger && (!modifiers.once || !hasTriggered)) {\n                    hasTriggered = true;\n                    livue.call(method, params);\n\n                    // Disconnect if .once modifier\n                    if (modifiers.once) {\n                        observer.disconnect();\n                        observers.delete(el);\n                    }\n                }\n            },\n            {\n                threshold: threshold,\n                rootMargin: rootMargin,\n            }\n        );\n\n        observer.observe(el);\n        observers.set(el, observer);\n    },\n\n    unmounted(el) {\n        let observer = observers.get(el);\n\n        if (observer) {\n            observer.disconnect();\n            observers.delete(el);\n        }\n    },\n};\n","/**\n * v-current Directive\n *\n * Highlights navigation links that match the current URL.\n * Applies CSS classes based on current route matching.\n *\n * Usage:\n *   <a href=\"/posts\" v-current=\"'text-blue-600 font-bold'\">Posts</a>\n *   <a href=\"/posts\" v-current.exact=\"'active'\">Posts</a>\n *   <a href=\"/posts\" v-current.strict=\"'active'\">Posts</a>\n *\n * Modifiers:\n *   (default) - Partial match: current URL starts with href\n *   .exact    - Exact match (ignoring trailing slash)\n *   .strict   - Strict match (including trailing slash)\n *\n * The directive automatically updates when the URL changes via\n * pushState/replaceState or popstate events.\n */\n\n/**\n * WeakMap to store cleanup functions.\n * @type {WeakMap<HTMLElement, Function>}\n */\nconst cleanups = new WeakMap();\n\n/**\n * Update current state for an element.\n *\n * @param {HTMLElement} el\n * @param {object} binding\n */\nfunction updateCurrent(el, binding) {\n    let href = el.getAttribute('href');\n\n    if (!href) {\n        return;\n    }\n\n    let classes = binding.value;\n    let modifiers = binding.modifiers || {};\n\n    // Get current path and link path\n    let currentPath = window.location.pathname;\n    let linkPath;\n\n    try {\n        linkPath = new URL(href, window.location.origin).pathname;\n    } catch (e) {\n        // Invalid URL, skip\n        return;\n    }\n\n    let isMatch = false;\n\n    if (modifiers.strict) {\n        // Strict: exact match including trailing slash\n        isMatch = currentPath === linkPath;\n    } else if (modifiers.exact) {\n        // Exact: match without trailing slash consideration\n        let normalizedCurrent = currentPath.replace(/\\/$/, '') || '/';\n        let normalizedLink = linkPath.replace(/\\/$/, '') || '/';\n        isMatch = normalizedCurrent === normalizedLink;\n    } else {\n        // Partial: current starts with link path\n        let normalizedLink = linkPath.replace(/\\/$/, '') || '/';\n        // Ensure we don't match /posts for /posts-archive\n        if (normalizedLink === '/') {\n            isMatch = currentPath === '/';\n        } else {\n            isMatch = currentPath === normalizedLink ||\n                      currentPath.startsWith(normalizedLink + '/');\n        }\n    }\n\n    // Apply or remove classes\n    if (typeof classes === 'string') {\n        let classList = classes.split(' ').filter(function (c) {\n            return c.trim();\n        });\n\n        if (isMatch) {\n            classList.forEach(function (cls) {\n                el.classList.add(cls);\n            });\n            el.setAttribute('data-current', '');\n        } else {\n            classList.forEach(function (cls) {\n                el.classList.remove(cls);\n            });\n            el.removeAttribute('data-current');\n        }\n    }\n}\n\nexport default {\n    mounted(el, binding) {\n        // Initial update\n        updateCurrent(el, binding);\n\n        // Listen for URL changes\n        let onUrlChange = function () {\n            updateCurrent(el, binding);\n        };\n\n        // popstate fires on back/forward navigation\n        window.addEventListener('popstate', onUrlChange);\n\n        // Custom event for LiVue SPA navigation\n        window.addEventListener('livue:navigated', onUrlChange);\n\n        // Store cleanup function\n        cleanups.set(el, function () {\n            window.removeEventListener('popstate', onUrlChange);\n            window.removeEventListener('livue:navigated', onUrlChange);\n        });\n    },\n\n    updated(el, binding) {\n        updateCurrent(el, binding);\n    },\n\n    unmounted(el, binding) {\n        // Remove classes\n        let classes = binding.value;\n        if (typeof classes === 'string') {\n            classes.split(' ').filter(function (c) {\n                return c.trim();\n            }).forEach(function (cls) {\n                el.classList.remove(cls);\n            });\n        }\n        el.removeAttribute('data-current');\n\n        // Call cleanup\n        let cleanup = cleanups.get(el);\n        if (cleanup) {\n            cleanup();\n            cleanups.delete(el);\n        }\n    },\n};\n","/**\n * v-ignore Directive\n *\n * Preserves element content during template swaps.\n * Useful for third-party widgets that manage their own DOM.\n *\n * Usage:\n *   <div v-ignore>\n *       <third-party-widget></third-party-widget>\n *   </div>\n *   <div v-ignore.self>\n *       <span>Dynamic content preserved</span>\n *   </div>\n *\n * Modifiers:\n *   (default) - Preserve entire element and all children\n *   .self     - Only preserve element itself (attributes), children can update\n *\n * The directive marks elements with a special attribute and ID that\n * the template swap logic in component.js uses to preserve content.\n */\n\nlet _ignoreCounter = 0;\n\nexport default {\n    /**\n     * Called before the element is inserted into the DOM.\n     * We set up the ignore markers here.\n     */\n    created(el, binding) {\n        // Generate unique ID for matching during template swap\n        _ignoreCounter++;\n        let ignoreId = 'livue-ignore-' + _ignoreCounter;\n\n        // Store on element for the template swap logic\n        el.__livue_ignore = true;\n        el.__livue_ignore_self = binding.modifiers.self === true;\n        el.__livue_ignore_id = ignoreId;\n\n        // Add data attribute for CSS selection during template processing\n        el.setAttribute('data-livue-ignore-id', ignoreId);\n\n        if (binding.modifiers.self) {\n            el.setAttribute('data-livue-ignore-self', '');\n        }\n    },\n\n    mounted(el, binding) {\n        // Ensure markers are present after mount\n        if (!el.hasAttribute('data-livue-ignore-id')) {\n            el.setAttribute('data-livue-ignore-id', el.__livue_ignore_id);\n        }\n    },\n\n    unmounted(el) {\n        // Cleanup\n        delete el.__livue_ignore;\n        delete el.__livue_ignore_self;\n        delete el.__livue_ignore_id;\n    },\n};\n","/**\n * v-model-livue Directive\n *\n * Enhanced v-model with timing and type modifiers.\n * Provides timing and type modifiers for v-model.\n *\n * Supports both native HTML inputs AND Vue components (like Vuetify).\n *\n * Usage:\n *   <input v-model-livue:name>\n *   <input v-model-livue:name.blur>\n *   <input v-model-livue:search.debounce.300ms>\n *   <v-text-field v-model-livue:search.debounce.500ms>\n *\n * Modifiers:\n *   .blur          - Sync only on blur event\n *   .change/.lazy  - Sync only on change event\n *   .enter         - Sync only on Enter keypress\n *   .live          - Sync immediately with 150ms debounce\n *   .debounce.Xms  - Custom debounce (e.g., .debounce.300ms)\n *   .throttle.Xms  - Custom throttle (e.g., .throttle.500ms)\n *   .number        - Cast value to number\n *   .boolean       - Cast value to boolean\n *\n * The property name is passed as the directive argument:\n *   v-model-livue:propertyName\n */\n\nimport { getDebounced, getThrottled } from '../helpers/modifiers.js';\nimport { watch } from 'vue';\n\n/**\n * WeakMap to store binding info for cleanup.\n * @type {WeakMap<HTMLElement, object>}\n */\nconst bindings = new WeakMap();\n\nlet _modelCounter = 0;\n\n/**\n * Get the livue helper and state from a vnode context.\n *\n * @param {object} vnode - Vue vnode\n * @returns {object|null} - { livue, state } or null\n */\nfunction getContextFromVnode(vnode) {\n    let ctx = vnode.ctx;\n\n    if (ctx && ctx.setupState && ctx.setupState.livue) {\n        return {\n            livue: ctx.setupState.livue,\n            state: ctx.setupState,\n        };\n    }\n\n    if (ctx && ctx.parent && ctx.parent.setupState && ctx.parent.setupState.livue) {\n        return {\n            livue: ctx.parent.setupState.livue,\n            state: ctx.parent.setupState,\n        };\n    }\n\n    let parent = ctx ? ctx.parent : null;\n    while (parent) {\n        if (parent.setupState && parent.setupState.livue) {\n            return {\n                livue: parent.setupState.livue,\n                state: parent.setupState,\n            };\n        }\n        parent = parent.parent;\n    }\n\n    return null;\n}\n\n/**\n * Parse timing modifiers from modifier object.\n * Vue compiles .debounce.500ms as { debounce: true, 500ms: true }\n * So we need to look for both patterns:\n * - Combined: debounce500ms, debounce.500ms\n * - Separate: debounce + 500ms (or just 500)\n *\n * @param {object} modifiers\n * @returns {object} { debounceMs, throttleMs }\n */\nfunction parseTimingModifiers(modifiers) {\n    let debounceMs = 0;\n    let throttleMs = 0;\n    let hasDebounce = false;\n    let hasThrottle = false;\n    let timingValue = 0;\n\n    for (let mod in modifiers) {\n        // Check for standalone debounce/throttle flags\n        if (mod === 'debounce') {\n            hasDebounce = true;\n            continue;\n        }\n        if (mod === 'throttle') {\n            hasThrottle = true;\n            continue;\n        }\n\n        // Match combined pattern: debounce500ms or debounce.500ms\n        let debounceMatch = mod.match(/^debounce\\.?(\\d+)(ms)?$/i);\n        if (debounceMatch) {\n            debounceMs = parseInt(debounceMatch[1], 10);\n            continue;\n        }\n\n        // Match combined pattern: throttle500ms or throttle.500ms\n        let throttleMatch = mod.match(/^throttle\\.?(\\d+)(ms)?$/i);\n        if (throttleMatch) {\n            throttleMs = parseInt(throttleMatch[1], 10);\n            continue;\n        }\n\n        // Match standalone timing value: 500ms or just 500\n        // Note: Vue compiles .500ms as modifier \"500ms\" (string with ms suffix)\n        let timingMatch = mod.match(/^(\\d+)(ms)?$/);\n        if (timingMatch) {\n            timingValue = parseInt(timingMatch[1], 10);\n        }\n    }\n\n    // Apply standalone timing value to the appropriate flag\n    if (hasDebounce && timingValue > 0) {\n        debounceMs = timingValue;\n    }\n    if (hasThrottle && timingValue > 0) {\n        throttleMs = timingValue;\n    }\n\n    // Default debounce if flag present but no value\n    if (hasDebounce && debounceMs === 0) {\n        debounceMs = 150; // Default debounce\n    }\n    if (hasThrottle && throttleMs === 0) {\n        throttleMs = 150; // Default throttle\n    }\n\n    return { debounceMs, throttleMs };\n}\n\n/**\n * Get value from input element based on type.\n *\n * @param {HTMLElement} el\n * @returns {*}\n */\nfunction getInputValue(el) {\n    if (el.type === 'checkbox') {\n        return el.checked;\n    }\n    if (el.type === 'radio') {\n        return el.checked ? el.value : null;\n    }\n    if (el.tagName === 'SELECT' && el.multiple) {\n        return Array.from(el.selectedOptions).map(function (opt) {\n            return opt.value;\n        });\n    }\n    return el.value;\n}\n\n/**\n * Set value on input element based on type.\n *\n * @param {HTMLElement} el\n * @param {*} value\n */\nfunction setInputValue(el, value) {\n    if (el.type === 'checkbox') {\n        el.checked = Boolean(value);\n    } else if (el.type === 'radio') {\n        el.checked = el.value === String(value);\n    } else if (el.tagName === 'SELECT' && el.multiple) {\n        let values = Array.isArray(value) ? value.map(String) : [String(value)];\n        Array.from(el.options).forEach(function (opt) {\n            opt.selected = values.includes(opt.value);\n        });\n    } else {\n        if (el.value !== String(value || '')) {\n            el.value = value || '';\n        }\n    }\n}\n\n/**\n * Check if the vnode is a Vue component (not a native element).\n *\n * @param {object} vnode\n * @returns {boolean}\n */\nfunction isVueComponent(vnode) {\n    return !!(vnode.component);\n}\n\n/**\n * Find the internal input element within a Vue component's DOM.\n * Useful for component libraries like Vuetify.\n *\n * @param {HTMLElement} el - Root element of the component\n * @returns {HTMLInputElement|HTMLTextAreaElement|null}\n */\nfunction findInternalInput(el) {\n    // Try to find an input or textarea inside the component\n    return el.querySelector('input, textarea, select');\n}\n\nexport default {\n    mounted(el, binding, vnode) {\n        let context = getContextFromVnode(vnode);\n\n        if (!context) {\n            console.warn('[LiVue] v-model-livue: livue helper not found in component context');\n            return;\n        }\n\n        let { livue, state } = context;\n        let property = binding.arg;\n\n        if (!property) {\n            console.warn('[LiVue] v-model-livue requires property name as argument (v-model-livue:propertyName)');\n            return;\n        }\n\n        let modifiers = binding.modifiers || {};\n\n        // Generate unique ID for debounce/throttle\n        _modelCounter++;\n        let modelId = 'model-' + _modelCounter;\n\n        // Determine event type for native inputs\n        let eventType = 'input';\n        if (modifiers.blur) {\n            eventType = 'blur';\n        }\n        if (modifiers.change || modifiers.lazy) {\n            eventType = 'change';\n        }\n\n        // Parse timing modifiers\n        let { debounceMs, throttleMs } = parseTimingModifiers(modifiers);\n\n        // Live mode: default 150ms debounce if no explicit timing\n        if (modifiers.live && !debounceMs && !throttleMs) {\n            debounceMs = 150;\n        }\n\n        /**\n         * Update the state property with optional type casting.\n         *\n         * @param {*} value\n         */\n        function updateValue(value) {\n            // Type casting\n            if (modifiers.number) {\n                let num = Number(value);\n                value = isNaN(num) ? 0 : num;\n            }\n            if (modifiers.boolean) {\n                value = Boolean(value) && value !== 'false' && value !== '0';\n            }\n\n            // Update state (this is a Vue ref)\n            if (state[property] && typeof state[property] === 'object' && 'value' in state[property]) {\n                state[property].value = value;\n            } else {\n                state[property] = value;\n            }\n        }\n\n        /**\n         * Create a value handler with optional timing (debounce/throttle).\n         *\n         * @param {*} value\n         */\n        function handleValueChange(value) {\n            if (debounceMs > 0) {\n                let debounced = getDebounced(modelId, debounceMs);\n                debounced(function () {\n                    updateValue(value);\n                });\n            } else if (throttleMs > 0) {\n                let throttled = getThrottled(modelId, throttleMs);\n                throttled(function () {\n                    updateValue(value);\n                });\n            } else {\n                updateValue(value);\n            }\n        }\n\n        // Get initial value from state\n        let initialValue;\n        if (state[property] && typeof state[property] === 'object' && 'value' in state[property]) {\n            initialValue = state[property].value;\n        } else {\n            initialValue = state[property];\n        }\n\n        // Check if this is a Vue component or native element\n        let isComponent = isVueComponent(vnode);\n        let componentInstance = vnode.component;\n        let handler = null;\n        let keyHandler = null;\n        let stopWatcher = null;\n        let originalEmit = null;\n\n        if (isComponent && componentInstance) {\n            // === VUE COMPONENT MODE ===\n            // For Vue components (like Vuetify), we intercept the emit function\n            // to catch 'update:modelValue' events\n\n            // Store original emit\n            originalEmit = componentInstance.emit;\n\n            // Create wrapper that intercepts update:modelValue\n            componentInstance.emit = function (event, ...args) {\n                if (event === 'update:modelValue') {\n                    let newValue = args[0];\n                    handleValueChange(newValue);\n\n                    // Don't call original emit - we're handling the update ourselves\n                    // But we need to update the component's internal state\n                    // by setting the prop through Vue's reactivity\n                    return;\n                }\n                // For other events, call original\n                return originalEmit.call(componentInstance, event, ...args);\n            };\n\n            // Set initial value on the component via props\n            // We need to update the component's modelValue prop\n            if (componentInstance.props && 'modelValue' in componentInstance.props) {\n                // The component expects modelValue - we'll sync from our state\n                // Watch our state and update component when it changes\n                stopWatcher = watch(\n                    function () {\n                        if (state[property] && typeof state[property] === 'object' && 'value' in state[property]) {\n                            return state[property].value;\n                        }\n                        return state[property];\n                    },\n                    function (newVal) {\n                        // Update the component's vnode props to trigger re-render\n                        if (componentInstance.vnode && componentInstance.vnode.props) {\n                            componentInstance.vnode.props.modelValue = newVal;\n                        }\n                        // Also try to update via exposed or internal methods\n                        if (componentInstance.exposed && typeof componentInstance.exposed.setValue === 'function') {\n                            componentInstance.exposed.setValue(newVal);\n                        }\n                        // Force update the component\n                        if (componentInstance.update) {\n                            componentInstance.update();\n                        }\n                    },\n                    { immediate: true }\n                );\n            }\n\n            // Store for cleanup\n            bindings.set(el, {\n                isComponent: true,\n                componentInstance: componentInstance,\n                originalEmit: originalEmit,\n                stopWatcher: stopWatcher,\n                property: property,\n                state: state,\n                modifiers: modifiers,\n            });\n        } else {\n            // === NATIVE INPUT MODE ===\n            // For native HTML elements (input, textarea, select)\n\n            // Create handler with timing\n            if (debounceMs > 0) {\n                let debounced = getDebounced(modelId, debounceMs);\n                handler = function (e) {\n                    let value = getInputValue(e.target);\n                    debounced(function () {\n                        updateValue(value);\n                    });\n                };\n            } else if (throttleMs > 0) {\n                let throttled = getThrottled(modelId, throttleMs);\n                handler = function (e) {\n                    let value = getInputValue(e.target);\n                    throttled(function () {\n                        updateValue(value);\n                    });\n                };\n            } else {\n                handler = function (e) {\n                    updateValue(getInputValue(e.target));\n                };\n            }\n\n            // Handle enter key modifier\n            if (modifiers.enter) {\n                keyHandler = function (e) {\n                    if (e.key === 'Enter') {\n                        updateValue(getInputValue(e.target));\n                    }\n                };\n                el.addEventListener('keyup', keyHandler);\n            } else {\n                el.addEventListener(eventType, handler);\n            }\n\n            // Set initial value\n            setInputValue(el, initialValue);\n\n            // Store binding info for cleanup and updates\n            bindings.set(el, {\n                isComponent: false,\n                handler: handler,\n                keyHandler: keyHandler,\n                eventType: eventType,\n                property: property,\n                modifiers: modifiers,\n                state: state,\n            });\n        }\n    },\n\n    updated(el, binding, vnode) {\n        let info = bindings.get(el);\n\n        if (!info) {\n            return;\n        }\n\n        // For native inputs, update element value from state\n        if (!info.isComponent) {\n            let { property, state } = info;\n            let currentValue;\n\n            if (state[property] && typeof state[property] === 'object' && 'value' in state[property]) {\n                currentValue = state[property].value;\n            } else {\n                currentValue = state[property];\n            }\n\n            setInputValue(el, currentValue);\n        }\n        // For Vue components, the watcher handles updates\n    },\n\n    unmounted(el) {\n        let info = bindings.get(el);\n\n        if (info) {\n            if (info.isComponent) {\n                // Restore original emit function\n                if (info.componentInstance && info.originalEmit) {\n                    info.componentInstance.emit = info.originalEmit;\n                }\n                // Stop the watcher\n                if (info.stopWatcher) {\n                    info.stopWatcher();\n                }\n            } else {\n                // Remove native event listeners\n                if (info.keyHandler) {\n                    el.removeEventListener('keyup', info.keyHandler);\n                } else if (info.handler) {\n                    el.removeEventListener(info.eventType, info.handler);\n                }\n            }\n            bindings.delete(el);\n        }\n    },\n};\n","/**\n * v-poll Directive\n *\n * Automatically polls the server at regular intervals.\n * Enables automatic server refresh at configurable intervals.\n *\n * Usage:\n *   <div v-poll>...</div>                        <!-- Refresh every 2.5s -->\n *   <div v-poll=\"'refreshData'\">...</div>        <!-- Call method every 2.5s -->\n *   <div v-poll.5s=\"'getData'\">...</div>         <!-- Custom interval in seconds -->\n *   <div v-poll.500ms=\"'getData'\">...</div>      <!-- Custom interval in milliseconds -->\n *   <div v-poll.visible=\"'getData'\">...</div>    <!-- Only poll when visible -->\n *   <div v-poll.keep-alive>...</div>             <!-- Continue polling when tab inactive -->\n *\n * Modifiers:\n *   .Xs       - Interval in seconds (e.g., .5s, .10s)\n *   .Xms      - Interval in milliseconds (e.g., .500ms, .2000ms)\n *   .visible  - Only poll when element is in viewport\n *   .keep-alive - Continue polling even when tab is inactive\n */\n\n/**\n * WeakMap to store poll state for cleanup.\n * @type {WeakMap<HTMLElement, object>}\n */\nconst pollState = new WeakMap();\n\n/**\n * Default poll interval in milliseconds (2.5 seconds).\n */\nconst DEFAULT_INTERVAL = 2500;\n\n/**\n * Parse interval from modifiers.\n *\n * @param {object} modifiers - Binding modifiers\n * @returns {number} - Interval in milliseconds\n */\nfunction parseInterval(modifiers) {\n    for (let key of Object.keys(modifiers)) {\n        // Check for seconds format: 5s, 10s, etc.\n        let secondsMatch = key.match(/^(\\d+)s$/);\n        if (secondsMatch) {\n            return parseInt(secondsMatch[1], 10) * 1000;\n        }\n\n        // Check for milliseconds format: 500ms, 2000ms, etc.\n        let msMatch = key.match(/^(\\d+)ms$/);\n        if (msMatch) {\n            return parseInt(msMatch[1], 10);\n        }\n    }\n\n    return DEFAULT_INTERVAL;\n}\n\n/**\n * Get the livue helper from a vnode context.\n *\n * @param {object} vnode - Vue vnode\n * @returns {object|null} - livue helper or null\n */\nfunction getLivueFromVnode(vnode) {\n    let ctx = vnode.ctx;\n\n    if (ctx && ctx.setupState && ctx.setupState.livue) {\n        return ctx.setupState.livue;\n    }\n\n    if (ctx && ctx.parent && ctx.parent.setupState && ctx.parent.setupState.livue) {\n        return ctx.parent.setupState.livue;\n    }\n\n    let parent = ctx ? ctx.parent : null;\n    while (parent) {\n        if (parent.setupState && parent.setupState.livue) {\n            return parent.setupState.livue;\n        }\n        parent = parent.parent;\n    }\n\n    return null;\n}\n\nexport default {\n    mounted(el, binding, vnode) {\n        let livue = getLivueFromVnode(vnode);\n\n        if (!livue) {\n            console.warn('[LiVue] v-poll: livue helper not found in component context');\n            return;\n        }\n\n        let value = binding.value;\n        let method = null;\n        let params = [];\n\n        // Parse value: string, array, or undefined (refresh)\n        if (Array.isArray(value)) {\n            method = value[0];\n            params = value[1] || [];\n        } else if (typeof value === 'string') {\n            method = value;\n        }\n        // If no value, we'll call $refresh (re-render component)\n\n        let modifiers = binding.modifiers || {};\n        let interval = parseInterval(modifiers);\n        let keepAlive = modifiers['keep-alive'] === true;\n        let visibleOnly = modifiers.visible === true;\n\n        // Track state\n        let state = {\n            intervalId: null,\n            observer: null,\n            isVisible: !visibleOnly, // If not visibleOnly, assume visible\n            isPaused: false,\n        };\n\n        /**\n         * Execute the poll action.\n         */\n        function doPoll() {\n            // Skip if paused (tab inactive and not keep-alive)\n            if (state.isPaused) {\n                return;\n            }\n\n            // Skip if visibleOnly and not visible\n            if (visibleOnly && !state.isVisible) {\n                return;\n            }\n\n            if (method) {\n                livue.call(method, params);\n            } else {\n                // No method specified = refresh component\n                livue.call('$refresh', []);\n            }\n        }\n\n        /**\n         * Start the poll interval.\n         */\n        function startPoll() {\n            if (state.intervalId) {\n                return; // Already running\n            }\n            state.intervalId = setInterval(doPoll, interval);\n        }\n\n        /**\n         * Stop the poll interval.\n         */\n        function stopPoll() {\n            if (state.intervalId) {\n                clearInterval(state.intervalId);\n                state.intervalId = null;\n            }\n        }\n\n        // Handle visibility changes (tab focus)\n        function handleVisibilityChange() {\n            if (keepAlive) {\n                return; // Don't pause if keep-alive\n            }\n\n            if (document.hidden) {\n                state.isPaused = true;\n            } else {\n                state.isPaused = false;\n            }\n        }\n\n        // Setup IntersectionObserver for .visible modifier\n        if (visibleOnly) {\n            state.observer = new IntersectionObserver(\n                function (entries) {\n                    state.isVisible = entries[0].isIntersecting;\n                },\n                { threshold: 0 }\n            );\n            state.observer.observe(el);\n        }\n\n        // Listen for visibility changes (tab focus/blur)\n        document.addEventListener('visibilitychange', handleVisibilityChange);\n        state.visibilityHandler = handleVisibilityChange;\n\n        // Start polling\n        startPoll();\n\n        // Store state for cleanup\n        pollState.set(el, state);\n    },\n\n    unmounted(el) {\n        let state = pollState.get(el);\n\n        if (state) {\n            // Stop interval\n            if (state.intervalId) {\n                clearInterval(state.intervalId);\n            }\n\n            // Disconnect observer\n            if (state.observer) {\n                state.observer.disconnect();\n            }\n\n            // Remove visibility listener\n            if (state.visibilityHandler) {\n                document.removeEventListener('visibilitychange', state.visibilityHandler);\n            }\n\n            pollState.delete(el);\n        }\n    },\n};\n","/**\n * v-offline Directive\n *\n * Shows content or modifies element when the device is offline.\n * Reacts to network connectivity changes.\n *\n * Usage:\n *   <div v-offline>You are offline</div>                    <!-- Show when offline -->\n *   <div v-offline.class=\"'bg-red-500'\">...</div>           <!-- Add class when offline -->\n *   <div v-offline.class.remove=\"'bg-green-500'\">...</div>  <!-- Remove class when offline -->\n *   <button v-offline.attr=\"'disabled'\">Save</button>       <!-- Add attribute when offline -->\n *\n * Modifiers:\n *   (default)     - Toggle visibility (hidden by default, shown when offline)\n *   .class        - Add the specified class when offline\n *   .class.remove - Remove the specified class when offline\n *   .attr         - Add the specified attribute when offline\n */\n\n/**\n * WeakMap to store offline state for cleanup.\n * @type {WeakMap<HTMLElement, object>}\n */\nconst offlineState = new WeakMap();\n\n/**\n * Global online/offline state tracking.\n */\nlet _isOnline = typeof navigator !== 'undefined' ? navigator.onLine : true;\nlet _listeners = new Set();\n\n/**\n * Initialize global online/offline listeners (once).\n */\nlet _initialized = false;\n\nfunction initGlobalListeners() {\n    if (_initialized || typeof window === 'undefined') {\n        return;\n    }\n    _initialized = true;\n\n    window.addEventListener('online', function () {\n        _isOnline = true;\n        _listeners.forEach(function (callback) {\n            callback(true);\n        });\n    });\n\n    window.addEventListener('offline', function () {\n        _isOnline = false;\n        _listeners.forEach(function (callback) {\n            callback(false);\n        });\n    });\n}\n\nexport default {\n    created(el, binding) {\n        initGlobalListeners();\n\n        let modifiers = binding.modifiers || {};\n        let value = binding.value;\n\n        // Determine mode\n        let mode = 'visibility'; // default: show/hide\n        if (modifiers.class) {\n            mode = modifiers.remove ? 'class-remove' : 'class-add';\n        } else if (modifiers.attr) {\n            mode = 'attr';\n        }\n\n        let state = {\n            mode: mode,\n            value: value,\n            originalDisplay: null,\n        };\n\n        // Store original display for visibility mode\n        if (mode === 'visibility') {\n            state.originalDisplay = el.style.display || '';\n            // Initially hidden (online by default)\n            if (_isOnline) {\n                el.style.display = 'none';\n            }\n        }\n\n        offlineState.set(el, state);\n    },\n\n    mounted(el, binding) {\n        let state = offlineState.get(el);\n        if (!state) {\n            return;\n        }\n\n        /**\n         * Update element based on online/offline status.\n         *\n         * @param {boolean} isOnline - Current online status\n         */\n        function updateElement(isOnline) {\n            let isOffline = !isOnline;\n\n            switch (state.mode) {\n                case 'visibility':\n                    if (isOffline) {\n                        el.style.display = state.originalDisplay || '';\n                    } else {\n                        el.style.display = 'none';\n                    }\n                    break;\n\n                case 'class-add':\n                    if (state.value) {\n                        // Split multiple classes by whitespace\n                        let classesToAdd = state.value.trim().split(/\\s+/);\n                        if (isOffline) {\n                            classesToAdd.forEach(function (cls) {\n                                el.classList.add(cls);\n                            });\n                        } else {\n                            classesToAdd.forEach(function (cls) {\n                                el.classList.remove(cls);\n                            });\n                        }\n                    }\n                    break;\n\n                case 'class-remove':\n                    if (state.value) {\n                        // Split multiple classes by whitespace\n                        let classesToRemove = state.value.trim().split(/\\s+/);\n                        if (isOffline) {\n                            classesToRemove.forEach(function (cls) {\n                                el.classList.remove(cls);\n                            });\n                        } else {\n                            classesToRemove.forEach(function (cls) {\n                                el.classList.add(cls);\n                            });\n                        }\n                    }\n                    break;\n\n                case 'attr':\n                    if (state.value) {\n                        if (isOffline) {\n                            el.setAttribute(state.value, '');\n                        } else {\n                            el.removeAttribute(state.value);\n                        }\n                    }\n                    break;\n            }\n        }\n\n        // Apply initial state\n        updateElement(_isOnline);\n\n        // Store update function for later cleanup\n        state.updateFn = updateElement;\n\n        // Register listener\n        _listeners.add(updateElement);\n    },\n\n    unmounted(el) {\n        let state = offlineState.get(el);\n\n        if (state && state.updateFn) {\n            _listeners.delete(state.updateFn);\n        }\n\n        offlineState.delete(el);\n    },\n};\n","/**\n * v-replace Directive\n *\n * Forces complete element replacement instead of Vue's default DOM reuse.\n * Useful for third-party widgets that need fresh DOM nodes.\n *\n * Usage:\n *   <div v-replace>\n *       <third-party-widget></third-party-widget>\n *   </div>\n *   <div v-replace.self>\n *       <span>Content</span>\n *   </div>\n *\n * Modifiers:\n *   (default) - Replace element and all children on each update\n *   .self     - Only force replacement of the element itself\n *\n * Use cases:\n *   - Third-party JavaScript widgets that manage their own state\n *   - Web Components with Shadow DOM\n *   - Elements that need fresh state on each render\n *\n * How it works:\n *   The directive injects a unique key that changes on each template swap,\n *   forcing Vue to recreate the element instead of reusing it.\n */\n\n/**\n * Counter for generating unique replacement keys.\n */\nlet _replaceCounter = 0;\n\n/**\n * WeakMap to store replace state.\n * @type {WeakMap<HTMLElement, object>}\n */\nconst replaceState = new WeakMap();\n\n/**\n * Global map of replace element IDs to their current version.\n * Used by template processing to inject dynamic keys.\n * @type {Map<string, number>}\n */\nexport const replaceVersions = new Map();\n\n/**\n * Get the next version number for a replace element.\n *\n * @param {string} replaceId - The replace element ID\n * @returns {number} - The new version number\n */\nexport function incrementReplaceVersion(replaceId) {\n    let current = replaceVersions.get(replaceId) || 0;\n    let next = current + 1;\n    replaceVersions.set(replaceId, next);\n    return next;\n}\n\n/**\n * Get current version for a replace element.\n *\n * @param {string} replaceId - The replace element ID\n * @returns {number}\n */\nexport function getReplaceVersion(replaceId) {\n    return replaceVersions.get(replaceId) || 0;\n}\n\nexport default {\n    created(el, binding) {\n        _replaceCounter++;\n        let replaceId = 'livue-replace-' + _replaceCounter;\n        let isSelf = binding.modifiers.self === true;\n\n        // Store state\n        replaceState.set(el, {\n            id: replaceId,\n            isSelf: isSelf,\n            version: 0,\n        });\n\n        // Mark element for template processing\n        el.setAttribute('data-livue-replace-id', replaceId);\n\n        if (isSelf) {\n            el.setAttribute('data-livue-replace-self', '');\n        }\n\n        // Initialize version in global map\n        replaceVersions.set(replaceId, 0);\n    },\n\n    mounted(el, binding) {\n        // Ensure markers are present\n        let state = replaceState.get(el);\n        if (state && !el.hasAttribute('data-livue-replace-id')) {\n            el.setAttribute('data-livue-replace-id', state.id);\n        }\n    },\n\n    beforeUpdate(el, binding) {\n        // Increment version before update to force recreation\n        let state = replaceState.get(el);\n        if (state) {\n            state.version++;\n            replaceVersions.set(state.id, state.version);\n\n            // Update the element's key attribute to force recreation\n            // This works with Vue's :key binding\n            el.setAttribute('data-livue-replace-version', state.version);\n        }\n    },\n\n    unmounted(el) {\n        let state = replaceState.get(el);\n        if (state) {\n            replaceVersions.delete(state.id);\n        }\n        replaceState.delete(el);\n    },\n};\n\n/**\n * Process a template to inject dynamic keys for v-replace elements.\n * Called by the template processor before Vue renders.\n *\n * @param {string} template - The template HTML\n * @returns {string} - Processed template with injected keys\n */\nexport function processReplaceElements(template) {\n    // Find all elements with data-livue-replace-id and inject :key bindings\n    // This is a simple regex-based approach; a full parser could be more robust\n\n    return template.replace(\n        /(<[^>]*)\\s+data-livue-replace-id=\"([^\"]+)\"([^>]*>)/g,\n        function (match, before, replaceId, after) {\n            let version = getReplaceVersion(replaceId);\n\n            // Check if :key already exists\n            if (before.includes(':key=') || after.includes(':key=')) {\n                // Don't override existing key\n                return match;\n            }\n\n            // Inject :key with the replace ID and version\n            let key = replaceId + '-' + version;\n            return before + ' data-livue-replace-id=\"' + replaceId + '\" :key=\"' + \"'\" + key + \"'\" + '\"' + after;\n        }\n    );\n}\n","/**\n * v-loading Directive\n *\n * Shows/hides elements or modifies attributes based on loading state.\n * Reactive loading indicators for server actions.\n *\n * Usage:\n *   <div v-loading>Loading...</div>                    -- Show when any action loading\n *   <div v-loading=\"'save'\">Saving...</div>            -- Show when 'save' is loading\n *   <div v-loading.remove>Content</div>                -- Remove when loading\n *   <div v-loading.class=\"'opacity-50'\">...</div>      -- Add class when loading\n *   <div v-loading.attr=\"'disabled'\">...</div>         -- Add attribute when loading\n *   <div v-loading.delay>...</div>                     -- 200ms delay (default)\n *   <div v-loading.delay.shortest>...</div>            -- 50ms delay\n *   <div v-loading.delay.short>...</div>               -- 150ms delay\n *   <div v-loading.delay.long>...</div>                -- 1000ms delay\n *   <div v-loading.delay.longest>...</div>             -- 2000ms delay\n *\n * Modifiers can be combined:\n *   <div v-loading.class.delay.short=\"'opacity-50'\">...</div>\n */\n\nimport { watch } from 'vue';\n\n/**\n * WeakMap to store loading state for cleanup.\n * @type {WeakMap<HTMLElement, object>}\n */\nconst loadingState = new WeakMap();\n\n/**\n * Delay presets in milliseconds.\n */\nconst DELAY_PRESETS = {\n    shortest: 50,\n    short: 150,\n    long: 1000,\n    longest: 2000,\n};\n\n/**\n * Default delay when .delay modifier is used without preset.\n */\nconst DEFAULT_DELAY = 200;\n\n/**\n * Parse delay from modifiers.\n *\n * @param {object} modifiers - Binding modifiers\n * @returns {number} - Delay in milliseconds (0 if no delay)\n */\nfunction parseDelay(modifiers) {\n    if (!modifiers.delay) {\n        return 0;\n    }\n\n    for (let key of Object.keys(DELAY_PRESETS)) {\n        if (modifiers[key]) {\n            return DELAY_PRESETS[key];\n        }\n    }\n\n    return DEFAULT_DELAY;\n}\n\n/**\n * Get the livue helper from a vnode context.\n *\n * @param {object} vnode - Vue vnode\n * @returns {object|null} - livue helper or null\n */\nfunction getLivueFromVnode(vnode) {\n    let ctx = vnode.ctx;\n\n    if (ctx && ctx.setupState && ctx.setupState.livue) {\n        return ctx.setupState.livue;\n    }\n\n    if (ctx && ctx.parent && ctx.parent.setupState && ctx.parent.setupState.livue) {\n        return ctx.parent.setupState.livue;\n    }\n\n    let parent = ctx ? ctx.parent : null;\n    while (parent) {\n        if (parent.setupState && parent.setupState.livue) {\n            return parent.setupState.livue;\n        }\n        parent = parent.parent;\n    }\n\n    return null;\n}\n\n/**\n * Apply loading state to element.\n *\n * @param {HTMLElement} el - Target element\n * @param {object} state - Stored state\n * @param {object} modifiers - Directive modifiers\n * @param {*} value - Directive value (class name, attribute, or action name)\n * @param {boolean} isLoading - Whether loading is active\n */\nfunction applyLoadingState(el, state, modifiers, value, isLoading) {\n    // Handle .remove modifier (inverse logic)\n    if (modifiers.remove) {\n        if (isLoading) {\n            el.style.display = 'none';\n        } else {\n            el.style.display = state.originalDisplay;\n        }\n        return;\n    }\n\n    // Handle .class modifier\n    if (modifiers.class) {\n        let classes = (value || '').split(' ').filter(Boolean);\n        if (isLoading) {\n            classes.forEach(function (cls) {\n                if (!state.addedClasses.includes(cls)) {\n                    el.classList.add(cls);\n                    state.addedClasses.push(cls);\n                }\n            });\n        } else {\n            state.addedClasses.forEach(function (cls) {\n                el.classList.remove(cls);\n            });\n            state.addedClasses = [];\n        }\n        return;\n    }\n\n    // Handle .attr modifier\n    if (modifiers.attr) {\n        let attrName = value || 'disabled';\n        if (isLoading) {\n            el.setAttribute(attrName, '');\n            state.addedAttr = attrName;\n        } else if (state.addedAttr) {\n            el.removeAttribute(state.addedAttr);\n            state.addedAttr = null;\n        }\n        return;\n    }\n\n    // Default: show/hide element\n    if (isLoading) {\n        el.style.display = state.originalDisplay || '';\n    } else {\n        el.style.display = 'none';\n    }\n}\n\nexport default {\n    created(el, binding) {\n        // Store initial state\n        let display = el.style.display;\n        loadingState.set(el, {\n            originalDisplay: display === 'none' ? '' : display,\n            addedClasses: [],\n            addedAttr: null,\n            delayTimer: null,\n            stopWatch: null,\n            isActive: false,\n        });\n\n        // For default show/hide (not .remove), hide initially\n        let modifiers = binding.modifiers || {};\n        if (!modifiers.remove && !modifiers.class && !modifiers.attr) {\n            el.style.display = 'none';\n        }\n    },\n\n    mounted(el, binding, vnode) {\n        let livue = getLivueFromVnode(vnode);\n\n        if (!livue) {\n            console.warn('[LiVue] v-loading: livue helper not found in component context');\n            return;\n        }\n\n        let state = loadingState.get(el);\n        let modifiers = binding.modifiers || {};\n        let delay = parseDelay(modifiers);\n\n        // Determine what to watch: specific action or any loading\n        let value = binding.value;\n        let action = null;\n        let classOrAttr = null;\n\n        // Parse value based on modifier\n        if (modifiers.class || modifiers.attr) {\n            classOrAttr = value;\n        } else if (typeof value === 'string') {\n            action = value;\n        }\n\n        /**\n         * Update element based on loading state.\n         * @param {boolean} isLoading\n         */\n        function updateElement(isLoading) {\n            // Clear any pending delay timer\n            if (state.delayTimer) {\n                clearTimeout(state.delayTimer);\n                state.delayTimer = null;\n            }\n\n            if (isLoading && delay > 0) {\n                // Delay showing loading state\n                state.delayTimer = setTimeout(function () {\n                    state.isActive = true;\n                    applyLoadingState(el, state, modifiers, classOrAttr, true);\n                }, delay);\n            } else if (isLoading) {\n                state.isActive = true;\n                applyLoadingState(el, state, modifiers, classOrAttr, true);\n            } else {\n                state.isActive = false;\n                applyLoadingState(el, state, modifiers, classOrAttr, false);\n            }\n        }\n\n        // Set up reactive watcher\n        state.stopWatch = watch(\n            function () {\n                return action ? livue.isLoading(action) : livue.loading;\n            },\n            updateElement,\n            { immediate: true }\n        );\n    },\n\n    updated(el, binding, vnode) {\n        // Handle dynamic value changes if needed\n        let state = loadingState.get(el);\n        if (!state) return;\n\n        // Value might have changed, but we keep the same watcher\n        // since it watches the same loading state\n    },\n\n    unmounted(el) {\n        let state = loadingState.get(el);\n\n        if (state) {\n            // Clear delay timer\n            if (state.delayTimer) {\n                clearTimeout(state.delayTimer);\n            }\n\n            // Stop reactive watcher\n            if (state.stopWatch) {\n                state.stopWatch();\n            }\n\n            loadingState.delete(el);\n        }\n    },\n};\n","/**\n * v-target Directive\n *\n * Auto-injects data-loading attribute on trigger elements when a specific\n * action is loading. Useful for Tailwind's data-[loading]: variant.\n *\n * Usage:\n *   <button @click=\"livue.call('save')\" v-target=\"'save'\">\n *       Save\n *   </button>\n *   <!-- Adds data-loading attribute when livue.isLoading('save') is true -->\n *\n *   With Tailwind:\n *   <button v-target=\"'save'\" class=\"data-[loading]:opacity-50 data-[loading]:cursor-wait\">\n *       Save\n *   </button>\n */\n\nimport { watch } from 'vue';\n\n/**\n * WeakMap to store target state for cleanup.\n * @type {WeakMap<HTMLElement, object>}\n */\nconst targetState = new WeakMap();\n\n/**\n * Get the livue helper from a vnode context.\n *\n * @param {object} vnode - Vue vnode\n * @returns {object|null} - livue helper or null\n */\nfunction getLivueFromVnode(vnode) {\n    let ctx = vnode.ctx;\n\n    if (ctx && ctx.setupState && ctx.setupState.livue) {\n        return ctx.setupState.livue;\n    }\n\n    if (ctx && ctx.parent && ctx.parent.setupState && ctx.parent.setupState.livue) {\n        return ctx.parent.setupState.livue;\n    }\n\n    let parent = ctx ? ctx.parent : null;\n    while (parent) {\n        if (parent.setupState && parent.setupState.livue) {\n            return parent.setupState.livue;\n        }\n        parent = parent.parent;\n    }\n\n    return null;\n}\n\nexport default {\n    mounted(el, binding, vnode) {\n        let livue = getLivueFromVnode(vnode);\n\n        if (!livue) {\n            console.warn('[LiVue] v-target: livue helper not found in component context');\n            return;\n        }\n\n        let action = binding.value;\n\n        if (!action) {\n            console.warn('[LiVue] v-target: action name is required');\n            return;\n        }\n\n        // Set up reactive watcher to toggle data-loading attribute\n        let stopWatch = watch(\n            function () {\n                return livue.isLoading(action);\n            },\n            function (isLoading) {\n                if (isLoading) {\n                    el.setAttribute('data-loading', '');\n                } else {\n                    el.removeAttribute('data-loading');\n                }\n            },\n            { immediate: true }\n        );\n\n        targetState.set(el, { stopWatch: stopWatch });\n    },\n\n    updated(el, binding, vnode) {\n        // Handle value changes (different action)\n        let state = targetState.get(el);\n        let livue = getLivueFromVnode(vnode);\n\n        if (!state || !livue) return;\n\n        let newAction = binding.value;\n        let oldAction = binding.oldValue;\n\n        if (newAction !== oldAction) {\n            // Stop old watcher and create new one\n            if (state.stopWatch) {\n                state.stopWatch();\n            }\n\n            state.stopWatch = watch(\n                function () {\n                    return livue.isLoading(newAction);\n                },\n                function (isLoading) {\n                    if (isLoading) {\n                        el.setAttribute('data-loading', '');\n                    } else {\n                        el.removeAttribute('data-loading');\n                    }\n                },\n                { immediate: true }\n            );\n        }\n    },\n\n    unmounted(el) {\n        let state = targetState.get(el);\n\n        if (state) {\n            if (state.stopWatch) {\n                state.stopWatch();\n            }\n            targetState.delete(el);\n        }\n    },\n};\n","/**\n * v-stream directive\n *\n * Marks an element as a streaming target. Content streamed from the server\n * via $this->stream(to: 'id', content: '...') will be applied to this element.\n *\n * Usage:\n *   <div v-stream=\"'output'\">Loading...</div>\n *   <div v-stream.replace=\"'status'\">Ready</div>\n *\n * Modifiers:\n *   .replace - Replace content instead of appending (default is append)\n *\n * The value should be a string (target ID) that matches the 'to' parameter\n * in the PHP $this->stream() call.\n */\n\nimport { registerStreamTarget, unregisterStreamTarget } from '../features/request/stream.js';\n\n/**\n * WeakMap to store element state for cleanup.\n * @type {WeakMap<HTMLElement, { targetId: string }>}\n */\nconst elementState = new WeakMap();\n\nexport default {\n    /**\n     * Called when directive is first bound to the element.\n     */\n    mounted(el, binding) {\n        // Get target ID from binding value\n        // Value can be a string directly or an expression that evaluates to string\n        const targetId = binding.value;\n\n        if (!targetId || typeof targetId !== 'string') {\n            console.warn('[v-stream] Target ID must be a non-empty string, got:', targetId);\n            return;\n        }\n\n        // Check for .replace modifier\n        const replace = binding.modifiers.replace || false;\n\n        // Store state for cleanup\n        elementState.set(el, { targetId });\n\n        // Register this element as a stream target\n        registerStreamTarget(targetId, el, replace);\n    },\n\n    /**\n     * Called when the binding value changes.\n     */\n    updated(el, binding) {\n        const oldState = elementState.get(el);\n        const newTargetId = binding.value;\n\n        if (!newTargetId || typeof newTargetId !== 'string') {\n            console.warn('[v-stream] Target ID must be a non-empty string, got:', newTargetId);\n            return;\n        }\n\n        // If target ID changed, re-register\n        if (oldState && oldState.targetId !== newTargetId) {\n            unregisterStreamTarget(oldState.targetId);\n\n            const replace = binding.modifiers.replace || false;\n            registerStreamTarget(newTargetId, el, replace);\n\n            elementState.set(el, { targetId: newTargetId });\n        }\n    },\n\n    /**\n     * Called when directive is unbound from the element.\n     */\n    unmounted(el) {\n        const state = elementState.get(el);\n\n        if (state) {\n            unregisterStreamTarget(state.targetId);\n            elementState.delete(el);\n        }\n    },\n};\n","/**\n * v-click directive for LiVue.\n *\n * Provides a cleaner syntax for calling server methods on click events.\n * Cleaner alternative to @click=\"livue.call('method')\".\n *\n * Usage:\n *   <button v-click:increment>+1</button>\n *   <button v-click:save=\"item.id\">Save</button>\n *   <button v-click:update=\"[item.id, 'active']\">Update</button>\n *\n * With modifiers:\n *   <button v-click:submit.prevent>Submit</button>\n *   <a v-click:navigate.prevent.stop=\"'/dashboard'\">Go</a>\n *   <button v-click:save.debounce.500ms>Save</button>\n *   <button v-click:track.throttle.1000ms>Track</button>\n *   <div v-click:close.outside>Modal</div>\n *   <button v-click:init.once>Initialize</button>\n *   <div v-click:handleOverlay.self>Overlay</div>\n *\n * Alternative syntax (method name as value):\n *   <button v-click=\"'increment'\">+1</button>\n */\n\nimport { getDebounced, getThrottled } from '../helpers/modifiers.js';\n\n/**\n * WeakMap to store event handlers for cleanup.\n * @type {WeakMap<HTMLElement, object>}\n */\nconst handlers = new WeakMap();\n\n/**\n * Counter for unique IDs (debounce/throttle cache keys).\n */\nlet _counter = 0;\n\n/**\n * Parse timing value from modifiers (e.g., { '500ms': true } -> 500).\n *\n * @param {object} modifiers\n * @param {number} defaultMs - Default value if no timing specified\n * @returns {number}\n */\nfunction parseTimingMs(modifiers, defaultMs = 250) {\n    for (let mod in modifiers) {\n        let match = mod.match(/^(\\d+)(ms)?$/);\n        if (match) {\n            return parseInt(match[1], 10);\n        }\n    }\n    return defaultMs;\n}\n\n/**\n * Get the livue helper from a vnode context.\n *\n * @param {object} vnode - Vue vnode\n * @returns {object|null} - livue helper or null\n */\nfunction getLivueFromVnode(vnode) {\n    let ctx = vnode.ctx;\n\n    if (ctx && ctx.setupState && ctx.setupState.livue) {\n        return ctx.setupState.livue;\n    }\n\n    if (ctx && ctx.parent && ctx.parent.setupState && ctx.parent.setupState.livue) {\n        return ctx.parent.setupState.livue;\n    }\n\n    let parent = ctx ? ctx.parent : null;\n    while (parent) {\n        if (parent.setupState && parent.setupState.livue) {\n            return parent.setupState.livue;\n        }\n        parent = parent.parent;\n    }\n\n    return null;\n}\n\nexport default {\n    mounted(el, binding, vnode) {\n        const { arg, modifiers } = binding;\n\n        const livue = getLivueFromVnode(vnode);\n\n        if (!livue) {\n            console.warn('[LiVue] v-click: livue helper not found in component context');\n            return;\n        }\n\n        // Generate unique ID for debounce/throttle caching\n        _counter++;\n        const uniqueId = 'v-click-' + _counter;\n\n        // Parse timing for debounce/throttle\n        const timingMs = parseTimingMs(modifiers);\n\n        // Get debounced/throttled executors if needed\n        let debounced = null;\n        let throttled = null;\n\n        if (modifiers.debounce) {\n            debounced = getDebounced(uniqueId, timingMs);\n        }\n        if (modifiers.throttle) {\n            throttled = getThrottled(uniqueId, timingMs);\n        }\n\n        // Track if .once has fired\n        let onceFired = false;\n\n        // Determine method name at mount time (for static values)\n        let staticMethod = null;\n        if (arg) {\n            staticMethod = arg;\n        }\n\n        /**\n         * Core handler logic - extracted for reuse with .outside\n         */\n        const executeCall = function(event) {\n            let methodName = staticMethod;\n            let args = [];\n\n            if (arg) {\n                // v-click:methodName=\"args\"\n                methodName = arg;\n                const currentValue = binding.value;\n                if (currentValue !== undefined && currentValue !== null) {\n                    args = Array.isArray(currentValue) ? currentValue : [currentValue];\n                }\n            } else {\n                // v-click=\"'methodName'\" or v-click=\"methodName\"\n                const currentValue = binding.value;\n                if (typeof currentValue === 'string') {\n                    methodName = currentValue;\n                } else if (Array.isArray(currentValue) && currentValue.length > 0) {\n                    methodName = currentValue[0];\n                    args = currentValue.slice(1);\n                }\n            }\n\n            if (!methodName) {\n                console.warn('[LiVue] v-click: no method specified');\n                return;\n            }\n\n            // Execute call (with debounce/throttle if applicable)\n            const doCall = function() {\n                livue.call(methodName, ...args);\n            };\n\n            if (debounced) {\n                debounced(doCall);\n            } else if (throttled) {\n                throttled(doCall);\n            } else {\n                doCall();\n            }\n        };\n\n        /**\n         * Main click handler\n         */\n        const handler = function(event) {\n            // .self - only if event originated from this element\n            if (modifiers.self && event.target !== el) {\n                return;\n            }\n\n            // .once - only fire once\n            if (modifiers.once) {\n                if (onceFired) {\n                    return;\n                }\n                onceFired = true;\n            }\n\n            // Event modifiers\n            if (modifiers.prevent) {\n                event.preventDefault();\n            }\n            if (modifiers.stop) {\n                event.stopPropagation();\n            }\n\n            executeCall(event);\n        };\n\n        // Build addEventListener options\n        const listenerOptions = {};\n        if (modifiers.capture) {\n            listenerOptions.capture = true;\n        }\n        if (modifiers.passive) {\n            listenerOptions.passive = true;\n        }\n\n        // Store info for cleanup\n        const handlerInfo = {\n            handler: handler,\n            options: listenerOptions,\n            outsideHandler: null,\n        };\n\n        // .outside - listen on document for clicks outside the element\n        if (modifiers.outside) {\n            const outsideHandler = function(event) {\n                // Check if click was outside the element\n                if (!el.contains(event.target) && event.target !== el) {\n                    // .once support for outside clicks too\n                    if (modifiers.once) {\n                        if (onceFired) {\n                            return;\n                        }\n                        onceFired = true;\n                    }\n\n                    executeCall(event);\n                }\n            };\n\n            document.addEventListener('click', outsideHandler, listenerOptions);\n            handlerInfo.outsideHandler = outsideHandler;\n        } else {\n            // Normal click on element\n            el.addEventListener('click', handler, listenerOptions);\n        }\n\n        handlers.set(el, handlerInfo);\n    },\n\n    updated(el, binding, vnode) {\n        // For dynamic arg changes, we'd need to rebind\n        // But typically the arg (method name) is static\n    },\n\n    unmounted(el) {\n        const handlerInfo = handlers.get(el);\n        if (handlerInfo) {\n            if (handlerInfo.outsideHandler) {\n                document.removeEventListener('click', handlerInfo.outsideHandler, handlerInfo.options);\n            } else {\n                el.removeEventListener('click', handlerInfo.handler, handlerInfo.options);\n            }\n            handlers.delete(el);\n        }\n    }\n};\n","/**\n * v-navigate Directive\n *\n * Transforms links into SPA navigation links with optional prefetching.\n *\n * Usage:\n *   <a href=\"/dashboard\" v-navigate>Dashboard</a>\n *   <a href=\"/posts\" v-navigate.hover>Posts</a>\n *   <a href=\"/posts\" v-navigate.prefetch>Posts</a> (same as .hover)\n *\n * Modifiers:\n *   (default) - Prefetch on mousedown (between mousedown and mouseup)\n *   .hover    - Prefetch on hover after 60ms delay\n *   .prefetch - Alias for .hover\n *\n * This directive marks links for SPA navigation by setting data attributes.\n * The actual click handling is done by a global event listener in navigation.js\n * using event delegation (more robust when elements are moved/preserved in DOM).\n */\n\nexport default {\n    mounted(el, binding) {\n        // Validate element type\n        if (el.tagName !== 'A') {\n            console.warn('[LiVue] v-navigate should only be used on <a> elements');\n            return;\n        }\n\n        var modifiers = binding.modifiers || {};\n\n        // Set data attributes for the navigation system (global click handler)\n        el.setAttribute('data-livue-navigate', 'true');\n\n        // Set prefetch mode\n        if (modifiers.hover || modifiers.prefetch) {\n            el.setAttribute('data-livue-navigate-mode', 'hover');\n        }\n\n        // Note: Click handling is done by the global handler in navigation.js\n        // This ensures clicks work even when elements are moved in the DOM\n        // (e.g., during @persist operations)\n    },\n\n    unmounted(el) {\n        el.removeAttribute('data-livue-navigate');\n        el.removeAttribute('data-livue-navigate-mode');\n    },\n};\n","/**\n * v-scroll Directive\n *\n * Marks an element for scroll position preservation during SPA navigation.\n * When navigating back/forward, the scroll position of marked elements\n * is saved and restored automatically.\n *\n * Usage:\n *   <aside v-scroll>...</aside>\n *   <aside v-scroll=\"'sidebar'\">...</aside>\n *   <div v-scroll=\"'main-content'\" class=\"overflow-y-auto\">...</div>\n *\n * The directive sets `data-livue-scroll` which the navigation module uses\n * to save/restore scroll positions.\n *\n * When a value is provided, it's used as the scroll identifier.\n * When no value is provided, a unique ID is auto-generated.\n */\n\nlet _scrollCounter = 0;\n\nexport default {\n    created(el, binding) {\n        // Determine the scroll key\n        let key = binding.value;\n\n        if (!key) {\n            // Auto-generate a unique key\n            _scrollCounter++;\n            key = 'scroll-' + _scrollCounter;\n        }\n\n        // Set the data attribute that the navigation module looks for\n        el.setAttribute('data-livue-scroll', key);\n\n        // Store for reference\n        el.__livue_scroll_key = key;\n    },\n\n    updated(el, binding) {\n        // Update key if it changed\n        let key = binding.value;\n\n        if (key && key !== el.__livue_scroll_key) {\n            el.setAttribute('data-livue-scroll', key);\n            el.__livue_scroll_key = key;\n        }\n    },\n\n    unmounted(el) {\n        // Cleanup\n        el.removeAttribute('data-livue-scroll');\n        delete el.__livue_scroll_key;\n    },\n};\n","/**\n * v-dirty Directive\n *\n * Shows/hides elements or modifies attributes based on dirty tracking state.\n * Reacts to client-side state changes compared to server-confirmed state.\n *\n * Usage:\n *   <div v-dirty>Modified!</div>                            -- Show when any property is dirty\n *   <div v-dirty:email>Email changed</div>                  -- Show when 'email' is dirty\n *   <div v-dirty.class=\"'border-yellow-500'\">...</div>      -- Add class when any dirty\n *   <div v-dirty:email.class=\"'border-yellow-500'\">...</div> -- Add class when 'email' dirty\n *   <div v-dirty.class.remove=\"'border-gray-300'\">...</div> -- Remove class when dirty\n *   <div v-dirty.attr=\"'data-modified'\">...</div>           -- Add attribute when dirty\n *\n * Modifiers:\n *   (default)     - Toggle visibility (hidden when clean, shown when dirty)\n *   .class        - Add the specified class(es) when dirty\n *   .class.remove - Remove the specified class(es) when dirty\n *   .attr         - Add the specified attribute when dirty\n */\n\nimport { watch } from 'vue';\n\n/**\n * WeakMap to store dirty directive state for cleanup.\n * @type {WeakMap<HTMLElement, object>}\n */\nconst dirtyState = new WeakMap();\n\n/**\n * Get the livue helper from a vnode context.\n *\n * @param {object} vnode - Vue vnode\n * @returns {object|null} - livue helper or null\n */\nfunction getLivueFromVnode(vnode) {\n    let ctx = vnode.ctx;\n\n    if (ctx && ctx.setupState && ctx.setupState.livue) {\n        return ctx.setupState.livue;\n    }\n\n    if (ctx && ctx.parent && ctx.parent.setupState && ctx.parent.setupState.livue) {\n        return ctx.parent.setupState.livue;\n    }\n\n    let parent = ctx ? ctx.parent : null;\n    while (parent) {\n        if (parent.setupState && parent.setupState.livue) {\n            return parent.setupState.livue;\n        }\n        parent = parent.parent;\n    }\n\n    return null;\n}\n\n/**\n * Apply dirty state to element.\n *\n * @param {HTMLElement} el - Target element\n * @param {object} state - Stored state\n * @param {object} modifiers - Directive modifiers\n * @param {*} value - Directive value (class name or attribute name)\n * @param {boolean} isDirty - Whether the target is dirty\n */\nfunction applyDirtyState(el, state, modifiers, value, isDirty) {\n    // Handle .class modifier\n    if (modifiers.class) {\n        if (!value) {\n            return;\n        }\n\n        let classes = value.trim().split(/\\s+/);\n\n        if (modifiers.remove) {\n            // .class.remove - Remove classes when dirty, restore when clean\n            if (isDirty) {\n                classes.forEach(function (cls) {\n                    el.classList.remove(cls);\n                });\n            } else {\n                classes.forEach(function (cls) {\n                    el.classList.add(cls);\n                });\n            }\n        } else {\n            // .class - Add classes when dirty, remove when clean\n            if (isDirty) {\n                classes.forEach(function (cls) {\n                    if (!state.addedClasses.includes(cls)) {\n                        el.classList.add(cls);\n                        state.addedClasses.push(cls);\n                    }\n                });\n            } else {\n                state.addedClasses.forEach(function (cls) {\n                    el.classList.remove(cls);\n                });\n                state.addedClasses = [];\n            }\n        }\n        return;\n    }\n\n    // Handle .attr modifier\n    if (modifiers.attr) {\n        let attrName = value || 'data-dirty';\n        if (isDirty) {\n            el.setAttribute(attrName, '');\n            state.addedAttr = attrName;\n        } else if (state.addedAttr) {\n            el.removeAttribute(state.addedAttr);\n            state.addedAttr = null;\n        }\n        return;\n    }\n\n    // Default: show/hide element (hidden when clean, shown when dirty)\n    if (isDirty) {\n        el.style.display = state.originalDisplay || '';\n    } else {\n        el.style.display = 'none';\n    }\n}\n\nexport default {\n    created(el, binding) {\n        let display = el.style.display;\n        dirtyState.set(el, {\n            originalDisplay: display === 'none' ? '' : display,\n            addedClasses: [],\n            addedAttr: null,\n            stopWatch: null,\n        });\n\n        // For default show/hide mode, hide initially (clean state)\n        let modifiers = binding.modifiers || {};\n        if (!modifiers.class && !modifiers.attr) {\n            el.style.display = 'none';\n        }\n    },\n\n    mounted(el, binding, vnode) {\n        let livue = getLivueFromVnode(vnode);\n\n        if (!livue) {\n            console.warn('[LiVue] v-dirty: livue helper not found in component context');\n            return;\n        }\n\n        let state = dirtyState.get(el);\n        let modifiers = binding.modifiers || {};\n        let property = binding.arg || null;\n        let value = binding.value;\n\n        // Set up reactive watcher on dirty state\n        state.stopWatch = watch(\n            function () {\n                return property ? livue.isDirty(property) : livue.isDirty();\n            },\n            function (isDirty) {\n                applyDirtyState(el, state, modifiers, value, isDirty);\n            },\n            { immediate: true }\n        );\n    },\n\n    updated(el, binding, vnode) {\n        let state = dirtyState.get(el);\n        if (!state) {\n            return;\n        }\n\n        // If value changed dynamically, re-apply current state\n        if (binding.value !== binding.oldValue) {\n            let livue = getLivueFromVnode(vnode);\n            if (livue) {\n                let property = binding.arg || null;\n                let isDirty = property ? livue.isDirty(property) : livue.isDirty();\n                applyDirtyState(el, state, binding.modifiers || {}, binding.value, isDirty);\n            }\n        }\n    },\n\n    unmounted(el) {\n        let state = dirtyState.get(el);\n\n        if (state) {\n            if (state.stopWatch) {\n                state.stopWatch();\n            }\n\n            dirtyState.delete(el);\n        }\n    },\n};\n","/**\n * v-watch Directive\n *\n * Syncs to the server when a field value changes.\n * Detects the bound property automatically from v-model on the element or children.\n *\n * Usage:\n *   <div v-watch>                  <!-- default 150ms debounce -->\n *   <div v-watch.debounce.300ms>   <!-- custom debounce -->\n *   <div v-watch.blur>             <!-- sync on blur only -->\n *\n * Modifiers:\n *   .debounce.Xms - Custom debounce (default: 150ms)\n *   .blur         - Sync only on blur (uses focusout event)\n */\n\nimport { watch } from 'vue';\nimport { getDebounced } from '../helpers/modifiers.js';\n\n/**\n * WeakMap to store binding info for cleanup.\n * @type {WeakMap<HTMLElement, object>}\n */\nconst _bindings = new WeakMap();\n\nlet _watchCounter = 0;\n\n/**\n * Parse timing value from modifiers (e.g., { '500ms': true } -> 500).\n *\n * @param {object} modifiers\n * @returns {number}\n */\nfunction parseTimingMs(modifiers) {\n    for (let mod in modifiers) {\n        let match = mod.match(/^(\\d+)(ms)?$/);\n        if (match) {\n            return parseInt(match[1], 10);\n        }\n    }\n    return 0;\n}\n\n/**\n * Get the livue helper and state from a binding context.\n *\n * @param {object} binding - Vue directive binding\n * @param {object} vnode - Vue vnode\n * @returns {object|null} - { livue, state } or null\n */\nfunction getContext(binding, vnode) {\n    let instance = binding.instance;\n\n    if (instance) {\n        let internal = instance.$ || instance._ || instance;\n\n        if (internal.setupState && internal.setupState.livue) {\n            return {\n                livue: internal.setupState.livue,\n                state: internal.setupState,\n            };\n        }\n\n        if (instance.livue) {\n            let setupState = internal.setupState || instance;\n            return {\n                livue: setupState.livue || instance.livue,\n                state: setupState,\n            };\n        }\n    }\n\n    let ctx = vnode.ctx;\n\n    if (ctx && ctx.setupState && ctx.setupState.livue) {\n        return {\n            livue: ctx.setupState.livue,\n            state: ctx.setupState,\n        };\n    }\n\n    if (ctx && ctx.parent && ctx.parent.setupState && ctx.parent.setupState.livue) {\n        return {\n            livue: ctx.parent.setupState.livue,\n            state: ctx.parent.setupState,\n        };\n    }\n\n    let parent = ctx ? ctx.parent : null;\n    while (parent) {\n        if (parent.setupState && parent.setupState.livue) {\n            return {\n                livue: parent.setupState.livue,\n                state: parent.setupState,\n            };\n        }\n        parent = parent.parent;\n    }\n\n    return null;\n}\n\n/**\n * Find the v-model path from the element or its children.\n * Looks for v-model attribute on the element itself, or on child\n * input/textarea/select elements.\n *\n * @param {HTMLElement} el\n * @returns {string|null}\n */\nfunction findModelPath(el) {\n    // Check for v-model on child elements (Vue compiles v-model to attributes)\n    let input = el.querySelector('[v-model], input, textarea, select');\n\n    // v-model is compiled away by Vue, but we can look for data attributes\n    // or the element's own dataset\n    if (el.dataset.watchPath) {\n        return el.dataset.watchPath;\n    }\n\n    return null;\n}\n\n/**\n * Resolve a dot-notation path from the reactive state.\n * Handles Vue refs (unwraps .value) for the root property.\n *\n * @param {object} state - Component setupState\n * @param {string} path - Dot-notation path (e.g., \"data.name\")\n * @returns {*} The resolved value\n */\nfunction resolvePath(state, path) {\n    let parts = path.split('.');\n    let current = state[parts[0]];\n\n    // Unwrap Vue ref\n    if (current && typeof current === 'object' && 'value' in current) {\n        current = current.value;\n    }\n\n    for (let i = 1; i < parts.length; i++) {\n        if (current == null) return undefined;\n        current = current[parts[i]];\n    }\n\n    return current;\n}\n\nexport default {\n    mounted(el, binding, vnode) {\n        let context = getContext(binding, vnode);\n\n        if (!context) {\n            console.warn('[LiVue] v-watch: Could not find livue context');\n            return;\n        }\n\n        // Path can come from: directive value, or data-watch-path attribute\n        let path = binding.value || el.dataset.watchPath;\n\n        if (!path) {\n            console.warn('[LiVue] v-watch: No path found. Use v-watch=\"\\'path\\'\" or data-watch-path=\"path\"');\n            return;\n        }\n\n        let { livue, state } = context;\n        let modifiers = binding.modifiers || {};\n\n        _watchCounter++;\n        let uniqueId = 'watch-' + path + '-' + _watchCounter;\n\n        // Blur mode: sync on focusout instead of watching\n        if (modifiers.blur) {\n            let blurHandler = function () {\n                livue.sync();\n            };\n\n            el.addEventListener('focusout', blurHandler);\n\n            _bindings.set(el, { blurHandler: blurHandler });\n            return;\n        }\n\n        // Debounce mode (default)\n        let debounceMs = parseTimingMs(modifiers) || 150;\n        let debounced = getDebounced(uniqueId, debounceMs);\n\n        let stopWatcher = watch(\n            function () {\n                return resolvePath(state, path);\n            },\n            function () {\n                debounced(function () {\n                    return livue.sync();\n                });\n            }\n        );\n\n        _bindings.set(el, { stopWatcher: stopWatcher });\n    },\n\n    unmounted(el) {\n        let info = _bindings.get(el);\n\n        if (info) {\n            if (info.stopWatcher) {\n                info.stopWatcher();\n            }\n            if (info.blurHandler) {\n                el.removeEventListener('focusout', info.blurHandler);\n            }\n            _bindings.delete(el);\n        }\n    },\n};\n","/**\n * v-model Modifier Directives\n *\n * Separate directives that work alongside Vue's native v-model\n * to add timing and type modifiers.\n *\n * Usage:\n *   <input v-model=\"search\" v-debounce:search.500ms>\n *   <input v-model=\"query\" v-throttle:query.300ms>\n *   <input v-model=\"name\" v-blur:name>\n *   <input v-model=\"term\" v-enter:term>\n *   <input v-model=\"active\" v-boolean:active>\n *\n * These directives:\n * 1. Require v-model to be present (throw error if missing)\n * 2. Intercept input events in capture phase\n * 3. Block v-model's handler via stopImmediatePropagation\n * 4. Apply the modifier behavior before updating state\n */\n\nimport { getDebounced, getThrottled } from '../helpers/modifiers.js';\n\n/**\n * WeakMap to store directive state for cleanup.\n * @type {WeakMap<HTMLElement, object>}\n */\nconst _bindings = new WeakMap();\n\n/**\n * Counter for unique IDs.\n */\nlet _counter = 0;\n\n/**\n * Check if the vnode is a native form input element.\n * We only want to enforce v-model check on actual form elements,\n * not on Vue component wrappers (which render as divs, spans, etc.)\n *\n * @param {object} vnode\n * @returns {boolean}\n */\nfunction isNativeFormElement(vnode) {\n    let type = vnode.type;\n    return type === 'input' || type === 'textarea' || type === 'select';\n}\n\n/**\n * Check if element has v-model bound (only reliable for native elements).\n * Vue compiles v-model to onInput (native) or onUpdate:modelValue (component).\n *\n * For Vue components, the directive receives the rendered root element,\n * not the component vnode, so we can't reliably check for v-model.\n *\n * @param {object} vnode\n * @returns {boolean}\n */\nfunction hasVModel(vnode) {\n    if (!vnode.props) {\n        return false;\n    }\n    // Native elements use onInput or onUpdate:modelValue\n    return !!(vnode.props.onInput || vnode.props['onUpdate:modelValue']);\n}\n\n/**\n * Get the component context and state from binding or vnode.\n * Uses binding.instance first (the component that owns the template),\n * then falls back to vnode.ctx traversal.\n *\n * @param {object} binding - Vue directive binding\n * @param {object} vnode - Vue vnode\n * @returns {object|null} - { state } or null\n */\nfunction getContextFromBinding(binding, vnode) {\n    // Try binding.instance first - this is the component that owns the template\n    let instance = binding.instance;\n\n    if (instance) {\n        // In Vue 3, instance.$ gives access to the internal component instance\n        let internal = instance.$ || instance._ || instance;\n\n        if (internal.setupState && internal.setupState.livue) {\n            return { state: internal.setupState };\n        }\n\n        // Check if instance itself has the properties (proxy)\n        if (instance.livue) {\n            // Need to get the actual setupState for refs\n            let setupState = internal.setupState || instance;\n            return { state: setupState };\n        }\n    }\n\n    // Fallback to vnode.ctx traversal\n    let ctx = vnode.ctx;\n\n    if (ctx && ctx.setupState && ctx.setupState.livue) {\n        return { state: ctx.setupState };\n    }\n\n    if (ctx && ctx.parent && ctx.parent.setupState && ctx.parent.setupState.livue) {\n        return { state: ctx.parent.setupState };\n    }\n\n    let parent = ctx ? ctx.parent : null;\n    while (parent) {\n        if (parent.setupState && parent.setupState.livue) {\n            return { state: parent.setupState };\n        }\n        parent = parent.parent;\n    }\n\n    return null;\n}\n\n/**\n * Get value from input element.\n *\n * @param {HTMLElement} el\n * @returns {*}\n */\nfunction getInputValue(el) {\n    if (el.type === 'checkbox') {\n        return el.checked;\n    }\n    if (el.type === 'radio') {\n        return el.checked ? el.value : null;\n    }\n    if (el.tagName === 'SELECT' && el.multiple) {\n        return Array.from(el.selectedOptions).map(function (opt) {\n            return opt.value;\n        });\n    }\n    return el.value;\n}\n\n/**\n * Update state property (handles Vue refs).\n *\n * @param {object} state\n * @param {string} property\n * @param {*} value\n */\nfunction updateState(state, property, value) {\n    let prop = state[property];\n    if (prop && typeof prop === 'object' && 'value' in prop) {\n        prop.value = value;\n    } else {\n        state[property] = value;\n    }\n}\n\n/**\n * Parse timing value from modifiers (e.g., { '500ms': true } -> 500).\n *\n * @param {object} modifiers\n * @returns {number}\n */\nfunction parseTimingMs(modifiers) {\n    for (let mod in modifiers) {\n        let match = mod.match(/^(\\d+)(ms)?$/);\n        if (match) {\n            return parseInt(match[1], 10);\n        }\n    }\n    return 0;\n}\n\n/**\n * Find the actual property name in state, handling case differences.\n * Vue lowercases directive arguments, so we need to find the matching property.\n *\n * @param {object} state - The state object\n * @param {string} arg - The directive argument (lowercased by Vue)\n * @returns {string|null} - The actual property name or null if not found\n */\nfunction findPropertyName(state, arg) {\n    // Direct match first\n    if (arg in state) {\n        return arg;\n    }\n\n    // Case-insensitive search\n    let lowerArg = arg.toLowerCase();\n    for (let key in state) {\n        if (key.toLowerCase() === lowerArg) {\n            return key;\n        }\n    }\n\n    return null;\n}\n\n/**\n * Check if element is a native form element or a Vue component wrapper.\n *\n * @param {HTMLElement} el\n * @returns {boolean}\n */\nfunction isNativeInput(el) {\n    let tagName = el.tagName.toLowerCase();\n    return tagName === 'input' || tagName === 'textarea' || tagName === 'select';\n}\n\n/**\n * Find the actual input element to attach listeners to.\n * For native inputs, returns the element itself.\n * For Vue component wrappers (like Vuetify), finds the internal input.\n *\n * @param {HTMLElement} el\n * @returns {HTMLInputElement|HTMLTextAreaElement|HTMLSelectElement|null}\n */\nfunction findTargetInput(el) {\n    if (isNativeInput(el)) {\n        return el;\n    }\n    // For Vue components, look for internal input/textarea/select\n    return el.querySelector('input, textarea, select');\n}\n\n/**\n * Create a directive that modifies v-model behavior.\n *\n * @param {string} name - Directive name for error messages\n * @param {Function} createHandler - Factory function: (el, property, state, modifiers, uniqueId) => { handler, eventType, options }\n * @returns {object} Vue directive definition\n */\nfunction createModelModifierDirective(name, createHandler) {\n    return {\n        mounted(el, binding, vnode) {\n            // Check for v-model only on native form elements (input, textarea, select)\n            // For Vue components (which render as divs, etc.), we can't reliably detect v-model\n            if (isNativeFormElement(vnode) && !hasVModel(vnode)) {\n                throw new Error('[LiVue] v-' + name + ' requires v-model on the element. Usage: <input v-model=\"prop\" v-' + name + ':prop>');\n            }\n\n            let argName = binding.arg;\n            if (!argName) {\n                throw new Error('[LiVue] v-' + name + ' requires property name as argument. Usage: v-' + name + ':propertyName');\n            }\n\n            let context = getContextFromBinding(binding, vnode);\n            if (!context) {\n                throw new Error('[LiVue] v-' + name + ': Could not find component context');\n            }\n\n            let { state } = context;\n\n            // Find actual property name (Vue lowercases directive arguments)\n            let property = findPropertyName(state, argName);\n            if (!property) {\n                throw new Error('[LiVue] v-' + name + ': Property \"' + argName + '\" not found in component state');\n            }\n            let modifiers = binding.modifiers || {};\n\n            _counter++;\n            let uniqueId = name + '-' + _counter;\n\n            // Find the actual input element (might be nested in a Vue component)\n            let targetEl = findTargetInput(el);\n\n            if (!targetEl) {\n                console.warn('[LiVue] v-' + name + ': Could not find input element inside component');\n                return;\n            }\n\n            // Create the handler configuration\n            let config = createHandler(targetEl, property, state, modifiers, uniqueId);\n\n            // Add event listener in capture phase to intercept before v-model/component handlers\n            targetEl.addEventListener(config.eventType, config.handler, { capture: true });\n\n            // Store for cleanup (use original el as key, but store targetEl)\n            _bindings.set(el, {\n                targetEl: targetEl,\n                handler: config.handler,\n                eventType: config.eventType,\n            });\n        },\n\n        unmounted(el) {\n            let info = _bindings.get(el);\n            if (info) {\n                info.targetEl.removeEventListener(info.eventType, info.handler, { capture: true });\n                _bindings.delete(el);\n            }\n        },\n    };\n}\n\n/**\n * v-debounce directive\n * Debounces v-model updates.\n *\n * Usage: <input v-model=\"search\" v-debounce:search.500ms>\n */\nexport const debounceDirective = createModelModifierDirective('debounce', function (el, property, state, modifiers, uniqueId) {\n    let ms = parseTimingMs(modifiers) || 150;\n    let debounced = getDebounced(uniqueId, ms);\n\n    return {\n        eventType: 'input',\n        handler: function (e) {\n            // Stop v-model from handling this event\n            e.stopImmediatePropagation();\n\n            let value = getInputValue(e.target);\n            debounced(function () {\n                updateState(state, property, value);\n            });\n        },\n    };\n});\n\n/**\n * v-throttle directive\n * Throttles v-model updates.\n *\n * Usage: <input v-model=\"query\" v-throttle:query.300ms>\n */\nexport const throttleDirective = createModelModifierDirective('throttle', function (el, property, state, modifiers, uniqueId) {\n    let ms = parseTimingMs(modifiers) || 150;\n    let throttled = getThrottled(uniqueId, ms);\n\n    return {\n        eventType: 'input',\n        handler: function (e) {\n            e.stopImmediatePropagation();\n\n            let value = getInputValue(e.target);\n            throttled(function () {\n                updateState(state, property, value);\n            });\n        },\n    };\n});\n\n/**\n * v-blur directive\n * Updates v-model only on blur event.\n *\n * Usage: <input v-model=\"name\" v-blur:name>\n */\nexport const blurDirective = createModelModifierDirective('blur', function (el, property, state, modifiers, uniqueId) {\n    // We need to block input events AND listen for blur\n    let inputHandler = function (e) {\n        // Block v-model's input handler\n        e.stopImmediatePropagation();\n    };\n\n    let blurHandler = function (e) {\n        updateState(state, property, getInputValue(e.target));\n    };\n\n    // Add blur listener (not in capture, just normal)\n    el.addEventListener('blur', blurHandler);\n\n    // Store blur handler for cleanup\n    el._livueBlurHandler = blurHandler;\n\n    return {\n        eventType: 'input',\n        handler: inputHandler,\n    };\n});\n\n// Override unmounted for blur to also remove blur listener\nconst originalBlurUnmounted = blurDirective.unmounted;\nblurDirective.unmounted = function (el) {\n    let info = _bindings.get(el);\n    let targetEl = info ? info.targetEl : el;\n    if (targetEl._livueBlurHandler) {\n        targetEl.removeEventListener('blur', targetEl._livueBlurHandler);\n        delete targetEl._livueBlurHandler;\n    }\n    originalBlurUnmounted(el);\n};\n\n/**\n * v-enter directive\n * Updates v-model only on Enter keypress.\n *\n * Usage: <input v-model=\"term\" v-enter:term>\n */\nexport const enterDirective = createModelModifierDirective('enter', function (el, property, state, modifiers, uniqueId) {\n    // Block input events\n    let inputHandler = function (e) {\n        e.stopImmediatePropagation();\n    };\n\n    // Listen for Enter key\n    let keyHandler = function (e) {\n        if (e.key === 'Enter') {\n            updateState(state, property, getInputValue(e.target));\n        }\n    };\n\n    el.addEventListener('keyup', keyHandler);\n    el._livueEnterHandler = keyHandler;\n\n    return {\n        eventType: 'input',\n        handler: inputHandler,\n    };\n});\n\n// Override unmounted for enter\nconst originalEnterUnmounted = enterDirective.unmounted;\nenterDirective.unmounted = function (el) {\n    let info = _bindings.get(el);\n    let targetEl = info ? info.targetEl : el;\n    if (targetEl._livueEnterHandler) {\n        targetEl.removeEventListener('keyup', targetEl._livueEnterHandler);\n        delete targetEl._livueEnterHandler;\n    }\n    originalEnterUnmounted(el);\n};\n\n/**\n * v-boolean directive\n * Casts v-model value to boolean.\n *\n * Usage: <input v-model=\"active\" v-boolean:active>\n */\nexport const booleanDirective = createModelModifierDirective('boolean', function (el, property, state, modifiers, uniqueId) {\n    return {\n        eventType: 'input',\n        handler: function (e) {\n            e.stopImmediatePropagation();\n\n            let value = getInputValue(e.target);\n            // Cast to boolean\n            value = Boolean(value) && value !== 'false' && value !== '0';\n            updateState(state, property, value);\n        },\n    };\n});\n\nexport default {\n    debounceDirective,\n    throttleDirective,\n    blurDirective,\n    enterDirective,\n    booleanDirective,\n};\n","/**!\n * Sortable 1.15.6\n * @author\tRubaXa   <trash@rubaxa.org>\n * @author\towenm    <owen23355@gmail.com>\n * @license MIT\n */\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n  return _typeof(obj);\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n  return target;\n}\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nvar version = \"1.15.6\";\n\nfunction userAgent(pattern) {\n  if (typeof window !== 'undefined' && window.navigator) {\n    return !! /*@__PURE__*/navigator.userAgent.match(pattern);\n  }\n}\nvar IE11OrLess = userAgent(/(?:Trident.*rv[ :]?11\\.|msie|iemobile|Windows Phone)/i);\nvar Edge = userAgent(/Edge/i);\nvar FireFox = userAgent(/firefox/i);\nvar Safari = userAgent(/safari/i) && !userAgent(/chrome/i) && !userAgent(/android/i);\nvar IOS = userAgent(/iP(ad|od|hone)/i);\nvar ChromeForAndroid = userAgent(/chrome/i) && userAgent(/android/i);\n\nvar captureMode = {\n  capture: false,\n  passive: false\n};\nfunction on(el, event, fn) {\n  el.addEventListener(event, fn, !IE11OrLess && captureMode);\n}\nfunction off(el, event, fn) {\n  el.removeEventListener(event, fn, !IE11OrLess && captureMode);\n}\nfunction matches( /**HTMLElement*/el, /**String*/selector) {\n  if (!selector) return;\n  selector[0] === '>' && (selector = selector.substring(1));\n  if (el) {\n    try {\n      if (el.matches) {\n        return el.matches(selector);\n      } else if (el.msMatchesSelector) {\n        return el.msMatchesSelector(selector);\n      } else if (el.webkitMatchesSelector) {\n        return el.webkitMatchesSelector(selector);\n      }\n    } catch (_) {\n      return false;\n    }\n  }\n  return false;\n}\nfunction getParentOrHost(el) {\n  return el.host && el !== document && el.host.nodeType ? el.host : el.parentNode;\n}\nfunction closest( /**HTMLElement*/el, /**String*/selector, /**HTMLElement*/ctx, includeCTX) {\n  if (el) {\n    ctx = ctx || document;\n    do {\n      if (selector != null && (selector[0] === '>' ? el.parentNode === ctx && matches(el, selector) : matches(el, selector)) || includeCTX && el === ctx) {\n        return el;\n      }\n      if (el === ctx) break;\n      /* jshint boss:true */\n    } while (el = getParentOrHost(el));\n  }\n  return null;\n}\nvar R_SPACE = /\\s+/g;\nfunction toggleClass(el, name, state) {\n  if (el && name) {\n    if (el.classList) {\n      el.classList[state ? 'add' : 'remove'](name);\n    } else {\n      var className = (' ' + el.className + ' ').replace(R_SPACE, ' ').replace(' ' + name + ' ', ' ');\n      el.className = (className + (state ? ' ' + name : '')).replace(R_SPACE, ' ');\n    }\n  }\n}\nfunction css(el, prop, val) {\n  var style = el && el.style;\n  if (style) {\n    if (val === void 0) {\n      if (document.defaultView && document.defaultView.getComputedStyle) {\n        val = document.defaultView.getComputedStyle(el, '');\n      } else if (el.currentStyle) {\n        val = el.currentStyle;\n      }\n      return prop === void 0 ? val : val[prop];\n    } else {\n      if (!(prop in style) && prop.indexOf('webkit') === -1) {\n        prop = '-webkit-' + prop;\n      }\n      style[prop] = val + (typeof val === 'string' ? '' : 'px');\n    }\n  }\n}\nfunction matrix(el, selfOnly) {\n  var appliedTransforms = '';\n  if (typeof el === 'string') {\n    appliedTransforms = el;\n  } else {\n    do {\n      var transform = css(el, 'transform');\n      if (transform && transform !== 'none') {\n        appliedTransforms = transform + ' ' + appliedTransforms;\n      }\n      /* jshint boss:true */\n    } while (!selfOnly && (el = el.parentNode));\n  }\n  var matrixFn = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;\n  /*jshint -W056 */\n  return matrixFn && new matrixFn(appliedTransforms);\n}\nfunction find(ctx, tagName, iterator) {\n  if (ctx) {\n    var list = ctx.getElementsByTagName(tagName),\n      i = 0,\n      n = list.length;\n    if (iterator) {\n      for (; i < n; i++) {\n        iterator(list[i], i);\n      }\n    }\n    return list;\n  }\n  return [];\n}\nfunction getWindowScrollingElement() {\n  var scrollingElement = document.scrollingElement;\n  if (scrollingElement) {\n    return scrollingElement;\n  } else {\n    return document.documentElement;\n  }\n}\n\n/**\r\n * Returns the \"bounding client rect\" of given element\r\n * @param  {HTMLElement} el                       The element whose boundingClientRect is wanted\r\n * @param  {[Boolean]} relativeToContainingBlock  Whether the rect should be relative to the containing block of (including) the container\r\n * @param  {[Boolean]} relativeToNonStaticParent  Whether the rect should be relative to the relative parent of (including) the contaienr\r\n * @param  {[Boolean]} undoScale                  Whether the container's scale() should be undone\r\n * @param  {[HTMLElement]} container              The parent the element will be placed in\r\n * @return {Object}                               The boundingClientRect of el, with specified adjustments\r\n */\nfunction getRect(el, relativeToContainingBlock, relativeToNonStaticParent, undoScale, container) {\n  if (!el.getBoundingClientRect && el !== window) return;\n  var elRect, top, left, bottom, right, height, width;\n  if (el !== window && el.parentNode && el !== getWindowScrollingElement()) {\n    elRect = el.getBoundingClientRect();\n    top = elRect.top;\n    left = elRect.left;\n    bottom = elRect.bottom;\n    right = elRect.right;\n    height = elRect.height;\n    width = elRect.width;\n  } else {\n    top = 0;\n    left = 0;\n    bottom = window.innerHeight;\n    right = window.innerWidth;\n    height = window.innerHeight;\n    width = window.innerWidth;\n  }\n  if ((relativeToContainingBlock || relativeToNonStaticParent) && el !== window) {\n    // Adjust for translate()\n    container = container || el.parentNode;\n\n    // solves #1123 (see: https://stackoverflow.com/a/37953806/6088312)\n    // Not needed on <= IE11\n    if (!IE11OrLess) {\n      do {\n        if (container && container.getBoundingClientRect && (css(container, 'transform') !== 'none' || relativeToNonStaticParent && css(container, 'position') !== 'static')) {\n          var containerRect = container.getBoundingClientRect();\n\n          // Set relative to edges of padding box of container\n          top -= containerRect.top + parseInt(css(container, 'border-top-width'));\n          left -= containerRect.left + parseInt(css(container, 'border-left-width'));\n          bottom = top + elRect.height;\n          right = left + elRect.width;\n          break;\n        }\n        /* jshint boss:true */\n      } while (container = container.parentNode);\n    }\n  }\n  if (undoScale && el !== window) {\n    // Adjust for scale()\n    var elMatrix = matrix(container || el),\n      scaleX = elMatrix && elMatrix.a,\n      scaleY = elMatrix && elMatrix.d;\n    if (elMatrix) {\n      top /= scaleY;\n      left /= scaleX;\n      width /= scaleX;\n      height /= scaleY;\n      bottom = top + height;\n      right = left + width;\n    }\n  }\n  return {\n    top: top,\n    left: left,\n    bottom: bottom,\n    right: right,\n    width: width,\n    height: height\n  };\n}\n\n/**\r\n * Checks if a side of an element is scrolled past a side of its parents\r\n * @param  {HTMLElement}  el           The element who's side being scrolled out of view is in question\r\n * @param  {String}       elSide       Side of the element in question ('top', 'left', 'right', 'bottom')\r\n * @param  {String}       parentSide   Side of the parent in question ('top', 'left', 'right', 'bottom')\r\n * @return {HTMLElement}               The parent scroll element that the el's side is scrolled past, or null if there is no such element\r\n */\nfunction isScrolledPast(el, elSide, parentSide) {\n  var parent = getParentAutoScrollElement(el, true),\n    elSideVal = getRect(el)[elSide];\n\n  /* jshint boss:true */\n  while (parent) {\n    var parentSideVal = getRect(parent)[parentSide],\n      visible = void 0;\n    if (parentSide === 'top' || parentSide === 'left') {\n      visible = elSideVal >= parentSideVal;\n    } else {\n      visible = elSideVal <= parentSideVal;\n    }\n    if (!visible) return parent;\n    if (parent === getWindowScrollingElement()) break;\n    parent = getParentAutoScrollElement(parent, false);\n  }\n  return false;\n}\n\n/**\r\n * Gets nth child of el, ignoring hidden children, sortable's elements (does not ignore clone if it's visible)\r\n * and non-draggable elements\r\n * @param  {HTMLElement} el       The parent element\r\n * @param  {Number} childNum      The index of the child\r\n * @param  {Object} options       Parent Sortable's options\r\n * @return {HTMLElement}          The child at index childNum, or null if not found\r\n */\nfunction getChild(el, childNum, options, includeDragEl) {\n  var currentChild = 0,\n    i = 0,\n    children = el.children;\n  while (i < children.length) {\n    if (children[i].style.display !== 'none' && children[i] !== Sortable.ghost && (includeDragEl || children[i] !== Sortable.dragged) && closest(children[i], options.draggable, el, false)) {\n      if (currentChild === childNum) {\n        return children[i];\n      }\n      currentChild++;\n    }\n    i++;\n  }\n  return null;\n}\n\n/**\r\n * Gets the last child in the el, ignoring ghostEl or invisible elements (clones)\r\n * @param  {HTMLElement} el       Parent element\r\n * @param  {selector} selector    Any other elements that should be ignored\r\n * @return {HTMLElement}          The last child, ignoring ghostEl\r\n */\nfunction lastChild(el, selector) {\n  var last = el.lastElementChild;\n  while (last && (last === Sortable.ghost || css(last, 'display') === 'none' || selector && !matches(last, selector))) {\n    last = last.previousElementSibling;\n  }\n  return last || null;\n}\n\n/**\r\n * Returns the index of an element within its parent for a selected set of\r\n * elements\r\n * @param  {HTMLElement} el\r\n * @param  {selector} selector\r\n * @return {number}\r\n */\nfunction index(el, selector) {\n  var index = 0;\n  if (!el || !el.parentNode) {\n    return -1;\n  }\n\n  /* jshint boss:true */\n  while (el = el.previousElementSibling) {\n    if (el.nodeName.toUpperCase() !== 'TEMPLATE' && el !== Sortable.clone && (!selector || matches(el, selector))) {\n      index++;\n    }\n  }\n  return index;\n}\n\n/**\r\n * Returns the scroll offset of the given element, added with all the scroll offsets of parent elements.\r\n * The value is returned in real pixels.\r\n * @param  {HTMLElement} el\r\n * @return {Array}             Offsets in the format of [left, top]\r\n */\nfunction getRelativeScrollOffset(el) {\n  var offsetLeft = 0,\n    offsetTop = 0,\n    winScroller = getWindowScrollingElement();\n  if (el) {\n    do {\n      var elMatrix = matrix(el),\n        scaleX = elMatrix.a,\n        scaleY = elMatrix.d;\n      offsetLeft += el.scrollLeft * scaleX;\n      offsetTop += el.scrollTop * scaleY;\n    } while (el !== winScroller && (el = el.parentNode));\n  }\n  return [offsetLeft, offsetTop];\n}\n\n/**\r\n * Returns the index of the object within the given array\r\n * @param  {Array} arr   Array that may or may not hold the object\r\n * @param  {Object} obj  An object that has a key-value pair unique to and identical to a key-value pair in the object you want to find\r\n * @return {Number}      The index of the object in the array, or -1\r\n */\nfunction indexOfObject(arr, obj) {\n  for (var i in arr) {\n    if (!arr.hasOwnProperty(i)) continue;\n    for (var key in obj) {\n      if (obj.hasOwnProperty(key) && obj[key] === arr[i][key]) return Number(i);\n    }\n  }\n  return -1;\n}\nfunction getParentAutoScrollElement(el, includeSelf) {\n  // skip to window\n  if (!el || !el.getBoundingClientRect) return getWindowScrollingElement();\n  var elem = el;\n  var gotSelf = false;\n  do {\n    // we don't need to get elem css if it isn't even overflowing in the first place (performance)\n    if (elem.clientWidth < elem.scrollWidth || elem.clientHeight < elem.scrollHeight) {\n      var elemCSS = css(elem);\n      if (elem.clientWidth < elem.scrollWidth && (elemCSS.overflowX == 'auto' || elemCSS.overflowX == 'scroll') || elem.clientHeight < elem.scrollHeight && (elemCSS.overflowY == 'auto' || elemCSS.overflowY == 'scroll')) {\n        if (!elem.getBoundingClientRect || elem === document.body) return getWindowScrollingElement();\n        if (gotSelf || includeSelf) return elem;\n        gotSelf = true;\n      }\n    }\n    /* jshint boss:true */\n  } while (elem = elem.parentNode);\n  return getWindowScrollingElement();\n}\nfunction extend(dst, src) {\n  if (dst && src) {\n    for (var key in src) {\n      if (src.hasOwnProperty(key)) {\n        dst[key] = src[key];\n      }\n    }\n  }\n  return dst;\n}\nfunction isRectEqual(rect1, rect2) {\n  return Math.round(rect1.top) === Math.round(rect2.top) && Math.round(rect1.left) === Math.round(rect2.left) && Math.round(rect1.height) === Math.round(rect2.height) && Math.round(rect1.width) === Math.round(rect2.width);\n}\nvar _throttleTimeout;\nfunction throttle(callback, ms) {\n  return function () {\n    if (!_throttleTimeout) {\n      var args = arguments,\n        _this = this;\n      if (args.length === 1) {\n        callback.call(_this, args[0]);\n      } else {\n        callback.apply(_this, args);\n      }\n      _throttleTimeout = setTimeout(function () {\n        _throttleTimeout = void 0;\n      }, ms);\n    }\n  };\n}\nfunction cancelThrottle() {\n  clearTimeout(_throttleTimeout);\n  _throttleTimeout = void 0;\n}\nfunction scrollBy(el, x, y) {\n  el.scrollLeft += x;\n  el.scrollTop += y;\n}\nfunction clone(el) {\n  var Polymer = window.Polymer;\n  var $ = window.jQuery || window.Zepto;\n  if (Polymer && Polymer.dom) {\n    return Polymer.dom(el).cloneNode(true);\n  } else if ($) {\n    return $(el).clone(true)[0];\n  } else {\n    return el.cloneNode(true);\n  }\n}\nfunction setRect(el, rect) {\n  css(el, 'position', 'absolute');\n  css(el, 'top', rect.top);\n  css(el, 'left', rect.left);\n  css(el, 'width', rect.width);\n  css(el, 'height', rect.height);\n}\nfunction unsetRect(el) {\n  css(el, 'position', '');\n  css(el, 'top', '');\n  css(el, 'left', '');\n  css(el, 'width', '');\n  css(el, 'height', '');\n}\nfunction getChildContainingRectFromElement(container, options, ghostEl) {\n  var rect = {};\n  Array.from(container.children).forEach(function (child) {\n    var _rect$left, _rect$top, _rect$right, _rect$bottom;\n    if (!closest(child, options.draggable, container, false) || child.animated || child === ghostEl) return;\n    var childRect = getRect(child);\n    rect.left = Math.min((_rect$left = rect.left) !== null && _rect$left !== void 0 ? _rect$left : Infinity, childRect.left);\n    rect.top = Math.min((_rect$top = rect.top) !== null && _rect$top !== void 0 ? _rect$top : Infinity, childRect.top);\n    rect.right = Math.max((_rect$right = rect.right) !== null && _rect$right !== void 0 ? _rect$right : -Infinity, childRect.right);\n    rect.bottom = Math.max((_rect$bottom = rect.bottom) !== null && _rect$bottom !== void 0 ? _rect$bottom : -Infinity, childRect.bottom);\n  });\n  rect.width = rect.right - rect.left;\n  rect.height = rect.bottom - rect.top;\n  rect.x = rect.left;\n  rect.y = rect.top;\n  return rect;\n}\nvar expando = 'Sortable' + new Date().getTime();\n\nfunction AnimationStateManager() {\n  var animationStates = [],\n    animationCallbackId;\n  return {\n    captureAnimationState: function captureAnimationState() {\n      animationStates = [];\n      if (!this.options.animation) return;\n      var children = [].slice.call(this.el.children);\n      children.forEach(function (child) {\n        if (css(child, 'display') === 'none' || child === Sortable.ghost) return;\n        animationStates.push({\n          target: child,\n          rect: getRect(child)\n        });\n        var fromRect = _objectSpread2({}, animationStates[animationStates.length - 1].rect);\n\n        // If animating: compensate for current animation\n        if (child.thisAnimationDuration) {\n          var childMatrix = matrix(child, true);\n          if (childMatrix) {\n            fromRect.top -= childMatrix.f;\n            fromRect.left -= childMatrix.e;\n          }\n        }\n        child.fromRect = fromRect;\n      });\n    },\n    addAnimationState: function addAnimationState(state) {\n      animationStates.push(state);\n    },\n    removeAnimationState: function removeAnimationState(target) {\n      animationStates.splice(indexOfObject(animationStates, {\n        target: target\n      }), 1);\n    },\n    animateAll: function animateAll(callback) {\n      var _this = this;\n      if (!this.options.animation) {\n        clearTimeout(animationCallbackId);\n        if (typeof callback === 'function') callback();\n        return;\n      }\n      var animating = false,\n        animationTime = 0;\n      animationStates.forEach(function (state) {\n        var time = 0,\n          target = state.target,\n          fromRect = target.fromRect,\n          toRect = getRect(target),\n          prevFromRect = target.prevFromRect,\n          prevToRect = target.prevToRect,\n          animatingRect = state.rect,\n          targetMatrix = matrix(target, true);\n        if (targetMatrix) {\n          // Compensate for current animation\n          toRect.top -= targetMatrix.f;\n          toRect.left -= targetMatrix.e;\n        }\n        target.toRect = toRect;\n        if (target.thisAnimationDuration) {\n          // Could also check if animatingRect is between fromRect and toRect\n          if (isRectEqual(prevFromRect, toRect) && !isRectEqual(fromRect, toRect) &&\n          // Make sure animatingRect is on line between toRect & fromRect\n          (animatingRect.top - toRect.top) / (animatingRect.left - toRect.left) === (fromRect.top - toRect.top) / (fromRect.left - toRect.left)) {\n            // If returning to same place as started from animation and on same axis\n            time = calculateRealTime(animatingRect, prevFromRect, prevToRect, _this.options);\n          }\n        }\n\n        // if fromRect != toRect: animate\n        if (!isRectEqual(toRect, fromRect)) {\n          target.prevFromRect = fromRect;\n          target.prevToRect = toRect;\n          if (!time) {\n            time = _this.options.animation;\n          }\n          _this.animate(target, animatingRect, toRect, time);\n        }\n        if (time) {\n          animating = true;\n          animationTime = Math.max(animationTime, time);\n          clearTimeout(target.animationResetTimer);\n          target.animationResetTimer = setTimeout(function () {\n            target.animationTime = 0;\n            target.prevFromRect = null;\n            target.fromRect = null;\n            target.prevToRect = null;\n            target.thisAnimationDuration = null;\n          }, time);\n          target.thisAnimationDuration = time;\n        }\n      });\n      clearTimeout(animationCallbackId);\n      if (!animating) {\n        if (typeof callback === 'function') callback();\n      } else {\n        animationCallbackId = setTimeout(function () {\n          if (typeof callback === 'function') callback();\n        }, animationTime);\n      }\n      animationStates = [];\n    },\n    animate: function animate(target, currentRect, toRect, duration) {\n      if (duration) {\n        css(target, 'transition', '');\n        css(target, 'transform', '');\n        var elMatrix = matrix(this.el),\n          scaleX = elMatrix && elMatrix.a,\n          scaleY = elMatrix && elMatrix.d,\n          translateX = (currentRect.left - toRect.left) / (scaleX || 1),\n          translateY = (currentRect.top - toRect.top) / (scaleY || 1);\n        target.animatingX = !!translateX;\n        target.animatingY = !!translateY;\n        css(target, 'transform', 'translate3d(' + translateX + 'px,' + translateY + 'px,0)');\n        this.forRepaintDummy = repaint(target); // repaint\n\n        css(target, 'transition', 'transform ' + duration + 'ms' + (this.options.easing ? ' ' + this.options.easing : ''));\n        css(target, 'transform', 'translate3d(0,0,0)');\n        typeof target.animated === 'number' && clearTimeout(target.animated);\n        target.animated = setTimeout(function () {\n          css(target, 'transition', '');\n          css(target, 'transform', '');\n          target.animated = false;\n          target.animatingX = false;\n          target.animatingY = false;\n        }, duration);\n      }\n    }\n  };\n}\nfunction repaint(target) {\n  return target.offsetWidth;\n}\nfunction calculateRealTime(animatingRect, fromRect, toRect, options) {\n  return Math.sqrt(Math.pow(fromRect.top - animatingRect.top, 2) + Math.pow(fromRect.left - animatingRect.left, 2)) / Math.sqrt(Math.pow(fromRect.top - toRect.top, 2) + Math.pow(fromRect.left - toRect.left, 2)) * options.animation;\n}\n\nvar plugins = [];\nvar defaults = {\n  initializeByDefault: true\n};\nvar PluginManager = {\n  mount: function mount(plugin) {\n    // Set default static properties\n    for (var option in defaults) {\n      if (defaults.hasOwnProperty(option) && !(option in plugin)) {\n        plugin[option] = defaults[option];\n      }\n    }\n    plugins.forEach(function (p) {\n      if (p.pluginName === plugin.pluginName) {\n        throw \"Sortable: Cannot mount plugin \".concat(plugin.pluginName, \" more than once\");\n      }\n    });\n    plugins.push(plugin);\n  },\n  pluginEvent: function pluginEvent(eventName, sortable, evt) {\n    var _this = this;\n    this.eventCanceled = false;\n    evt.cancel = function () {\n      _this.eventCanceled = true;\n    };\n    var eventNameGlobal = eventName + 'Global';\n    plugins.forEach(function (plugin) {\n      if (!sortable[plugin.pluginName]) return;\n      // Fire global events if it exists in this sortable\n      if (sortable[plugin.pluginName][eventNameGlobal]) {\n        sortable[plugin.pluginName][eventNameGlobal](_objectSpread2({\n          sortable: sortable\n        }, evt));\n      }\n\n      // Only fire plugin event if plugin is enabled in this sortable,\n      // and plugin has event defined\n      if (sortable.options[plugin.pluginName] && sortable[plugin.pluginName][eventName]) {\n        sortable[plugin.pluginName][eventName](_objectSpread2({\n          sortable: sortable\n        }, evt));\n      }\n    });\n  },\n  initializePlugins: function initializePlugins(sortable, el, defaults, options) {\n    plugins.forEach(function (plugin) {\n      var pluginName = plugin.pluginName;\n      if (!sortable.options[pluginName] && !plugin.initializeByDefault) return;\n      var initialized = new plugin(sortable, el, sortable.options);\n      initialized.sortable = sortable;\n      initialized.options = sortable.options;\n      sortable[pluginName] = initialized;\n\n      // Add default options from plugin\n      _extends(defaults, initialized.defaults);\n    });\n    for (var option in sortable.options) {\n      if (!sortable.options.hasOwnProperty(option)) continue;\n      var modified = this.modifyOption(sortable, option, sortable.options[option]);\n      if (typeof modified !== 'undefined') {\n        sortable.options[option] = modified;\n      }\n    }\n  },\n  getEventProperties: function getEventProperties(name, sortable) {\n    var eventProperties = {};\n    plugins.forEach(function (plugin) {\n      if (typeof plugin.eventProperties !== 'function') return;\n      _extends(eventProperties, plugin.eventProperties.call(sortable[plugin.pluginName], name));\n    });\n    return eventProperties;\n  },\n  modifyOption: function modifyOption(sortable, name, value) {\n    var modifiedValue;\n    plugins.forEach(function (plugin) {\n      // Plugin must exist on the Sortable\n      if (!sortable[plugin.pluginName]) return;\n\n      // If static option listener exists for this option, call in the context of the Sortable's instance of this plugin\n      if (plugin.optionListeners && typeof plugin.optionListeners[name] === 'function') {\n        modifiedValue = plugin.optionListeners[name].call(sortable[plugin.pluginName], value);\n      }\n    });\n    return modifiedValue;\n  }\n};\n\nfunction dispatchEvent(_ref) {\n  var sortable = _ref.sortable,\n    rootEl = _ref.rootEl,\n    name = _ref.name,\n    targetEl = _ref.targetEl,\n    cloneEl = _ref.cloneEl,\n    toEl = _ref.toEl,\n    fromEl = _ref.fromEl,\n    oldIndex = _ref.oldIndex,\n    newIndex = _ref.newIndex,\n    oldDraggableIndex = _ref.oldDraggableIndex,\n    newDraggableIndex = _ref.newDraggableIndex,\n    originalEvent = _ref.originalEvent,\n    putSortable = _ref.putSortable,\n    extraEventProperties = _ref.extraEventProperties;\n  sortable = sortable || rootEl && rootEl[expando];\n  if (!sortable) return;\n  var evt,\n    options = sortable.options,\n    onName = 'on' + name.charAt(0).toUpperCase() + name.substr(1);\n  // Support for new CustomEvent feature\n  if (window.CustomEvent && !IE11OrLess && !Edge) {\n    evt = new CustomEvent(name, {\n      bubbles: true,\n      cancelable: true\n    });\n  } else {\n    evt = document.createEvent('Event');\n    evt.initEvent(name, true, true);\n  }\n  evt.to = toEl || rootEl;\n  evt.from = fromEl || rootEl;\n  evt.item = targetEl || rootEl;\n  evt.clone = cloneEl;\n  evt.oldIndex = oldIndex;\n  evt.newIndex = newIndex;\n  evt.oldDraggableIndex = oldDraggableIndex;\n  evt.newDraggableIndex = newDraggableIndex;\n  evt.originalEvent = originalEvent;\n  evt.pullMode = putSortable ? putSortable.lastPutMode : undefined;\n  var allEventProperties = _objectSpread2(_objectSpread2({}, extraEventProperties), PluginManager.getEventProperties(name, sortable));\n  for (var option in allEventProperties) {\n    evt[option] = allEventProperties[option];\n  }\n  if (rootEl) {\n    rootEl.dispatchEvent(evt);\n  }\n  if (options[onName]) {\n    options[onName].call(sortable, evt);\n  }\n}\n\nvar _excluded = [\"evt\"];\nvar pluginEvent = function pluginEvent(eventName, sortable) {\n  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n    originalEvent = _ref.evt,\n    data = _objectWithoutProperties(_ref, _excluded);\n  PluginManager.pluginEvent.bind(Sortable)(eventName, sortable, _objectSpread2({\n    dragEl: dragEl,\n    parentEl: parentEl,\n    ghostEl: ghostEl,\n    rootEl: rootEl,\n    nextEl: nextEl,\n    lastDownEl: lastDownEl,\n    cloneEl: cloneEl,\n    cloneHidden: cloneHidden,\n    dragStarted: moved,\n    putSortable: putSortable,\n    activeSortable: Sortable.active,\n    originalEvent: originalEvent,\n    oldIndex: oldIndex,\n    oldDraggableIndex: oldDraggableIndex,\n    newIndex: newIndex,\n    newDraggableIndex: newDraggableIndex,\n    hideGhostForTarget: _hideGhostForTarget,\n    unhideGhostForTarget: _unhideGhostForTarget,\n    cloneNowHidden: function cloneNowHidden() {\n      cloneHidden = true;\n    },\n    cloneNowShown: function cloneNowShown() {\n      cloneHidden = false;\n    },\n    dispatchSortableEvent: function dispatchSortableEvent(name) {\n      _dispatchEvent({\n        sortable: sortable,\n        name: name,\n        originalEvent: originalEvent\n      });\n    }\n  }, data));\n};\nfunction _dispatchEvent(info) {\n  dispatchEvent(_objectSpread2({\n    putSortable: putSortable,\n    cloneEl: cloneEl,\n    targetEl: dragEl,\n    rootEl: rootEl,\n    oldIndex: oldIndex,\n    oldDraggableIndex: oldDraggableIndex,\n    newIndex: newIndex,\n    newDraggableIndex: newDraggableIndex\n  }, info));\n}\nvar dragEl,\n  parentEl,\n  ghostEl,\n  rootEl,\n  nextEl,\n  lastDownEl,\n  cloneEl,\n  cloneHidden,\n  oldIndex,\n  newIndex,\n  oldDraggableIndex,\n  newDraggableIndex,\n  activeGroup,\n  putSortable,\n  awaitingDragStarted = false,\n  ignoreNextClick = false,\n  sortables = [],\n  tapEvt,\n  touchEvt,\n  lastDx,\n  lastDy,\n  tapDistanceLeft,\n  tapDistanceTop,\n  moved,\n  lastTarget,\n  lastDirection,\n  pastFirstInvertThresh = false,\n  isCircumstantialInvert = false,\n  targetMoveDistance,\n  // For positioning ghost absolutely\n  ghostRelativeParent,\n  ghostRelativeParentInitialScroll = [],\n  // (left, top)\n\n  _silent = false,\n  savedInputChecked = [];\n\n/** @const */\nvar documentExists = typeof document !== 'undefined',\n  PositionGhostAbsolutely = IOS,\n  CSSFloatProperty = Edge || IE11OrLess ? 'cssFloat' : 'float',\n  // This will not pass for IE9, because IE9 DnD only works on anchors\n  supportDraggable = documentExists && !ChromeForAndroid && !IOS && 'draggable' in document.createElement('div'),\n  supportCssPointerEvents = function () {\n    if (!documentExists) return;\n    // false when <= IE11\n    if (IE11OrLess) {\n      return false;\n    }\n    var el = document.createElement('x');\n    el.style.cssText = 'pointer-events:auto';\n    return el.style.pointerEvents === 'auto';\n  }(),\n  _detectDirection = function _detectDirection(el, options) {\n    var elCSS = css(el),\n      elWidth = parseInt(elCSS.width) - parseInt(elCSS.paddingLeft) - parseInt(elCSS.paddingRight) - parseInt(elCSS.borderLeftWidth) - parseInt(elCSS.borderRightWidth),\n      child1 = getChild(el, 0, options),\n      child2 = getChild(el, 1, options),\n      firstChildCSS = child1 && css(child1),\n      secondChildCSS = child2 && css(child2),\n      firstChildWidth = firstChildCSS && parseInt(firstChildCSS.marginLeft) + parseInt(firstChildCSS.marginRight) + getRect(child1).width,\n      secondChildWidth = secondChildCSS && parseInt(secondChildCSS.marginLeft) + parseInt(secondChildCSS.marginRight) + getRect(child2).width;\n    if (elCSS.display === 'flex') {\n      return elCSS.flexDirection === 'column' || elCSS.flexDirection === 'column-reverse' ? 'vertical' : 'horizontal';\n    }\n    if (elCSS.display === 'grid') {\n      return elCSS.gridTemplateColumns.split(' ').length <= 1 ? 'vertical' : 'horizontal';\n    }\n    if (child1 && firstChildCSS[\"float\"] && firstChildCSS[\"float\"] !== 'none') {\n      var touchingSideChild2 = firstChildCSS[\"float\"] === 'left' ? 'left' : 'right';\n      return child2 && (secondChildCSS.clear === 'both' || secondChildCSS.clear === touchingSideChild2) ? 'vertical' : 'horizontal';\n    }\n    return child1 && (firstChildCSS.display === 'block' || firstChildCSS.display === 'flex' || firstChildCSS.display === 'table' || firstChildCSS.display === 'grid' || firstChildWidth >= elWidth && elCSS[CSSFloatProperty] === 'none' || child2 && elCSS[CSSFloatProperty] === 'none' && firstChildWidth + secondChildWidth > elWidth) ? 'vertical' : 'horizontal';\n  },\n  _dragElInRowColumn = function _dragElInRowColumn(dragRect, targetRect, vertical) {\n    var dragElS1Opp = vertical ? dragRect.left : dragRect.top,\n      dragElS2Opp = vertical ? dragRect.right : dragRect.bottom,\n      dragElOppLength = vertical ? dragRect.width : dragRect.height,\n      targetS1Opp = vertical ? targetRect.left : targetRect.top,\n      targetS2Opp = vertical ? targetRect.right : targetRect.bottom,\n      targetOppLength = vertical ? targetRect.width : targetRect.height;\n    return dragElS1Opp === targetS1Opp || dragElS2Opp === targetS2Opp || dragElS1Opp + dragElOppLength / 2 === targetS1Opp + targetOppLength / 2;\n  },\n  /**\r\n   * Detects first nearest empty sortable to X and Y position using emptyInsertThreshold.\r\n   * @param  {Number} x      X position\r\n   * @param  {Number} y      Y position\r\n   * @return {HTMLElement}   Element of the first found nearest Sortable\r\n   */\n  _detectNearestEmptySortable = function _detectNearestEmptySortable(x, y) {\n    var ret;\n    sortables.some(function (sortable) {\n      var threshold = sortable[expando].options.emptyInsertThreshold;\n      if (!threshold || lastChild(sortable)) return;\n      var rect = getRect(sortable),\n        insideHorizontally = x >= rect.left - threshold && x <= rect.right + threshold,\n        insideVertically = y >= rect.top - threshold && y <= rect.bottom + threshold;\n      if (insideHorizontally && insideVertically) {\n        return ret = sortable;\n      }\n    });\n    return ret;\n  },\n  _prepareGroup = function _prepareGroup(options) {\n    function toFn(value, pull) {\n      return function (to, from, dragEl, evt) {\n        var sameGroup = to.options.group.name && from.options.group.name && to.options.group.name === from.options.group.name;\n        if (value == null && (pull || sameGroup)) {\n          // Default pull value\n          // Default pull and put value if same group\n          return true;\n        } else if (value == null || value === false) {\n          return false;\n        } else if (pull && value === 'clone') {\n          return value;\n        } else if (typeof value === 'function') {\n          return toFn(value(to, from, dragEl, evt), pull)(to, from, dragEl, evt);\n        } else {\n          var otherGroup = (pull ? to : from).options.group.name;\n          return value === true || typeof value === 'string' && value === otherGroup || value.join && value.indexOf(otherGroup) > -1;\n        }\n      };\n    }\n    var group = {};\n    var originalGroup = options.group;\n    if (!originalGroup || _typeof(originalGroup) != 'object') {\n      originalGroup = {\n        name: originalGroup\n      };\n    }\n    group.name = originalGroup.name;\n    group.checkPull = toFn(originalGroup.pull, true);\n    group.checkPut = toFn(originalGroup.put);\n    group.revertClone = originalGroup.revertClone;\n    options.group = group;\n  },\n  _hideGhostForTarget = function _hideGhostForTarget() {\n    if (!supportCssPointerEvents && ghostEl) {\n      css(ghostEl, 'display', 'none');\n    }\n  },\n  _unhideGhostForTarget = function _unhideGhostForTarget() {\n    if (!supportCssPointerEvents && ghostEl) {\n      css(ghostEl, 'display', '');\n    }\n  };\n\n// #1184 fix - Prevent click event on fallback if dragged but item not changed position\nif (documentExists && !ChromeForAndroid) {\n  document.addEventListener('click', function (evt) {\n    if (ignoreNextClick) {\n      evt.preventDefault();\n      evt.stopPropagation && evt.stopPropagation();\n      evt.stopImmediatePropagation && evt.stopImmediatePropagation();\n      ignoreNextClick = false;\n      return false;\n    }\n  }, true);\n}\nvar nearestEmptyInsertDetectEvent = function nearestEmptyInsertDetectEvent(evt) {\n  if (dragEl) {\n    evt = evt.touches ? evt.touches[0] : evt;\n    var nearest = _detectNearestEmptySortable(evt.clientX, evt.clientY);\n    if (nearest) {\n      // Create imitation event\n      var event = {};\n      for (var i in evt) {\n        if (evt.hasOwnProperty(i)) {\n          event[i] = evt[i];\n        }\n      }\n      event.target = event.rootEl = nearest;\n      event.preventDefault = void 0;\n      event.stopPropagation = void 0;\n      nearest[expando]._onDragOver(event);\n    }\n  }\n};\nvar _checkOutsideTargetEl = function _checkOutsideTargetEl(evt) {\n  if (dragEl) {\n    dragEl.parentNode[expando]._isOutsideThisEl(evt.target);\n  }\n};\n\n/**\r\n * @class  Sortable\r\n * @param  {HTMLElement}  el\r\n * @param  {Object}       [options]\r\n */\nfunction Sortable(el, options) {\n  if (!(el && el.nodeType && el.nodeType === 1)) {\n    throw \"Sortable: `el` must be an HTMLElement, not \".concat({}.toString.call(el));\n  }\n  this.el = el; // root element\n  this.options = options = _extends({}, options);\n\n  // Export instance\n  el[expando] = this;\n  var defaults = {\n    group: null,\n    sort: true,\n    disabled: false,\n    store: null,\n    handle: null,\n    draggable: /^[uo]l$/i.test(el.nodeName) ? '>li' : '>*',\n    swapThreshold: 1,\n    // percentage; 0 <= x <= 1\n    invertSwap: false,\n    // invert always\n    invertedSwapThreshold: null,\n    // will be set to same as swapThreshold if default\n    removeCloneOnHide: true,\n    direction: function direction() {\n      return _detectDirection(el, this.options);\n    },\n    ghostClass: 'sortable-ghost',\n    chosenClass: 'sortable-chosen',\n    dragClass: 'sortable-drag',\n    ignore: 'a, img',\n    filter: null,\n    preventOnFilter: true,\n    animation: 0,\n    easing: null,\n    setData: function setData(dataTransfer, dragEl) {\n      dataTransfer.setData('Text', dragEl.textContent);\n    },\n    dropBubble: false,\n    dragoverBubble: false,\n    dataIdAttr: 'data-id',\n    delay: 0,\n    delayOnTouchOnly: false,\n    touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1,\n    forceFallback: false,\n    fallbackClass: 'sortable-fallback',\n    fallbackOnBody: false,\n    fallbackTolerance: 0,\n    fallbackOffset: {\n      x: 0,\n      y: 0\n    },\n    // Disabled on Safari: #1571; Enabled on Safari IOS: #2244\n    supportPointer: Sortable.supportPointer !== false && 'PointerEvent' in window && (!Safari || IOS),\n    emptyInsertThreshold: 5\n  };\n  PluginManager.initializePlugins(this, el, defaults);\n\n  // Set default options\n  for (var name in defaults) {\n    !(name in options) && (options[name] = defaults[name]);\n  }\n  _prepareGroup(options);\n\n  // Bind all private methods\n  for (var fn in this) {\n    if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {\n      this[fn] = this[fn].bind(this);\n    }\n  }\n\n  // Setup drag mode\n  this.nativeDraggable = options.forceFallback ? false : supportDraggable;\n  if (this.nativeDraggable) {\n    // Touch start threshold cannot be greater than the native dragstart threshold\n    this.options.touchStartThreshold = 1;\n  }\n\n  // Bind events\n  if (options.supportPointer) {\n    on(el, 'pointerdown', this._onTapStart);\n  } else {\n    on(el, 'mousedown', this._onTapStart);\n    on(el, 'touchstart', this._onTapStart);\n  }\n  if (this.nativeDraggable) {\n    on(el, 'dragover', this);\n    on(el, 'dragenter', this);\n  }\n  sortables.push(this.el);\n\n  // Restore sorting\n  options.store && options.store.get && this.sort(options.store.get(this) || []);\n\n  // Add animation state manager\n  _extends(this, AnimationStateManager());\n}\nSortable.prototype = /** @lends Sortable.prototype */{\n  constructor: Sortable,\n  _isOutsideThisEl: function _isOutsideThisEl(target) {\n    if (!this.el.contains(target) && target !== this.el) {\n      lastTarget = null;\n    }\n  },\n  _getDirection: function _getDirection(evt, target) {\n    return typeof this.options.direction === 'function' ? this.options.direction.call(this, evt, target, dragEl) : this.options.direction;\n  },\n  _onTapStart: function _onTapStart( /** Event|TouchEvent */evt) {\n    if (!evt.cancelable) return;\n    var _this = this,\n      el = this.el,\n      options = this.options,\n      preventOnFilter = options.preventOnFilter,\n      type = evt.type,\n      touch = evt.touches && evt.touches[0] || evt.pointerType && evt.pointerType === 'touch' && evt,\n      target = (touch || evt).target,\n      originalTarget = evt.target.shadowRoot && (evt.path && evt.path[0] || evt.composedPath && evt.composedPath()[0]) || target,\n      filter = options.filter;\n    _saveInputCheckedState(el);\n\n    // Don't trigger start event when an element is been dragged, otherwise the evt.oldindex always wrong when set option.group.\n    if (dragEl) {\n      return;\n    }\n    if (/mousedown|pointerdown/.test(type) && evt.button !== 0 || options.disabled) {\n      return; // only left button and enabled\n    }\n\n    // cancel dnd if original target is content editable\n    if (originalTarget.isContentEditable) {\n      return;\n    }\n\n    // Safari ignores further event handling after mousedown\n    if (!this.nativeDraggable && Safari && target && target.tagName.toUpperCase() === 'SELECT') {\n      return;\n    }\n    target = closest(target, options.draggable, el, false);\n    if (target && target.animated) {\n      return;\n    }\n    if (lastDownEl === target) {\n      // Ignoring duplicate `down`\n      return;\n    }\n\n    // Get the index of the dragged element within its parent\n    oldIndex = index(target);\n    oldDraggableIndex = index(target, options.draggable);\n\n    // Check filter\n    if (typeof filter === 'function') {\n      if (filter.call(this, evt, target, this)) {\n        _dispatchEvent({\n          sortable: _this,\n          rootEl: originalTarget,\n          name: 'filter',\n          targetEl: target,\n          toEl: el,\n          fromEl: el\n        });\n        pluginEvent('filter', _this, {\n          evt: evt\n        });\n        preventOnFilter && evt.preventDefault();\n        return; // cancel dnd\n      }\n    } else if (filter) {\n      filter = filter.split(',').some(function (criteria) {\n        criteria = closest(originalTarget, criteria.trim(), el, false);\n        if (criteria) {\n          _dispatchEvent({\n            sortable: _this,\n            rootEl: criteria,\n            name: 'filter',\n            targetEl: target,\n            fromEl: el,\n            toEl: el\n          });\n          pluginEvent('filter', _this, {\n            evt: evt\n          });\n          return true;\n        }\n      });\n      if (filter) {\n        preventOnFilter && evt.preventDefault();\n        return; // cancel dnd\n      }\n    }\n    if (options.handle && !closest(originalTarget, options.handle, el, false)) {\n      return;\n    }\n\n    // Prepare `dragstart`\n    this._prepareDragStart(evt, touch, target);\n  },\n  _prepareDragStart: function _prepareDragStart( /** Event */evt, /** Touch */touch, /** HTMLElement */target) {\n    var _this = this,\n      el = _this.el,\n      options = _this.options,\n      ownerDocument = el.ownerDocument,\n      dragStartFn;\n    if (target && !dragEl && target.parentNode === el) {\n      var dragRect = getRect(target);\n      rootEl = el;\n      dragEl = target;\n      parentEl = dragEl.parentNode;\n      nextEl = dragEl.nextSibling;\n      lastDownEl = target;\n      activeGroup = options.group;\n      Sortable.dragged = dragEl;\n      tapEvt = {\n        target: dragEl,\n        clientX: (touch || evt).clientX,\n        clientY: (touch || evt).clientY\n      };\n      tapDistanceLeft = tapEvt.clientX - dragRect.left;\n      tapDistanceTop = tapEvt.clientY - dragRect.top;\n      this._lastX = (touch || evt).clientX;\n      this._lastY = (touch || evt).clientY;\n      dragEl.style['will-change'] = 'all';\n      dragStartFn = function dragStartFn() {\n        pluginEvent('delayEnded', _this, {\n          evt: evt\n        });\n        if (Sortable.eventCanceled) {\n          _this._onDrop();\n          return;\n        }\n        // Delayed drag has been triggered\n        // we can re-enable the events: touchmove/mousemove\n        _this._disableDelayedDragEvents();\n        if (!FireFox && _this.nativeDraggable) {\n          dragEl.draggable = true;\n        }\n\n        // Bind the events: dragstart/dragend\n        _this._triggerDragStart(evt, touch);\n\n        // Drag start event\n        _dispatchEvent({\n          sortable: _this,\n          name: 'choose',\n          originalEvent: evt\n        });\n\n        // Chosen item\n        toggleClass(dragEl, options.chosenClass, true);\n      };\n\n      // Disable \"draggable\"\n      options.ignore.split(',').forEach(function (criteria) {\n        find(dragEl, criteria.trim(), _disableDraggable);\n      });\n      on(ownerDocument, 'dragover', nearestEmptyInsertDetectEvent);\n      on(ownerDocument, 'mousemove', nearestEmptyInsertDetectEvent);\n      on(ownerDocument, 'touchmove', nearestEmptyInsertDetectEvent);\n      if (options.supportPointer) {\n        on(ownerDocument, 'pointerup', _this._onDrop);\n        // Native D&D triggers pointercancel\n        !this.nativeDraggable && on(ownerDocument, 'pointercancel', _this._onDrop);\n      } else {\n        on(ownerDocument, 'mouseup', _this._onDrop);\n        on(ownerDocument, 'touchend', _this._onDrop);\n        on(ownerDocument, 'touchcancel', _this._onDrop);\n      }\n\n      // Make dragEl draggable (must be before delay for FireFox)\n      if (FireFox && this.nativeDraggable) {\n        this.options.touchStartThreshold = 4;\n        dragEl.draggable = true;\n      }\n      pluginEvent('delayStart', this, {\n        evt: evt\n      });\n\n      // Delay is impossible for native DnD in Edge or IE\n      if (options.delay && (!options.delayOnTouchOnly || touch) && (!this.nativeDraggable || !(Edge || IE11OrLess))) {\n        if (Sortable.eventCanceled) {\n          this._onDrop();\n          return;\n        }\n        // If the user moves the pointer or let go the click or touch\n        // before the delay has been reached:\n        // disable the delayed drag\n        if (options.supportPointer) {\n          on(ownerDocument, 'pointerup', _this._disableDelayedDrag);\n          on(ownerDocument, 'pointercancel', _this._disableDelayedDrag);\n        } else {\n          on(ownerDocument, 'mouseup', _this._disableDelayedDrag);\n          on(ownerDocument, 'touchend', _this._disableDelayedDrag);\n          on(ownerDocument, 'touchcancel', _this._disableDelayedDrag);\n        }\n        on(ownerDocument, 'mousemove', _this._delayedDragTouchMoveHandler);\n        on(ownerDocument, 'touchmove', _this._delayedDragTouchMoveHandler);\n        options.supportPointer && on(ownerDocument, 'pointermove', _this._delayedDragTouchMoveHandler);\n        _this._dragStartTimer = setTimeout(dragStartFn, options.delay);\n      } else {\n        dragStartFn();\n      }\n    }\n  },\n  _delayedDragTouchMoveHandler: function _delayedDragTouchMoveHandler( /** TouchEvent|PointerEvent **/e) {\n    var touch = e.touches ? e.touches[0] : e;\n    if (Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1))) {\n      this._disableDelayedDrag();\n    }\n  },\n  _disableDelayedDrag: function _disableDelayedDrag() {\n    dragEl && _disableDraggable(dragEl);\n    clearTimeout(this._dragStartTimer);\n    this._disableDelayedDragEvents();\n  },\n  _disableDelayedDragEvents: function _disableDelayedDragEvents() {\n    var ownerDocument = this.el.ownerDocument;\n    off(ownerDocument, 'mouseup', this._disableDelayedDrag);\n    off(ownerDocument, 'touchend', this._disableDelayedDrag);\n    off(ownerDocument, 'touchcancel', this._disableDelayedDrag);\n    off(ownerDocument, 'pointerup', this._disableDelayedDrag);\n    off(ownerDocument, 'pointercancel', this._disableDelayedDrag);\n    off(ownerDocument, 'mousemove', this._delayedDragTouchMoveHandler);\n    off(ownerDocument, 'touchmove', this._delayedDragTouchMoveHandler);\n    off(ownerDocument, 'pointermove', this._delayedDragTouchMoveHandler);\n  },\n  _triggerDragStart: function _triggerDragStart( /** Event */evt, /** Touch */touch) {\n    touch = touch || evt.pointerType == 'touch' && evt;\n    if (!this.nativeDraggable || touch) {\n      if (this.options.supportPointer) {\n        on(document, 'pointermove', this._onTouchMove);\n      } else if (touch) {\n        on(document, 'touchmove', this._onTouchMove);\n      } else {\n        on(document, 'mousemove', this._onTouchMove);\n      }\n    } else {\n      on(dragEl, 'dragend', this);\n      on(rootEl, 'dragstart', this._onDragStart);\n    }\n    try {\n      if (document.selection) {\n        _nextTick(function () {\n          document.selection.empty();\n        });\n      } else {\n        window.getSelection().removeAllRanges();\n      }\n    } catch (err) {}\n  },\n  _dragStarted: function _dragStarted(fallback, evt) {\n    awaitingDragStarted = false;\n    if (rootEl && dragEl) {\n      pluginEvent('dragStarted', this, {\n        evt: evt\n      });\n      if (this.nativeDraggable) {\n        on(document, 'dragover', _checkOutsideTargetEl);\n      }\n      var options = this.options;\n\n      // Apply effect\n      !fallback && toggleClass(dragEl, options.dragClass, false);\n      toggleClass(dragEl, options.ghostClass, true);\n      Sortable.active = this;\n      fallback && this._appendGhost();\n\n      // Drag start event\n      _dispatchEvent({\n        sortable: this,\n        name: 'start',\n        originalEvent: evt\n      });\n    } else {\n      this._nulling();\n    }\n  },\n  _emulateDragOver: function _emulateDragOver() {\n    if (touchEvt) {\n      this._lastX = touchEvt.clientX;\n      this._lastY = touchEvt.clientY;\n      _hideGhostForTarget();\n      var target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY);\n      var parent = target;\n      while (target && target.shadowRoot) {\n        target = target.shadowRoot.elementFromPoint(touchEvt.clientX, touchEvt.clientY);\n        if (target === parent) break;\n        parent = target;\n      }\n      dragEl.parentNode[expando]._isOutsideThisEl(target);\n      if (parent) {\n        do {\n          if (parent[expando]) {\n            var inserted = void 0;\n            inserted = parent[expando]._onDragOver({\n              clientX: touchEvt.clientX,\n              clientY: touchEvt.clientY,\n              target: target,\n              rootEl: parent\n            });\n            if (inserted && !this.options.dragoverBubble) {\n              break;\n            }\n          }\n          target = parent; // store last element\n        }\n        /* jshint boss:true */ while (parent = getParentOrHost(parent));\n      }\n      _unhideGhostForTarget();\n    }\n  },\n  _onTouchMove: function _onTouchMove( /**TouchEvent*/evt) {\n    if (tapEvt) {\n      var options = this.options,\n        fallbackTolerance = options.fallbackTolerance,\n        fallbackOffset = options.fallbackOffset,\n        touch = evt.touches ? evt.touches[0] : evt,\n        ghostMatrix = ghostEl && matrix(ghostEl, true),\n        scaleX = ghostEl && ghostMatrix && ghostMatrix.a,\n        scaleY = ghostEl && ghostMatrix && ghostMatrix.d,\n        relativeScrollOffset = PositionGhostAbsolutely && ghostRelativeParent && getRelativeScrollOffset(ghostRelativeParent),\n        dx = (touch.clientX - tapEvt.clientX + fallbackOffset.x) / (scaleX || 1) + (relativeScrollOffset ? relativeScrollOffset[0] - ghostRelativeParentInitialScroll[0] : 0) / (scaleX || 1),\n        dy = (touch.clientY - tapEvt.clientY + fallbackOffset.y) / (scaleY || 1) + (relativeScrollOffset ? relativeScrollOffset[1] - ghostRelativeParentInitialScroll[1] : 0) / (scaleY || 1);\n\n      // only set the status to dragging, when we are actually dragging\n      if (!Sortable.active && !awaitingDragStarted) {\n        if (fallbackTolerance && Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) < fallbackTolerance) {\n          return;\n        }\n        this._onDragStart(evt, true);\n      }\n      if (ghostEl) {\n        if (ghostMatrix) {\n          ghostMatrix.e += dx - (lastDx || 0);\n          ghostMatrix.f += dy - (lastDy || 0);\n        } else {\n          ghostMatrix = {\n            a: 1,\n            b: 0,\n            c: 0,\n            d: 1,\n            e: dx,\n            f: dy\n          };\n        }\n        var cssMatrix = \"matrix(\".concat(ghostMatrix.a, \",\").concat(ghostMatrix.b, \",\").concat(ghostMatrix.c, \",\").concat(ghostMatrix.d, \",\").concat(ghostMatrix.e, \",\").concat(ghostMatrix.f, \")\");\n        css(ghostEl, 'webkitTransform', cssMatrix);\n        css(ghostEl, 'mozTransform', cssMatrix);\n        css(ghostEl, 'msTransform', cssMatrix);\n        css(ghostEl, 'transform', cssMatrix);\n        lastDx = dx;\n        lastDy = dy;\n        touchEvt = touch;\n      }\n      evt.cancelable && evt.preventDefault();\n    }\n  },\n  _appendGhost: function _appendGhost() {\n    // Bug if using scale(): https://stackoverflow.com/questions/2637058\n    // Not being adjusted for\n    if (!ghostEl) {\n      var container = this.options.fallbackOnBody ? document.body : rootEl,\n        rect = getRect(dragEl, true, PositionGhostAbsolutely, true, container),\n        options = this.options;\n\n      // Position absolutely\n      if (PositionGhostAbsolutely) {\n        // Get relatively positioned parent\n        ghostRelativeParent = container;\n        while (css(ghostRelativeParent, 'position') === 'static' && css(ghostRelativeParent, 'transform') === 'none' && ghostRelativeParent !== document) {\n          ghostRelativeParent = ghostRelativeParent.parentNode;\n        }\n        if (ghostRelativeParent !== document.body && ghostRelativeParent !== document.documentElement) {\n          if (ghostRelativeParent === document) ghostRelativeParent = getWindowScrollingElement();\n          rect.top += ghostRelativeParent.scrollTop;\n          rect.left += ghostRelativeParent.scrollLeft;\n        } else {\n          ghostRelativeParent = getWindowScrollingElement();\n        }\n        ghostRelativeParentInitialScroll = getRelativeScrollOffset(ghostRelativeParent);\n      }\n      ghostEl = dragEl.cloneNode(true);\n      toggleClass(ghostEl, options.ghostClass, false);\n      toggleClass(ghostEl, options.fallbackClass, true);\n      toggleClass(ghostEl, options.dragClass, true);\n      css(ghostEl, 'transition', '');\n      css(ghostEl, 'transform', '');\n      css(ghostEl, 'box-sizing', 'border-box');\n      css(ghostEl, 'margin', 0);\n      css(ghostEl, 'top', rect.top);\n      css(ghostEl, 'left', rect.left);\n      css(ghostEl, 'width', rect.width);\n      css(ghostEl, 'height', rect.height);\n      css(ghostEl, 'opacity', '0.8');\n      css(ghostEl, 'position', PositionGhostAbsolutely ? 'absolute' : 'fixed');\n      css(ghostEl, 'zIndex', '100000');\n      css(ghostEl, 'pointerEvents', 'none');\n      Sortable.ghost = ghostEl;\n      container.appendChild(ghostEl);\n\n      // Set transform-origin\n      css(ghostEl, 'transform-origin', tapDistanceLeft / parseInt(ghostEl.style.width) * 100 + '% ' + tapDistanceTop / parseInt(ghostEl.style.height) * 100 + '%');\n    }\n  },\n  _onDragStart: function _onDragStart( /**Event*/evt, /**boolean*/fallback) {\n    var _this = this;\n    var dataTransfer = evt.dataTransfer;\n    var options = _this.options;\n    pluginEvent('dragStart', this, {\n      evt: evt\n    });\n    if (Sortable.eventCanceled) {\n      this._onDrop();\n      return;\n    }\n    pluginEvent('setupClone', this);\n    if (!Sortable.eventCanceled) {\n      cloneEl = clone(dragEl);\n      cloneEl.removeAttribute(\"id\");\n      cloneEl.draggable = false;\n      cloneEl.style['will-change'] = '';\n      this._hideClone();\n      toggleClass(cloneEl, this.options.chosenClass, false);\n      Sortable.clone = cloneEl;\n    }\n\n    // #1143: IFrame support workaround\n    _this.cloneId = _nextTick(function () {\n      pluginEvent('clone', _this);\n      if (Sortable.eventCanceled) return;\n      if (!_this.options.removeCloneOnHide) {\n        rootEl.insertBefore(cloneEl, dragEl);\n      }\n      _this._hideClone();\n      _dispatchEvent({\n        sortable: _this,\n        name: 'clone'\n      });\n    });\n    !fallback && toggleClass(dragEl, options.dragClass, true);\n\n    // Set proper drop events\n    if (fallback) {\n      ignoreNextClick = true;\n      _this._loopId = setInterval(_this._emulateDragOver, 50);\n    } else {\n      // Undo what was set in _prepareDragStart before drag started\n      off(document, 'mouseup', _this._onDrop);\n      off(document, 'touchend', _this._onDrop);\n      off(document, 'touchcancel', _this._onDrop);\n      if (dataTransfer) {\n        dataTransfer.effectAllowed = 'move';\n        options.setData && options.setData.call(_this, dataTransfer, dragEl);\n      }\n      on(document, 'drop', _this);\n\n      // #1276 fix:\n      css(dragEl, 'transform', 'translateZ(0)');\n    }\n    awaitingDragStarted = true;\n    _this._dragStartId = _nextTick(_this._dragStarted.bind(_this, fallback, evt));\n    on(document, 'selectstart', _this);\n    moved = true;\n    window.getSelection().removeAllRanges();\n    if (Safari) {\n      css(document.body, 'user-select', 'none');\n    }\n  },\n  // Returns true - if no further action is needed (either inserted or another condition)\n  _onDragOver: function _onDragOver( /**Event*/evt) {\n    var el = this.el,\n      target = evt.target,\n      dragRect,\n      targetRect,\n      revert,\n      options = this.options,\n      group = options.group,\n      activeSortable = Sortable.active,\n      isOwner = activeGroup === group,\n      canSort = options.sort,\n      fromSortable = putSortable || activeSortable,\n      vertical,\n      _this = this,\n      completedFired = false;\n    if (_silent) return;\n    function dragOverEvent(name, extra) {\n      pluginEvent(name, _this, _objectSpread2({\n        evt: evt,\n        isOwner: isOwner,\n        axis: vertical ? 'vertical' : 'horizontal',\n        revert: revert,\n        dragRect: dragRect,\n        targetRect: targetRect,\n        canSort: canSort,\n        fromSortable: fromSortable,\n        target: target,\n        completed: completed,\n        onMove: function onMove(target, after) {\n          return _onMove(rootEl, el, dragEl, dragRect, target, getRect(target), evt, after);\n        },\n        changed: changed\n      }, extra));\n    }\n\n    // Capture animation state\n    function capture() {\n      dragOverEvent('dragOverAnimationCapture');\n      _this.captureAnimationState();\n      if (_this !== fromSortable) {\n        fromSortable.captureAnimationState();\n      }\n    }\n\n    // Return invocation when dragEl is inserted (or completed)\n    function completed(insertion) {\n      dragOverEvent('dragOverCompleted', {\n        insertion: insertion\n      });\n      if (insertion) {\n        // Clones must be hidden before folding animation to capture dragRectAbsolute properly\n        if (isOwner) {\n          activeSortable._hideClone();\n        } else {\n          activeSortable._showClone(_this);\n        }\n        if (_this !== fromSortable) {\n          // Set ghost class to new sortable's ghost class\n          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : activeSortable.options.ghostClass, false);\n          toggleClass(dragEl, options.ghostClass, true);\n        }\n        if (putSortable !== _this && _this !== Sortable.active) {\n          putSortable = _this;\n        } else if (_this === Sortable.active && putSortable) {\n          putSortable = null;\n        }\n\n        // Animation\n        if (fromSortable === _this) {\n          _this._ignoreWhileAnimating = target;\n        }\n        _this.animateAll(function () {\n          dragOverEvent('dragOverAnimationComplete');\n          _this._ignoreWhileAnimating = null;\n        });\n        if (_this !== fromSortable) {\n          fromSortable.animateAll();\n          fromSortable._ignoreWhileAnimating = null;\n        }\n      }\n\n      // Null lastTarget if it is not inside a previously swapped element\n      if (target === dragEl && !dragEl.animated || target === el && !target.animated) {\n        lastTarget = null;\n      }\n\n      // no bubbling and not fallback\n      if (!options.dragoverBubble && !evt.rootEl && target !== document) {\n        dragEl.parentNode[expando]._isOutsideThisEl(evt.target);\n\n        // Do not detect for empty insert if already inserted\n        !insertion && nearestEmptyInsertDetectEvent(evt);\n      }\n      !options.dragoverBubble && evt.stopPropagation && evt.stopPropagation();\n      return completedFired = true;\n    }\n\n    // Call when dragEl has been inserted\n    function changed() {\n      newIndex = index(dragEl);\n      newDraggableIndex = index(dragEl, options.draggable);\n      _dispatchEvent({\n        sortable: _this,\n        name: 'change',\n        toEl: el,\n        newIndex: newIndex,\n        newDraggableIndex: newDraggableIndex,\n        originalEvent: evt\n      });\n    }\n    if (evt.preventDefault !== void 0) {\n      evt.cancelable && evt.preventDefault();\n    }\n    target = closest(target, options.draggable, el, true);\n    dragOverEvent('dragOver');\n    if (Sortable.eventCanceled) return completedFired;\n    if (dragEl.contains(evt.target) || target.animated && target.animatingX && target.animatingY || _this._ignoreWhileAnimating === target) {\n      return completed(false);\n    }\n    ignoreNextClick = false;\n    if (activeSortable && !options.disabled && (isOwner ? canSort || (revert = parentEl !== rootEl) // Reverting item into the original list\n    : putSortable === this || (this.lastPutMode = activeGroup.checkPull(this, activeSortable, dragEl, evt)) && group.checkPut(this, activeSortable, dragEl, evt))) {\n      vertical = this._getDirection(evt, target) === 'vertical';\n      dragRect = getRect(dragEl);\n      dragOverEvent('dragOverValid');\n      if (Sortable.eventCanceled) return completedFired;\n      if (revert) {\n        parentEl = rootEl; // actualization\n        capture();\n        this._hideClone();\n        dragOverEvent('revert');\n        if (!Sortable.eventCanceled) {\n          if (nextEl) {\n            rootEl.insertBefore(dragEl, nextEl);\n          } else {\n            rootEl.appendChild(dragEl);\n          }\n        }\n        return completed(true);\n      }\n      var elLastChild = lastChild(el, options.draggable);\n      if (!elLastChild || _ghostIsLast(evt, vertical, this) && !elLastChild.animated) {\n        // Insert to end of list\n\n        // If already at end of list: Do not insert\n        if (elLastChild === dragEl) {\n          return completed(false);\n        }\n\n        // if there is a last element, it is the target\n        if (elLastChild && el === evt.target) {\n          target = elLastChild;\n        }\n        if (target) {\n          targetRect = getRect(target);\n        }\n        if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, !!target) !== false) {\n          capture();\n          if (elLastChild && elLastChild.nextSibling) {\n            // the last draggable element is not the last node\n            el.insertBefore(dragEl, elLastChild.nextSibling);\n          } else {\n            el.appendChild(dragEl);\n          }\n          parentEl = el; // actualization\n\n          changed();\n          return completed(true);\n        }\n      } else if (elLastChild && _ghostIsFirst(evt, vertical, this)) {\n        // Insert to start of list\n        var firstChild = getChild(el, 0, options, true);\n        if (firstChild === dragEl) {\n          return completed(false);\n        }\n        target = firstChild;\n        targetRect = getRect(target);\n        if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, false) !== false) {\n          capture();\n          el.insertBefore(dragEl, firstChild);\n          parentEl = el; // actualization\n\n          changed();\n          return completed(true);\n        }\n      } else if (target.parentNode === el) {\n        targetRect = getRect(target);\n        var direction = 0,\n          targetBeforeFirstSwap,\n          differentLevel = dragEl.parentNode !== el,\n          differentRowCol = !_dragElInRowColumn(dragEl.animated && dragEl.toRect || dragRect, target.animated && target.toRect || targetRect, vertical),\n          side1 = vertical ? 'top' : 'left',\n          scrolledPastTop = isScrolledPast(target, 'top', 'top') || isScrolledPast(dragEl, 'top', 'top'),\n          scrollBefore = scrolledPastTop ? scrolledPastTop.scrollTop : void 0;\n        if (lastTarget !== target) {\n          targetBeforeFirstSwap = targetRect[side1];\n          pastFirstInvertThresh = false;\n          isCircumstantialInvert = !differentRowCol && options.invertSwap || differentLevel;\n        }\n        direction = _getSwapDirection(evt, target, targetRect, vertical, differentRowCol ? 1 : options.swapThreshold, options.invertedSwapThreshold == null ? options.swapThreshold : options.invertedSwapThreshold, isCircumstantialInvert, lastTarget === target);\n        var sibling;\n        if (direction !== 0) {\n          // Check if target is beside dragEl in respective direction (ignoring hidden elements)\n          var dragIndex = index(dragEl);\n          do {\n            dragIndex -= direction;\n            sibling = parentEl.children[dragIndex];\n          } while (sibling && (css(sibling, 'display') === 'none' || sibling === ghostEl));\n        }\n        // If dragEl is already beside target: Do not insert\n        if (direction === 0 || sibling === target) {\n          return completed(false);\n        }\n        lastTarget = target;\n        lastDirection = direction;\n        var nextSibling = target.nextElementSibling,\n          after = false;\n        after = direction === 1;\n        var moveVector = _onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, after);\n        if (moveVector !== false) {\n          if (moveVector === 1 || moveVector === -1) {\n            after = moveVector === 1;\n          }\n          _silent = true;\n          setTimeout(_unsilent, 30);\n          capture();\n          if (after && !nextSibling) {\n            el.appendChild(dragEl);\n          } else {\n            target.parentNode.insertBefore(dragEl, after ? nextSibling : target);\n          }\n\n          // Undo chrome's scroll adjustment (has no effect on other browsers)\n          if (scrolledPastTop) {\n            scrollBy(scrolledPastTop, 0, scrollBefore - scrolledPastTop.scrollTop);\n          }\n          parentEl = dragEl.parentNode; // actualization\n\n          // must be done before animation\n          if (targetBeforeFirstSwap !== undefined && !isCircumstantialInvert) {\n            targetMoveDistance = Math.abs(targetBeforeFirstSwap - getRect(target)[side1]);\n          }\n          changed();\n          return completed(true);\n        }\n      }\n      if (el.contains(dragEl)) {\n        return completed(false);\n      }\n    }\n    return false;\n  },\n  _ignoreWhileAnimating: null,\n  _offMoveEvents: function _offMoveEvents() {\n    off(document, 'mousemove', this._onTouchMove);\n    off(document, 'touchmove', this._onTouchMove);\n    off(document, 'pointermove', this._onTouchMove);\n    off(document, 'dragover', nearestEmptyInsertDetectEvent);\n    off(document, 'mousemove', nearestEmptyInsertDetectEvent);\n    off(document, 'touchmove', nearestEmptyInsertDetectEvent);\n  },\n  _offUpEvents: function _offUpEvents() {\n    var ownerDocument = this.el.ownerDocument;\n    off(ownerDocument, 'mouseup', this._onDrop);\n    off(ownerDocument, 'touchend', this._onDrop);\n    off(ownerDocument, 'pointerup', this._onDrop);\n    off(ownerDocument, 'pointercancel', this._onDrop);\n    off(ownerDocument, 'touchcancel', this._onDrop);\n    off(document, 'selectstart', this);\n  },\n  _onDrop: function _onDrop( /**Event*/evt) {\n    var el = this.el,\n      options = this.options;\n\n    // Get the index of the dragged element within its parent\n    newIndex = index(dragEl);\n    newDraggableIndex = index(dragEl, options.draggable);\n    pluginEvent('drop', this, {\n      evt: evt\n    });\n    parentEl = dragEl && dragEl.parentNode;\n\n    // Get again after plugin event\n    newIndex = index(dragEl);\n    newDraggableIndex = index(dragEl, options.draggable);\n    if (Sortable.eventCanceled) {\n      this._nulling();\n      return;\n    }\n    awaitingDragStarted = false;\n    isCircumstantialInvert = false;\n    pastFirstInvertThresh = false;\n    clearInterval(this._loopId);\n    clearTimeout(this._dragStartTimer);\n    _cancelNextTick(this.cloneId);\n    _cancelNextTick(this._dragStartId);\n\n    // Unbind events\n    if (this.nativeDraggable) {\n      off(document, 'drop', this);\n      off(el, 'dragstart', this._onDragStart);\n    }\n    this._offMoveEvents();\n    this._offUpEvents();\n    if (Safari) {\n      css(document.body, 'user-select', '');\n    }\n    css(dragEl, 'transform', '');\n    if (evt) {\n      if (moved) {\n        evt.cancelable && evt.preventDefault();\n        !options.dropBubble && evt.stopPropagation();\n      }\n      ghostEl && ghostEl.parentNode && ghostEl.parentNode.removeChild(ghostEl);\n      if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== 'clone') {\n        // Remove clone(s)\n        cloneEl && cloneEl.parentNode && cloneEl.parentNode.removeChild(cloneEl);\n      }\n      if (dragEl) {\n        if (this.nativeDraggable) {\n          off(dragEl, 'dragend', this);\n        }\n        _disableDraggable(dragEl);\n        dragEl.style['will-change'] = '';\n\n        // Remove classes\n        // ghostClass is added in dragStarted\n        if (moved && !awaitingDragStarted) {\n          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : this.options.ghostClass, false);\n        }\n        toggleClass(dragEl, this.options.chosenClass, false);\n\n        // Drag stop event\n        _dispatchEvent({\n          sortable: this,\n          name: 'unchoose',\n          toEl: parentEl,\n          newIndex: null,\n          newDraggableIndex: null,\n          originalEvent: evt\n        });\n        if (rootEl !== parentEl) {\n          if (newIndex >= 0) {\n            // Add event\n            _dispatchEvent({\n              rootEl: parentEl,\n              name: 'add',\n              toEl: parentEl,\n              fromEl: rootEl,\n              originalEvent: evt\n            });\n\n            // Remove event\n            _dispatchEvent({\n              sortable: this,\n              name: 'remove',\n              toEl: parentEl,\n              originalEvent: evt\n            });\n\n            // drag from one list and drop into another\n            _dispatchEvent({\n              rootEl: parentEl,\n              name: 'sort',\n              toEl: parentEl,\n              fromEl: rootEl,\n              originalEvent: evt\n            });\n            _dispatchEvent({\n              sortable: this,\n              name: 'sort',\n              toEl: parentEl,\n              originalEvent: evt\n            });\n          }\n          putSortable && putSortable.save();\n        } else {\n          if (newIndex !== oldIndex) {\n            if (newIndex >= 0) {\n              // drag & drop within the same list\n              _dispatchEvent({\n                sortable: this,\n                name: 'update',\n                toEl: parentEl,\n                originalEvent: evt\n              });\n              _dispatchEvent({\n                sortable: this,\n                name: 'sort',\n                toEl: parentEl,\n                originalEvent: evt\n              });\n            }\n          }\n        }\n        if (Sortable.active) {\n          /* jshint eqnull:true */\n          if (newIndex == null || newIndex === -1) {\n            newIndex = oldIndex;\n            newDraggableIndex = oldDraggableIndex;\n          }\n          _dispatchEvent({\n            sortable: this,\n            name: 'end',\n            toEl: parentEl,\n            originalEvent: evt\n          });\n\n          // Save sorting\n          this.save();\n        }\n      }\n    }\n    this._nulling();\n  },\n  _nulling: function _nulling() {\n    pluginEvent('nulling', this);\n    rootEl = dragEl = parentEl = ghostEl = nextEl = cloneEl = lastDownEl = cloneHidden = tapEvt = touchEvt = moved = newIndex = newDraggableIndex = oldIndex = oldDraggableIndex = lastTarget = lastDirection = putSortable = activeGroup = Sortable.dragged = Sortable.ghost = Sortable.clone = Sortable.active = null;\n    savedInputChecked.forEach(function (el) {\n      el.checked = true;\n    });\n    savedInputChecked.length = lastDx = lastDy = 0;\n  },\n  handleEvent: function handleEvent( /**Event*/evt) {\n    switch (evt.type) {\n      case 'drop':\n      case 'dragend':\n        this._onDrop(evt);\n        break;\n      case 'dragenter':\n      case 'dragover':\n        if (dragEl) {\n          this._onDragOver(evt);\n          _globalDragOver(evt);\n        }\n        break;\n      case 'selectstart':\n        evt.preventDefault();\n        break;\n    }\n  },\n  /**\r\n   * Serializes the item into an array of string.\r\n   * @returns {String[]}\r\n   */\n  toArray: function toArray() {\n    var order = [],\n      el,\n      children = this.el.children,\n      i = 0,\n      n = children.length,\n      options = this.options;\n    for (; i < n; i++) {\n      el = children[i];\n      if (closest(el, options.draggable, this.el, false)) {\n        order.push(el.getAttribute(options.dataIdAttr) || _generateId(el));\n      }\n    }\n    return order;\n  },\n  /**\r\n   * Sorts the elements according to the array.\r\n   * @param  {String[]}  order  order of the items\r\n   */\n  sort: function sort(order, useAnimation) {\n    var items = {},\n      rootEl = this.el;\n    this.toArray().forEach(function (id, i) {\n      var el = rootEl.children[i];\n      if (closest(el, this.options.draggable, rootEl, false)) {\n        items[id] = el;\n      }\n    }, this);\n    useAnimation && this.captureAnimationState();\n    order.forEach(function (id) {\n      if (items[id]) {\n        rootEl.removeChild(items[id]);\n        rootEl.appendChild(items[id]);\n      }\n    });\n    useAnimation && this.animateAll();\n  },\n  /**\r\n   * Save the current sorting\r\n   */\n  save: function save() {\n    var store = this.options.store;\n    store && store.set && store.set(this);\n  },\n  /**\r\n   * For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.\r\n   * @param   {HTMLElement}  el\r\n   * @param   {String}       [selector]  default: `options.draggable`\r\n   * @returns {HTMLElement|null}\r\n   */\n  closest: function closest$1(el, selector) {\n    return closest(el, selector || this.options.draggable, this.el, false);\n  },\n  /**\r\n   * Set/get option\r\n   * @param   {string} name\r\n   * @param   {*}      [value]\r\n   * @returns {*}\r\n   */\n  option: function option(name, value) {\n    var options = this.options;\n    if (value === void 0) {\n      return options[name];\n    } else {\n      var modifiedValue = PluginManager.modifyOption(this, name, value);\n      if (typeof modifiedValue !== 'undefined') {\n        options[name] = modifiedValue;\n      } else {\n        options[name] = value;\n      }\n      if (name === 'group') {\n        _prepareGroup(options);\n      }\n    }\n  },\n  /**\r\n   * Destroy\r\n   */\n  destroy: function destroy() {\n    pluginEvent('destroy', this);\n    var el = this.el;\n    el[expando] = null;\n    off(el, 'mousedown', this._onTapStart);\n    off(el, 'touchstart', this._onTapStart);\n    off(el, 'pointerdown', this._onTapStart);\n    if (this.nativeDraggable) {\n      off(el, 'dragover', this);\n      off(el, 'dragenter', this);\n    }\n    // Remove draggable attributes\n    Array.prototype.forEach.call(el.querySelectorAll('[draggable]'), function (el) {\n      el.removeAttribute('draggable');\n    });\n    this._onDrop();\n    this._disableDelayedDragEvents();\n    sortables.splice(sortables.indexOf(this.el), 1);\n    this.el = el = null;\n  },\n  _hideClone: function _hideClone() {\n    if (!cloneHidden) {\n      pluginEvent('hideClone', this);\n      if (Sortable.eventCanceled) return;\n      css(cloneEl, 'display', 'none');\n      if (this.options.removeCloneOnHide && cloneEl.parentNode) {\n        cloneEl.parentNode.removeChild(cloneEl);\n      }\n      cloneHidden = true;\n    }\n  },\n  _showClone: function _showClone(putSortable) {\n    if (putSortable.lastPutMode !== 'clone') {\n      this._hideClone();\n      return;\n    }\n    if (cloneHidden) {\n      pluginEvent('showClone', this);\n      if (Sortable.eventCanceled) return;\n\n      // show clone at dragEl or original position\n      if (dragEl.parentNode == rootEl && !this.options.group.revertClone) {\n        rootEl.insertBefore(cloneEl, dragEl);\n      } else if (nextEl) {\n        rootEl.insertBefore(cloneEl, nextEl);\n      } else {\n        rootEl.appendChild(cloneEl);\n      }\n      if (this.options.group.revertClone) {\n        this.animate(dragEl, cloneEl);\n      }\n      css(cloneEl, 'display', '');\n      cloneHidden = false;\n    }\n  }\n};\nfunction _globalDragOver( /**Event*/evt) {\n  if (evt.dataTransfer) {\n    evt.dataTransfer.dropEffect = 'move';\n  }\n  evt.cancelable && evt.preventDefault();\n}\nfunction _onMove(fromEl, toEl, dragEl, dragRect, targetEl, targetRect, originalEvent, willInsertAfter) {\n  var evt,\n    sortable = fromEl[expando],\n    onMoveFn = sortable.options.onMove,\n    retVal;\n  // Support for new CustomEvent feature\n  if (window.CustomEvent && !IE11OrLess && !Edge) {\n    evt = new CustomEvent('move', {\n      bubbles: true,\n      cancelable: true\n    });\n  } else {\n    evt = document.createEvent('Event');\n    evt.initEvent('move', true, true);\n  }\n  evt.to = toEl;\n  evt.from = fromEl;\n  evt.dragged = dragEl;\n  evt.draggedRect = dragRect;\n  evt.related = targetEl || toEl;\n  evt.relatedRect = targetRect || getRect(toEl);\n  evt.willInsertAfter = willInsertAfter;\n  evt.originalEvent = originalEvent;\n  fromEl.dispatchEvent(evt);\n  if (onMoveFn) {\n    retVal = onMoveFn.call(sortable, evt, originalEvent);\n  }\n  return retVal;\n}\nfunction _disableDraggable(el) {\n  el.draggable = false;\n}\nfunction _unsilent() {\n  _silent = false;\n}\nfunction _ghostIsFirst(evt, vertical, sortable) {\n  var firstElRect = getRect(getChild(sortable.el, 0, sortable.options, true));\n  var childContainingRect = getChildContainingRectFromElement(sortable.el, sortable.options, ghostEl);\n  var spacer = 10;\n  return vertical ? evt.clientX < childContainingRect.left - spacer || evt.clientY < firstElRect.top && evt.clientX < firstElRect.right : evt.clientY < childContainingRect.top - spacer || evt.clientY < firstElRect.bottom && evt.clientX < firstElRect.left;\n}\nfunction _ghostIsLast(evt, vertical, sortable) {\n  var lastElRect = getRect(lastChild(sortable.el, sortable.options.draggable));\n  var childContainingRect = getChildContainingRectFromElement(sortable.el, sortable.options, ghostEl);\n  var spacer = 10;\n  return vertical ? evt.clientX > childContainingRect.right + spacer || evt.clientY > lastElRect.bottom && evt.clientX > lastElRect.left : evt.clientY > childContainingRect.bottom + spacer || evt.clientX > lastElRect.right && evt.clientY > lastElRect.top;\n}\nfunction _getSwapDirection(evt, target, targetRect, vertical, swapThreshold, invertedSwapThreshold, invertSwap, isLastTarget) {\n  var mouseOnAxis = vertical ? evt.clientY : evt.clientX,\n    targetLength = vertical ? targetRect.height : targetRect.width,\n    targetS1 = vertical ? targetRect.top : targetRect.left,\n    targetS2 = vertical ? targetRect.bottom : targetRect.right,\n    invert = false;\n  if (!invertSwap) {\n    // Never invert or create dragEl shadow when target movemenet causes mouse to move past the end of regular swapThreshold\n    if (isLastTarget && targetMoveDistance < targetLength * swapThreshold) {\n      // multiplied only by swapThreshold because mouse will already be inside target by (1 - threshold) * targetLength / 2\n      // check if past first invert threshold on side opposite of lastDirection\n      if (!pastFirstInvertThresh && (lastDirection === 1 ? mouseOnAxis > targetS1 + targetLength * invertedSwapThreshold / 2 : mouseOnAxis < targetS2 - targetLength * invertedSwapThreshold / 2)) {\n        // past first invert threshold, do not restrict inverted threshold to dragEl shadow\n        pastFirstInvertThresh = true;\n      }\n      if (!pastFirstInvertThresh) {\n        // dragEl shadow (target move distance shadow)\n        if (lastDirection === 1 ? mouseOnAxis < targetS1 + targetMoveDistance // over dragEl shadow\n        : mouseOnAxis > targetS2 - targetMoveDistance) {\n          return -lastDirection;\n        }\n      } else {\n        invert = true;\n      }\n    } else {\n      // Regular\n      if (mouseOnAxis > targetS1 + targetLength * (1 - swapThreshold) / 2 && mouseOnAxis < targetS2 - targetLength * (1 - swapThreshold) / 2) {\n        return _getInsertDirection(target);\n      }\n    }\n  }\n  invert = invert || invertSwap;\n  if (invert) {\n    // Invert of regular\n    if (mouseOnAxis < targetS1 + targetLength * invertedSwapThreshold / 2 || mouseOnAxis > targetS2 - targetLength * invertedSwapThreshold / 2) {\n      return mouseOnAxis > targetS1 + targetLength / 2 ? 1 : -1;\n    }\n  }\n  return 0;\n}\n\n/**\r\n * Gets the direction dragEl must be swapped relative to target in order to make it\r\n * seem that dragEl has been \"inserted\" into that element's position\r\n * @param  {HTMLElement} target       The target whose position dragEl is being inserted at\r\n * @return {Number}                   Direction dragEl must be swapped\r\n */\nfunction _getInsertDirection(target) {\n  if (index(dragEl) < index(target)) {\n    return 1;\n  } else {\n    return -1;\n  }\n}\n\n/**\r\n * Generate id\r\n * @param   {HTMLElement} el\r\n * @returns {String}\r\n * @private\r\n */\nfunction _generateId(el) {\n  var str = el.tagName + el.className + el.src + el.href + el.textContent,\n    i = str.length,\n    sum = 0;\n  while (i--) {\n    sum += str.charCodeAt(i);\n  }\n  return sum.toString(36);\n}\nfunction _saveInputCheckedState(root) {\n  savedInputChecked.length = 0;\n  var inputs = root.getElementsByTagName('input');\n  var idx = inputs.length;\n  while (idx--) {\n    var el = inputs[idx];\n    el.checked && savedInputChecked.push(el);\n  }\n}\nfunction _nextTick(fn) {\n  return setTimeout(fn, 0);\n}\nfunction _cancelNextTick(id) {\n  return clearTimeout(id);\n}\n\n// Fixed #973:\nif (documentExists) {\n  on(document, 'touchmove', function (evt) {\n    if ((Sortable.active || awaitingDragStarted) && evt.cancelable) {\n      evt.preventDefault();\n    }\n  });\n}\n\n// Export utils\nSortable.utils = {\n  on: on,\n  off: off,\n  css: css,\n  find: find,\n  is: function is(el, selector) {\n    return !!closest(el, selector, el, false);\n  },\n  extend: extend,\n  throttle: throttle,\n  closest: closest,\n  toggleClass: toggleClass,\n  clone: clone,\n  index: index,\n  nextTick: _nextTick,\n  cancelNextTick: _cancelNextTick,\n  detectDirection: _detectDirection,\n  getChild: getChild,\n  expando: expando\n};\n\n/**\r\n * Get the Sortable instance of an element\r\n * @param  {HTMLElement} element The element\r\n * @return {Sortable|undefined}         The instance of Sortable\r\n */\nSortable.get = function (element) {\n  return element[expando];\n};\n\n/**\r\n * Mount a plugin to Sortable\r\n * @param  {...SortablePlugin|SortablePlugin[]} plugins       Plugins being mounted\r\n */\nSortable.mount = function () {\n  for (var _len = arguments.length, plugins = new Array(_len), _key = 0; _key < _len; _key++) {\n    plugins[_key] = arguments[_key];\n  }\n  if (plugins[0].constructor === Array) plugins = plugins[0];\n  plugins.forEach(function (plugin) {\n    if (!plugin.prototype || !plugin.prototype.constructor) {\n      throw \"Sortable: Mounted plugin must be a constructor function, not \".concat({}.toString.call(plugin));\n    }\n    if (plugin.utils) Sortable.utils = _objectSpread2(_objectSpread2({}, Sortable.utils), plugin.utils);\n    PluginManager.mount(plugin);\n  });\n};\n\n/**\r\n * Create sortable instance\r\n * @param {HTMLElement}  el\r\n * @param {Object}      [options]\r\n */\nSortable.create = function (el, options) {\n  return new Sortable(el, options);\n};\n\n// Export\nSortable.version = version;\n\nvar autoScrolls = [],\n  scrollEl,\n  scrollRootEl,\n  scrolling = false,\n  lastAutoScrollX,\n  lastAutoScrollY,\n  touchEvt$1,\n  pointerElemChangedInterval;\nfunction AutoScrollPlugin() {\n  function AutoScroll() {\n    this.defaults = {\n      scroll: true,\n      forceAutoScrollFallback: false,\n      scrollSensitivity: 30,\n      scrollSpeed: 10,\n      bubbleScroll: true\n    };\n\n    // Bind all private methods\n    for (var fn in this) {\n      if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {\n        this[fn] = this[fn].bind(this);\n      }\n    }\n  }\n  AutoScroll.prototype = {\n    dragStarted: function dragStarted(_ref) {\n      var originalEvent = _ref.originalEvent;\n      if (this.sortable.nativeDraggable) {\n        on(document, 'dragover', this._handleAutoScroll);\n      } else {\n        if (this.options.supportPointer) {\n          on(document, 'pointermove', this._handleFallbackAutoScroll);\n        } else if (originalEvent.touches) {\n          on(document, 'touchmove', this._handleFallbackAutoScroll);\n        } else {\n          on(document, 'mousemove', this._handleFallbackAutoScroll);\n        }\n      }\n    },\n    dragOverCompleted: function dragOverCompleted(_ref2) {\n      var originalEvent = _ref2.originalEvent;\n      // For when bubbling is canceled and using fallback (fallback 'touchmove' always reached)\n      if (!this.options.dragOverBubble && !originalEvent.rootEl) {\n        this._handleAutoScroll(originalEvent);\n      }\n    },\n    drop: function drop() {\n      if (this.sortable.nativeDraggable) {\n        off(document, 'dragover', this._handleAutoScroll);\n      } else {\n        off(document, 'pointermove', this._handleFallbackAutoScroll);\n        off(document, 'touchmove', this._handleFallbackAutoScroll);\n        off(document, 'mousemove', this._handleFallbackAutoScroll);\n      }\n      clearPointerElemChangedInterval();\n      clearAutoScrolls();\n      cancelThrottle();\n    },\n    nulling: function nulling() {\n      touchEvt$1 = scrollRootEl = scrollEl = scrolling = pointerElemChangedInterval = lastAutoScrollX = lastAutoScrollY = null;\n      autoScrolls.length = 0;\n    },\n    _handleFallbackAutoScroll: function _handleFallbackAutoScroll(evt) {\n      this._handleAutoScroll(evt, true);\n    },\n    _handleAutoScroll: function _handleAutoScroll(evt, fallback) {\n      var _this = this;\n      var x = (evt.touches ? evt.touches[0] : evt).clientX,\n        y = (evt.touches ? evt.touches[0] : evt).clientY,\n        elem = document.elementFromPoint(x, y);\n      touchEvt$1 = evt;\n\n      // IE does not seem to have native autoscroll,\n      // Edge's autoscroll seems too conditional,\n      // MACOS Safari does not have autoscroll,\n      // Firefox and Chrome are good\n      if (fallback || this.options.forceAutoScrollFallback || Edge || IE11OrLess || Safari) {\n        autoScroll(evt, this.options, elem, fallback);\n\n        // Listener for pointer element change\n        var ogElemScroller = getParentAutoScrollElement(elem, true);\n        if (scrolling && (!pointerElemChangedInterval || x !== lastAutoScrollX || y !== lastAutoScrollY)) {\n          pointerElemChangedInterval && clearPointerElemChangedInterval();\n          // Detect for pointer elem change, emulating native DnD behaviour\n          pointerElemChangedInterval = setInterval(function () {\n            var newElem = getParentAutoScrollElement(document.elementFromPoint(x, y), true);\n            if (newElem !== ogElemScroller) {\n              ogElemScroller = newElem;\n              clearAutoScrolls();\n            }\n            autoScroll(evt, _this.options, newElem, fallback);\n          }, 10);\n          lastAutoScrollX = x;\n          lastAutoScrollY = y;\n        }\n      } else {\n        // if DnD is enabled (and browser has good autoscrolling), first autoscroll will already scroll, so get parent autoscroll of first autoscroll\n        if (!this.options.bubbleScroll || getParentAutoScrollElement(elem, true) === getWindowScrollingElement()) {\n          clearAutoScrolls();\n          return;\n        }\n        autoScroll(evt, this.options, getParentAutoScrollElement(elem, false), false);\n      }\n    }\n  };\n  return _extends(AutoScroll, {\n    pluginName: 'scroll',\n    initializeByDefault: true\n  });\n}\nfunction clearAutoScrolls() {\n  autoScrolls.forEach(function (autoScroll) {\n    clearInterval(autoScroll.pid);\n  });\n  autoScrolls = [];\n}\nfunction clearPointerElemChangedInterval() {\n  clearInterval(pointerElemChangedInterval);\n}\nvar autoScroll = throttle(function (evt, options, rootEl, isFallback) {\n  // Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=505521\n  if (!options.scroll) return;\n  var x = (evt.touches ? evt.touches[0] : evt).clientX,\n    y = (evt.touches ? evt.touches[0] : evt).clientY,\n    sens = options.scrollSensitivity,\n    speed = options.scrollSpeed,\n    winScroller = getWindowScrollingElement();\n  var scrollThisInstance = false,\n    scrollCustomFn;\n\n  // New scroll root, set scrollEl\n  if (scrollRootEl !== rootEl) {\n    scrollRootEl = rootEl;\n    clearAutoScrolls();\n    scrollEl = options.scroll;\n    scrollCustomFn = options.scrollFn;\n    if (scrollEl === true) {\n      scrollEl = getParentAutoScrollElement(rootEl, true);\n    }\n  }\n  var layersOut = 0;\n  var currentParent = scrollEl;\n  do {\n    var el = currentParent,\n      rect = getRect(el),\n      top = rect.top,\n      bottom = rect.bottom,\n      left = rect.left,\n      right = rect.right,\n      width = rect.width,\n      height = rect.height,\n      canScrollX = void 0,\n      canScrollY = void 0,\n      scrollWidth = el.scrollWidth,\n      scrollHeight = el.scrollHeight,\n      elCSS = css(el),\n      scrollPosX = el.scrollLeft,\n      scrollPosY = el.scrollTop;\n    if (el === winScroller) {\n      canScrollX = width < scrollWidth && (elCSS.overflowX === 'auto' || elCSS.overflowX === 'scroll' || elCSS.overflowX === 'visible');\n      canScrollY = height < scrollHeight && (elCSS.overflowY === 'auto' || elCSS.overflowY === 'scroll' || elCSS.overflowY === 'visible');\n    } else {\n      canScrollX = width < scrollWidth && (elCSS.overflowX === 'auto' || elCSS.overflowX === 'scroll');\n      canScrollY = height < scrollHeight && (elCSS.overflowY === 'auto' || elCSS.overflowY === 'scroll');\n    }\n    var vx = canScrollX && (Math.abs(right - x) <= sens && scrollPosX + width < scrollWidth) - (Math.abs(left - x) <= sens && !!scrollPosX);\n    var vy = canScrollY && (Math.abs(bottom - y) <= sens && scrollPosY + height < scrollHeight) - (Math.abs(top - y) <= sens && !!scrollPosY);\n    if (!autoScrolls[layersOut]) {\n      for (var i = 0; i <= layersOut; i++) {\n        if (!autoScrolls[i]) {\n          autoScrolls[i] = {};\n        }\n      }\n    }\n    if (autoScrolls[layersOut].vx != vx || autoScrolls[layersOut].vy != vy || autoScrolls[layersOut].el !== el) {\n      autoScrolls[layersOut].el = el;\n      autoScrolls[layersOut].vx = vx;\n      autoScrolls[layersOut].vy = vy;\n      clearInterval(autoScrolls[layersOut].pid);\n      if (vx != 0 || vy != 0) {\n        scrollThisInstance = true;\n        /* jshint loopfunc:true */\n        autoScrolls[layersOut].pid = setInterval(function () {\n          // emulate drag over during autoscroll (fallback), emulating native DnD behaviour\n          if (isFallback && this.layer === 0) {\n            Sortable.active._onTouchMove(touchEvt$1); // To move ghost if it is positioned absolutely\n          }\n          var scrollOffsetY = autoScrolls[this.layer].vy ? autoScrolls[this.layer].vy * speed : 0;\n          var scrollOffsetX = autoScrolls[this.layer].vx ? autoScrolls[this.layer].vx * speed : 0;\n          if (typeof scrollCustomFn === 'function') {\n            if (scrollCustomFn.call(Sortable.dragged.parentNode[expando], scrollOffsetX, scrollOffsetY, evt, touchEvt$1, autoScrolls[this.layer].el) !== 'continue') {\n              return;\n            }\n          }\n          scrollBy(autoScrolls[this.layer].el, scrollOffsetX, scrollOffsetY);\n        }.bind({\n          layer: layersOut\n        }), 24);\n      }\n    }\n    layersOut++;\n  } while (options.bubbleScroll && currentParent !== winScroller && (currentParent = getParentAutoScrollElement(currentParent, false)));\n  scrolling = scrollThisInstance; // in case another function catches scrolling as false in between when it is not\n}, 30);\n\nvar drop = function drop(_ref) {\n  var originalEvent = _ref.originalEvent,\n    putSortable = _ref.putSortable,\n    dragEl = _ref.dragEl,\n    activeSortable = _ref.activeSortable,\n    dispatchSortableEvent = _ref.dispatchSortableEvent,\n    hideGhostForTarget = _ref.hideGhostForTarget,\n    unhideGhostForTarget = _ref.unhideGhostForTarget;\n  if (!originalEvent) return;\n  var toSortable = putSortable || activeSortable;\n  hideGhostForTarget();\n  var touch = originalEvent.changedTouches && originalEvent.changedTouches.length ? originalEvent.changedTouches[0] : originalEvent;\n  var target = document.elementFromPoint(touch.clientX, touch.clientY);\n  unhideGhostForTarget();\n  if (toSortable && !toSortable.el.contains(target)) {\n    dispatchSortableEvent('spill');\n    this.onSpill({\n      dragEl: dragEl,\n      putSortable: putSortable\n    });\n  }\n};\nfunction Revert() {}\nRevert.prototype = {\n  startIndex: null,\n  dragStart: function dragStart(_ref2) {\n    var oldDraggableIndex = _ref2.oldDraggableIndex;\n    this.startIndex = oldDraggableIndex;\n  },\n  onSpill: function onSpill(_ref3) {\n    var dragEl = _ref3.dragEl,\n      putSortable = _ref3.putSortable;\n    this.sortable.captureAnimationState();\n    if (putSortable) {\n      putSortable.captureAnimationState();\n    }\n    var nextSibling = getChild(this.sortable.el, this.startIndex, this.options);\n    if (nextSibling) {\n      this.sortable.el.insertBefore(dragEl, nextSibling);\n    } else {\n      this.sortable.el.appendChild(dragEl);\n    }\n    this.sortable.animateAll();\n    if (putSortable) {\n      putSortable.animateAll();\n    }\n  },\n  drop: drop\n};\n_extends(Revert, {\n  pluginName: 'revertOnSpill'\n});\nfunction Remove() {}\nRemove.prototype = {\n  onSpill: function onSpill(_ref4) {\n    var dragEl = _ref4.dragEl,\n      putSortable = _ref4.putSortable;\n    var parentSortable = putSortable || this.sortable;\n    parentSortable.captureAnimationState();\n    dragEl.parentNode && dragEl.parentNode.removeChild(dragEl);\n    parentSortable.animateAll();\n  },\n  drop: drop\n};\n_extends(Remove, {\n  pluginName: 'removeOnSpill'\n});\n\nvar lastSwapEl;\nfunction SwapPlugin() {\n  function Swap() {\n    this.defaults = {\n      swapClass: 'sortable-swap-highlight'\n    };\n  }\n  Swap.prototype = {\n    dragStart: function dragStart(_ref) {\n      var dragEl = _ref.dragEl;\n      lastSwapEl = dragEl;\n    },\n    dragOverValid: function dragOverValid(_ref2) {\n      var completed = _ref2.completed,\n        target = _ref2.target,\n        onMove = _ref2.onMove,\n        activeSortable = _ref2.activeSortable,\n        changed = _ref2.changed,\n        cancel = _ref2.cancel;\n      if (!activeSortable.options.swap) return;\n      var el = this.sortable.el,\n        options = this.options;\n      if (target && target !== el) {\n        var prevSwapEl = lastSwapEl;\n        if (onMove(target) !== false) {\n          toggleClass(target, options.swapClass, true);\n          lastSwapEl = target;\n        } else {\n          lastSwapEl = null;\n        }\n        if (prevSwapEl && prevSwapEl !== lastSwapEl) {\n          toggleClass(prevSwapEl, options.swapClass, false);\n        }\n      }\n      changed();\n      completed(true);\n      cancel();\n    },\n    drop: function drop(_ref3) {\n      var activeSortable = _ref3.activeSortable,\n        putSortable = _ref3.putSortable,\n        dragEl = _ref3.dragEl;\n      var toSortable = putSortable || this.sortable;\n      var options = this.options;\n      lastSwapEl && toggleClass(lastSwapEl, options.swapClass, false);\n      if (lastSwapEl && (options.swap || putSortable && putSortable.options.swap)) {\n        if (dragEl !== lastSwapEl) {\n          toSortable.captureAnimationState();\n          if (toSortable !== activeSortable) activeSortable.captureAnimationState();\n          swapNodes(dragEl, lastSwapEl);\n          toSortable.animateAll();\n          if (toSortable !== activeSortable) activeSortable.animateAll();\n        }\n      }\n    },\n    nulling: function nulling() {\n      lastSwapEl = null;\n    }\n  };\n  return _extends(Swap, {\n    pluginName: 'swap',\n    eventProperties: function eventProperties() {\n      return {\n        swapItem: lastSwapEl\n      };\n    }\n  });\n}\nfunction swapNodes(n1, n2) {\n  var p1 = n1.parentNode,\n    p2 = n2.parentNode,\n    i1,\n    i2;\n  if (!p1 || !p2 || p1.isEqualNode(n2) || p2.isEqualNode(n1)) return;\n  i1 = index(n1);\n  i2 = index(n2);\n  if (p1.isEqualNode(p2) && i1 < i2) {\n    i2++;\n  }\n  p1.insertBefore(n2, p1.children[i1]);\n  p2.insertBefore(n1, p2.children[i2]);\n}\n\nvar multiDragElements = [],\n  multiDragClones = [],\n  lastMultiDragSelect,\n  // for selection with modifier key down (SHIFT)\n  multiDragSortable,\n  initialFolding = false,\n  // Initial multi-drag fold when drag started\n  folding = false,\n  // Folding any other time\n  dragStarted = false,\n  dragEl$1,\n  clonesFromRect,\n  clonesHidden;\nfunction MultiDragPlugin() {\n  function MultiDrag(sortable) {\n    // Bind all private methods\n    for (var fn in this) {\n      if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {\n        this[fn] = this[fn].bind(this);\n      }\n    }\n    if (!sortable.options.avoidImplicitDeselect) {\n      if (sortable.options.supportPointer) {\n        on(document, 'pointerup', this._deselectMultiDrag);\n      } else {\n        on(document, 'mouseup', this._deselectMultiDrag);\n        on(document, 'touchend', this._deselectMultiDrag);\n      }\n    }\n    on(document, 'keydown', this._checkKeyDown);\n    on(document, 'keyup', this._checkKeyUp);\n    this.defaults = {\n      selectedClass: 'sortable-selected',\n      multiDragKey: null,\n      avoidImplicitDeselect: false,\n      setData: function setData(dataTransfer, dragEl) {\n        var data = '';\n        if (multiDragElements.length && multiDragSortable === sortable) {\n          multiDragElements.forEach(function (multiDragElement, i) {\n            data += (!i ? '' : ', ') + multiDragElement.textContent;\n          });\n        } else {\n          data = dragEl.textContent;\n        }\n        dataTransfer.setData('Text', data);\n      }\n    };\n  }\n  MultiDrag.prototype = {\n    multiDragKeyDown: false,\n    isMultiDrag: false,\n    delayStartGlobal: function delayStartGlobal(_ref) {\n      var dragged = _ref.dragEl;\n      dragEl$1 = dragged;\n    },\n    delayEnded: function delayEnded() {\n      this.isMultiDrag = ~multiDragElements.indexOf(dragEl$1);\n    },\n    setupClone: function setupClone(_ref2) {\n      var sortable = _ref2.sortable,\n        cancel = _ref2.cancel;\n      if (!this.isMultiDrag) return;\n      for (var i = 0; i < multiDragElements.length; i++) {\n        multiDragClones.push(clone(multiDragElements[i]));\n        multiDragClones[i].sortableIndex = multiDragElements[i].sortableIndex;\n        multiDragClones[i].draggable = false;\n        multiDragClones[i].style['will-change'] = '';\n        toggleClass(multiDragClones[i], this.options.selectedClass, false);\n        multiDragElements[i] === dragEl$1 && toggleClass(multiDragClones[i], this.options.chosenClass, false);\n      }\n      sortable._hideClone();\n      cancel();\n    },\n    clone: function clone(_ref3) {\n      var sortable = _ref3.sortable,\n        rootEl = _ref3.rootEl,\n        dispatchSortableEvent = _ref3.dispatchSortableEvent,\n        cancel = _ref3.cancel;\n      if (!this.isMultiDrag) return;\n      if (!this.options.removeCloneOnHide) {\n        if (multiDragElements.length && multiDragSortable === sortable) {\n          insertMultiDragClones(true, rootEl);\n          dispatchSortableEvent('clone');\n          cancel();\n        }\n      }\n    },\n    showClone: function showClone(_ref4) {\n      var cloneNowShown = _ref4.cloneNowShown,\n        rootEl = _ref4.rootEl,\n        cancel = _ref4.cancel;\n      if (!this.isMultiDrag) return;\n      insertMultiDragClones(false, rootEl);\n      multiDragClones.forEach(function (clone) {\n        css(clone, 'display', '');\n      });\n      cloneNowShown();\n      clonesHidden = false;\n      cancel();\n    },\n    hideClone: function hideClone(_ref5) {\n      var _this = this;\n      var sortable = _ref5.sortable,\n        cloneNowHidden = _ref5.cloneNowHidden,\n        cancel = _ref5.cancel;\n      if (!this.isMultiDrag) return;\n      multiDragClones.forEach(function (clone) {\n        css(clone, 'display', 'none');\n        if (_this.options.removeCloneOnHide && clone.parentNode) {\n          clone.parentNode.removeChild(clone);\n        }\n      });\n      cloneNowHidden();\n      clonesHidden = true;\n      cancel();\n    },\n    dragStartGlobal: function dragStartGlobal(_ref6) {\n      var sortable = _ref6.sortable;\n      if (!this.isMultiDrag && multiDragSortable) {\n        multiDragSortable.multiDrag._deselectMultiDrag();\n      }\n      multiDragElements.forEach(function (multiDragElement) {\n        multiDragElement.sortableIndex = index(multiDragElement);\n      });\n\n      // Sort multi-drag elements\n      multiDragElements = multiDragElements.sort(function (a, b) {\n        return a.sortableIndex - b.sortableIndex;\n      });\n      dragStarted = true;\n    },\n    dragStarted: function dragStarted(_ref7) {\n      var _this2 = this;\n      var sortable = _ref7.sortable;\n      if (!this.isMultiDrag) return;\n      if (this.options.sort) {\n        // Capture rects,\n        // hide multi drag elements (by positioning them absolute),\n        // set multi drag elements rects to dragRect,\n        // show multi drag elements,\n        // animate to rects,\n        // unset rects & remove from DOM\n\n        sortable.captureAnimationState();\n        if (this.options.animation) {\n          multiDragElements.forEach(function (multiDragElement) {\n            if (multiDragElement === dragEl$1) return;\n            css(multiDragElement, 'position', 'absolute');\n          });\n          var dragRect = getRect(dragEl$1, false, true, true);\n          multiDragElements.forEach(function (multiDragElement) {\n            if (multiDragElement === dragEl$1) return;\n            setRect(multiDragElement, dragRect);\n          });\n          folding = true;\n          initialFolding = true;\n        }\n      }\n      sortable.animateAll(function () {\n        folding = false;\n        initialFolding = false;\n        if (_this2.options.animation) {\n          multiDragElements.forEach(function (multiDragElement) {\n            unsetRect(multiDragElement);\n          });\n        }\n\n        // Remove all auxiliary multidrag items from el, if sorting enabled\n        if (_this2.options.sort) {\n          removeMultiDragElements();\n        }\n      });\n    },\n    dragOver: function dragOver(_ref8) {\n      var target = _ref8.target,\n        completed = _ref8.completed,\n        cancel = _ref8.cancel;\n      if (folding && ~multiDragElements.indexOf(target)) {\n        completed(false);\n        cancel();\n      }\n    },\n    revert: function revert(_ref9) {\n      var fromSortable = _ref9.fromSortable,\n        rootEl = _ref9.rootEl,\n        sortable = _ref9.sortable,\n        dragRect = _ref9.dragRect;\n      if (multiDragElements.length > 1) {\n        // Setup unfold animation\n        multiDragElements.forEach(function (multiDragElement) {\n          sortable.addAnimationState({\n            target: multiDragElement,\n            rect: folding ? getRect(multiDragElement) : dragRect\n          });\n          unsetRect(multiDragElement);\n          multiDragElement.fromRect = dragRect;\n          fromSortable.removeAnimationState(multiDragElement);\n        });\n        folding = false;\n        insertMultiDragElements(!this.options.removeCloneOnHide, rootEl);\n      }\n    },\n    dragOverCompleted: function dragOverCompleted(_ref10) {\n      var sortable = _ref10.sortable,\n        isOwner = _ref10.isOwner,\n        insertion = _ref10.insertion,\n        activeSortable = _ref10.activeSortable,\n        parentEl = _ref10.parentEl,\n        putSortable = _ref10.putSortable;\n      var options = this.options;\n      if (insertion) {\n        // Clones must be hidden before folding animation to capture dragRectAbsolute properly\n        if (isOwner) {\n          activeSortable._hideClone();\n        }\n        initialFolding = false;\n        // If leaving sort:false root, or already folding - Fold to new location\n        if (options.animation && multiDragElements.length > 1 && (folding || !isOwner && !activeSortable.options.sort && !putSortable)) {\n          // Fold: Set all multi drag elements's rects to dragEl's rect when multi-drag elements are invisible\n          var dragRectAbsolute = getRect(dragEl$1, false, true, true);\n          multiDragElements.forEach(function (multiDragElement) {\n            if (multiDragElement === dragEl$1) return;\n            setRect(multiDragElement, dragRectAbsolute);\n\n            // Move element(s) to end of parentEl so that it does not interfere with multi-drag clones insertion if they are inserted\n            // while folding, and so that we can capture them again because old sortable will no longer be fromSortable\n            parentEl.appendChild(multiDragElement);\n          });\n          folding = true;\n        }\n\n        // Clones must be shown (and check to remove multi drags) after folding when interfering multiDragElements are moved out\n        if (!isOwner) {\n          // Only remove if not folding (folding will remove them anyways)\n          if (!folding) {\n            removeMultiDragElements();\n          }\n          if (multiDragElements.length > 1) {\n            var clonesHiddenBefore = clonesHidden;\n            activeSortable._showClone(sortable);\n\n            // Unfold animation for clones if showing from hidden\n            if (activeSortable.options.animation && !clonesHidden && clonesHiddenBefore) {\n              multiDragClones.forEach(function (clone) {\n                activeSortable.addAnimationState({\n                  target: clone,\n                  rect: clonesFromRect\n                });\n                clone.fromRect = clonesFromRect;\n                clone.thisAnimationDuration = null;\n              });\n            }\n          } else {\n            activeSortable._showClone(sortable);\n          }\n        }\n      }\n    },\n    dragOverAnimationCapture: function dragOverAnimationCapture(_ref11) {\n      var dragRect = _ref11.dragRect,\n        isOwner = _ref11.isOwner,\n        activeSortable = _ref11.activeSortable;\n      multiDragElements.forEach(function (multiDragElement) {\n        multiDragElement.thisAnimationDuration = null;\n      });\n      if (activeSortable.options.animation && !isOwner && activeSortable.multiDrag.isMultiDrag) {\n        clonesFromRect = _extends({}, dragRect);\n        var dragMatrix = matrix(dragEl$1, true);\n        clonesFromRect.top -= dragMatrix.f;\n        clonesFromRect.left -= dragMatrix.e;\n      }\n    },\n    dragOverAnimationComplete: function dragOverAnimationComplete() {\n      if (folding) {\n        folding = false;\n        removeMultiDragElements();\n      }\n    },\n    drop: function drop(_ref12) {\n      var evt = _ref12.originalEvent,\n        rootEl = _ref12.rootEl,\n        parentEl = _ref12.parentEl,\n        sortable = _ref12.sortable,\n        dispatchSortableEvent = _ref12.dispatchSortableEvent,\n        oldIndex = _ref12.oldIndex,\n        putSortable = _ref12.putSortable;\n      var toSortable = putSortable || this.sortable;\n      if (!evt) return;\n      var options = this.options,\n        children = parentEl.children;\n\n      // Multi-drag selection\n      if (!dragStarted) {\n        if (options.multiDragKey && !this.multiDragKeyDown) {\n          this._deselectMultiDrag();\n        }\n        toggleClass(dragEl$1, options.selectedClass, !~multiDragElements.indexOf(dragEl$1));\n        if (!~multiDragElements.indexOf(dragEl$1)) {\n          multiDragElements.push(dragEl$1);\n          dispatchEvent({\n            sortable: sortable,\n            rootEl: rootEl,\n            name: 'select',\n            targetEl: dragEl$1,\n            originalEvent: evt\n          });\n\n          // Modifier activated, select from last to dragEl\n          if (evt.shiftKey && lastMultiDragSelect && sortable.el.contains(lastMultiDragSelect)) {\n            var lastIndex = index(lastMultiDragSelect),\n              currentIndex = index(dragEl$1);\n            if (~lastIndex && ~currentIndex && lastIndex !== currentIndex) {\n              (function () {\n                // Must include lastMultiDragSelect (select it), in case modified selection from no selection\n                // (but previous selection existed)\n                var n, i;\n                if (currentIndex > lastIndex) {\n                  i = lastIndex;\n                  n = currentIndex;\n                } else {\n                  i = currentIndex;\n                  n = lastIndex + 1;\n                }\n                var filter = options.filter;\n                for (; i < n; i++) {\n                  if (~multiDragElements.indexOf(children[i])) continue;\n                  // Check if element is draggable\n                  if (!closest(children[i], options.draggable, parentEl, false)) continue;\n                  // Check if element is filtered\n                  var filtered = filter && (typeof filter === 'function' ? filter.call(sortable, evt, children[i], sortable) : filter.split(',').some(function (criteria) {\n                    return closest(children[i], criteria.trim(), parentEl, false);\n                  }));\n                  if (filtered) continue;\n                  toggleClass(children[i], options.selectedClass, true);\n                  multiDragElements.push(children[i]);\n                  dispatchEvent({\n                    sortable: sortable,\n                    rootEl: rootEl,\n                    name: 'select',\n                    targetEl: children[i],\n                    originalEvent: evt\n                  });\n                }\n              })();\n            }\n          } else {\n            lastMultiDragSelect = dragEl$1;\n          }\n          multiDragSortable = toSortable;\n        } else {\n          multiDragElements.splice(multiDragElements.indexOf(dragEl$1), 1);\n          lastMultiDragSelect = null;\n          dispatchEvent({\n            sortable: sortable,\n            rootEl: rootEl,\n            name: 'deselect',\n            targetEl: dragEl$1,\n            originalEvent: evt\n          });\n        }\n      }\n\n      // Multi-drag drop\n      if (dragStarted && this.isMultiDrag) {\n        folding = false;\n        // Do not \"unfold\" after around dragEl if reverted\n        if ((parentEl[expando].options.sort || parentEl !== rootEl) && multiDragElements.length > 1) {\n          var dragRect = getRect(dragEl$1),\n            multiDragIndex = index(dragEl$1, ':not(.' + this.options.selectedClass + ')');\n          if (!initialFolding && options.animation) dragEl$1.thisAnimationDuration = null;\n          toSortable.captureAnimationState();\n          if (!initialFolding) {\n            if (options.animation) {\n              dragEl$1.fromRect = dragRect;\n              multiDragElements.forEach(function (multiDragElement) {\n                multiDragElement.thisAnimationDuration = null;\n                if (multiDragElement !== dragEl$1) {\n                  var rect = folding ? getRect(multiDragElement) : dragRect;\n                  multiDragElement.fromRect = rect;\n\n                  // Prepare unfold animation\n                  toSortable.addAnimationState({\n                    target: multiDragElement,\n                    rect: rect\n                  });\n                }\n              });\n            }\n\n            // Multi drag elements are not necessarily removed from the DOM on drop, so to reinsert\n            // properly they must all be removed\n            removeMultiDragElements();\n            multiDragElements.forEach(function (multiDragElement) {\n              if (children[multiDragIndex]) {\n                parentEl.insertBefore(multiDragElement, children[multiDragIndex]);\n              } else {\n                parentEl.appendChild(multiDragElement);\n              }\n              multiDragIndex++;\n            });\n\n            // If initial folding is done, the elements may have changed position because they are now\n            // unfolding around dragEl, even though dragEl may not have his index changed, so update event\n            // must be fired here as Sortable will not.\n            if (oldIndex === index(dragEl$1)) {\n              var update = false;\n              multiDragElements.forEach(function (multiDragElement) {\n                if (multiDragElement.sortableIndex !== index(multiDragElement)) {\n                  update = true;\n                  return;\n                }\n              });\n              if (update) {\n                dispatchSortableEvent('update');\n                dispatchSortableEvent('sort');\n              }\n            }\n          }\n\n          // Must be done after capturing individual rects (scroll bar)\n          multiDragElements.forEach(function (multiDragElement) {\n            unsetRect(multiDragElement);\n          });\n          toSortable.animateAll();\n        }\n        multiDragSortable = toSortable;\n      }\n\n      // Remove clones if necessary\n      if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== 'clone') {\n        multiDragClones.forEach(function (clone) {\n          clone.parentNode && clone.parentNode.removeChild(clone);\n        });\n      }\n    },\n    nullingGlobal: function nullingGlobal() {\n      this.isMultiDrag = dragStarted = false;\n      multiDragClones.length = 0;\n    },\n    destroyGlobal: function destroyGlobal() {\n      this._deselectMultiDrag();\n      off(document, 'pointerup', this._deselectMultiDrag);\n      off(document, 'mouseup', this._deselectMultiDrag);\n      off(document, 'touchend', this._deselectMultiDrag);\n      off(document, 'keydown', this._checkKeyDown);\n      off(document, 'keyup', this._checkKeyUp);\n    },\n    _deselectMultiDrag: function _deselectMultiDrag(evt) {\n      if (typeof dragStarted !== \"undefined\" && dragStarted) return;\n\n      // Only deselect if selection is in this sortable\n      if (multiDragSortable !== this.sortable) return;\n\n      // Only deselect if target is not item in this sortable\n      if (evt && closest(evt.target, this.options.draggable, this.sortable.el, false)) return;\n\n      // Only deselect if left click\n      if (evt && evt.button !== 0) return;\n      while (multiDragElements.length) {\n        var el = multiDragElements[0];\n        toggleClass(el, this.options.selectedClass, false);\n        multiDragElements.shift();\n        dispatchEvent({\n          sortable: this.sortable,\n          rootEl: this.sortable.el,\n          name: 'deselect',\n          targetEl: el,\n          originalEvent: evt\n        });\n      }\n    },\n    _checkKeyDown: function _checkKeyDown(evt) {\n      if (evt.key === this.options.multiDragKey) {\n        this.multiDragKeyDown = true;\n      }\n    },\n    _checkKeyUp: function _checkKeyUp(evt) {\n      if (evt.key === this.options.multiDragKey) {\n        this.multiDragKeyDown = false;\n      }\n    }\n  };\n  return _extends(MultiDrag, {\n    // Static methods & properties\n    pluginName: 'multiDrag',\n    utils: {\n      /**\r\n       * Selects the provided multi-drag item\r\n       * @param  {HTMLElement} el    The element to be selected\r\n       */\n      select: function select(el) {\n        var sortable = el.parentNode[expando];\n        if (!sortable || !sortable.options.multiDrag || ~multiDragElements.indexOf(el)) return;\n        if (multiDragSortable && multiDragSortable !== sortable) {\n          multiDragSortable.multiDrag._deselectMultiDrag();\n          multiDragSortable = sortable;\n        }\n        toggleClass(el, sortable.options.selectedClass, true);\n        multiDragElements.push(el);\n      },\n      /**\r\n       * Deselects the provided multi-drag item\r\n       * @param  {HTMLElement} el    The element to be deselected\r\n       */\n      deselect: function deselect(el) {\n        var sortable = el.parentNode[expando],\n          index = multiDragElements.indexOf(el);\n        if (!sortable || !sortable.options.multiDrag || !~index) return;\n        toggleClass(el, sortable.options.selectedClass, false);\n        multiDragElements.splice(index, 1);\n      }\n    },\n    eventProperties: function eventProperties() {\n      var _this3 = this;\n      var oldIndicies = [],\n        newIndicies = [];\n      multiDragElements.forEach(function (multiDragElement) {\n        oldIndicies.push({\n          multiDragElement: multiDragElement,\n          index: multiDragElement.sortableIndex\n        });\n\n        // multiDragElements will already be sorted if folding\n        var newIndex;\n        if (folding && multiDragElement !== dragEl$1) {\n          newIndex = -1;\n        } else if (folding) {\n          newIndex = index(multiDragElement, ':not(.' + _this3.options.selectedClass + ')');\n        } else {\n          newIndex = index(multiDragElement);\n        }\n        newIndicies.push({\n          multiDragElement: multiDragElement,\n          index: newIndex\n        });\n      });\n      return {\n        items: _toConsumableArray(multiDragElements),\n        clones: [].concat(multiDragClones),\n        oldIndicies: oldIndicies,\n        newIndicies: newIndicies\n      };\n    },\n    optionListeners: {\n      multiDragKey: function multiDragKey(key) {\n        key = key.toLowerCase();\n        if (key === 'ctrl') {\n          key = 'Control';\n        } else if (key.length > 1) {\n          key = key.charAt(0).toUpperCase() + key.substr(1);\n        }\n        return key;\n      }\n    }\n  });\n}\nfunction insertMultiDragElements(clonesInserted, rootEl) {\n  multiDragElements.forEach(function (multiDragElement, i) {\n    var target = rootEl.children[multiDragElement.sortableIndex + (clonesInserted ? Number(i) : 0)];\n    if (target) {\n      rootEl.insertBefore(multiDragElement, target);\n    } else {\n      rootEl.appendChild(multiDragElement);\n    }\n  });\n}\n\n/**\r\n * Insert multi-drag clones\r\n * @param  {[Boolean]} elementsInserted  Whether the multi-drag elements are inserted\r\n * @param  {HTMLElement} rootEl\r\n */\nfunction insertMultiDragClones(elementsInserted, rootEl) {\n  multiDragClones.forEach(function (clone, i) {\n    var target = rootEl.children[clone.sortableIndex + (elementsInserted ? Number(i) : 0)];\n    if (target) {\n      rootEl.insertBefore(clone, target);\n    } else {\n      rootEl.appendChild(clone);\n    }\n  });\n}\nfunction removeMultiDragElements() {\n  multiDragElements.forEach(function (multiDragElement) {\n    if (multiDragElement === dragEl$1) return;\n    multiDragElement.parentNode && multiDragElement.parentNode.removeChild(multiDragElement);\n  });\n}\n\nSortable.mount(new AutoScrollPlugin());\nSortable.mount(Remove, Revert);\n\nexport default Sortable;\nexport { MultiDragPlugin as MultiDrag, Sortable, SwapPlugin as Swap };\n","/**\n * v-sort Directives\n *\n * Drag & Drop sorting using SortableJS.\n * Integrates SortableJS for drag-and-drop functionality.\n *\n * Usage:\n *   Server-side (calls PHP method):\n *   <ul v-sort=\"'reorder'\">\n *       <li v-for=\"item in items\" :key=\"item.id\" v-sort-item=\"item.id\">\n *           <span v-sort-handle>â‹®â‹®</span>\n *           {{ item.name }}\n *           <button v-sort-ignore>Delete</button>\n *       </li>\n *   </ul>\n *\n *   Client-side only (reorders Vue array locally):\n *   <div v-sort=\"items\">\n *       <div v-for=\"(item, index) in items\" :key=\"index\" v-sort-item=\"index\">...</div>\n *   </div>\n *\n *   Cross-list (Kanban):\n *   <ul v-sort=\"'reorderTodo'\" v-sort-group=\"'tasks'\">...</ul>\n *   <ul v-sort=\"'reorderDone'\" v-sort-group=\"'tasks'\">...</ul>\n *\n * Modifiers:\n *   .Xms          - Animation duration (default 150ms)\n *   .no-animation - Disable animation\n *   .horizontal   - Horizontal sorting direction\n */\n\nimport Sortable from 'sortablejs';\n\n/**\n * WeakMap to store Sortable instances for cleanup.\n * @type {WeakMap<HTMLElement, Sortable>}\n */\nconst sortables = new WeakMap();\n\n/**\n * WeakMap to store item IDs for fast lookup.\n * @type {WeakMap<HTMLElement, string|number>}\n */\nconst itemIds = new WeakMap();\n\n/**\n * Get the livue helper from a vnode context.\n *\n * @param {object} vnode - Vue vnode\n * @returns {object|null} - livue helper or null\n */\nfunction getLivueFromVnode(vnode) {\n    let ctx = vnode.ctx;\n\n    if (ctx && ctx.setupState && ctx.setupState.livue) {\n        return ctx.setupState.livue;\n    }\n\n    if (ctx && ctx.parent && ctx.parent.setupState && ctx.parent.setupState.livue) {\n        return ctx.parent.setupState.livue;\n    }\n\n    let parent = ctx ? ctx.parent : null;\n    while (parent) {\n        if (parent.setupState && parent.setupState.livue) {\n            return parent.setupState.livue;\n        }\n        parent = parent.parent;\n    }\n\n    return null;\n}\n\n/**\n * Parse animation duration from modifiers.\n *\n * @param {object} modifiers - Vue binding modifiers\n * @returns {number} Duration in milliseconds\n */\nfunction parseAnimation(modifiers) {\n    if (modifiers['no-animation']) {\n        return 0;\n    }\n\n    // Look for Xms modifier (e.g., 300ms)\n    for (let key of Object.keys(modifiers)) {\n        let match = key.match(/^(\\d+)ms$/);\n        if (match) {\n            return parseInt(match[1], 10);\n        }\n    }\n\n    return 150; // Default animation duration\n}\n\n/**\n * Parse binding value into method and extra params.\n *\n * @param {string|Array} value - Binding value\n * @returns {Array} [method, extraParams]\n */\nfunction parseValue(value) {\n    if (Array.isArray(value)) {\n        return [value[0], value[1] || []];\n    }\n    return [value, []];\n}\n\n/**\n * WeakMap to store binding references for accessing current value in onEnd.\n * @type {WeakMap<HTMLElement, object>}\n */\nconst bindings = new WeakMap();\n\n/**\n * v-sort: Main container directive.\n * Creates a SortableJS instance and calls PHP method on drop.\n */\nexport const sortDirective = {\n    mounted(el, binding, vnode) {\n        let livue = getLivueFromVnode(vnode);\n        let modifiers = binding.modifiers || {};\n        let animation = parseAnimation(modifiers);\n        let direction = modifiers.horizontal ? 'horizontal' : 'vertical';\n\n        // Store binding for access in onEnd (to get current value)\n        bindings.set(el, binding);\n\n        // Get group name if v-sort-group is set\n        let groupName = el.dataset.livueSortGroup || null;\n\n        // Build Sortable options\n        let options = {\n            animation: animation,\n            direction: direction,\n            ghostClass: 'livue-sort-ghost',\n            chosenClass: 'livue-sort-chosen',\n            dragClass: 'livue-sort-drag',\n\n            // Draggable items selector (elements with data-livue-sort-item)\n            draggable: '[data-livue-sort-item]',\n\n            // Filter out ignored elements (prevents drag on buttons, etc.)\n            filter: '[data-livue-sort-ignore]',\n            preventOnFilter: false,\n\n            // Callback when item is dropped\n            onEnd: function (evt) {\n                let newIndex = evt.newIndex;\n                let oldIndex = evt.oldIndex;\n\n                if (oldIndex === newIndex) {\n                    return;\n                }\n\n                // Get current binding value (may have changed since mount)\n                let currentBinding = bindings.get(el);\n                let value = currentBinding ? currentBinding.value : null;\n\n                // Determine mode based on current value type:\n                // - string: server-side (call PHP method)\n                // - array: client-side (reorder Vue array locally)\n                let isServerMode = typeof value === 'string';\n                let isLocalMode = Array.isArray(value);\n\n                // Local mode: reorder Vue array directly\n                if (isLocalMode) {\n                    // Revert DOM changes made by SortableJS - let Vue handle rendering\n                    let parent = evt.from;\n                    if (oldIndex < newIndex) {\n                        parent.insertBefore(evt.item, parent.children[oldIndex]);\n                    } else {\n                        parent.insertBefore(evt.item, parent.children[oldIndex + 1]);\n                    }\n\n                    // Now update the Vue array - Vue will re-render correctly\n                    let item = value.splice(oldIndex, 1)[0];\n                    value.splice(newIndex, 0, item);\n                    return;\n                }\n\n                // Server mode: call PHP method\n                if (isServerMode && livue) {\n                    let method = value;\n                    let extraParams = [];\n\n                    let itemEl = evt.item;\n\n                    // Get item ID from WeakMap or fallback to data attribute\n                    let itemId = itemIds.get(itemEl);\n                    if (itemId === undefined) {\n                        itemId = itemEl.dataset.livueSortItem;\n                    }\n\n                    // Try to convert to number if it looks like one\n                    if (typeof itemId === 'string' && /^\\d+$/.test(itemId)) {\n                        itemId = parseInt(itemId, 10);\n                    }\n\n                    let fromList = evt.from;\n                    let toList = evt.to;\n\n                    // Build params: [itemId, newPosition, ...extraParams]\n                    let params = [itemId, newIndex].concat(extraParams);\n\n                    // If moved between lists, use destination list's method and add fromList info\n                    let isCrossList = fromList !== toList;\n                    if (isCrossList) {\n                        // Use the method from the DESTINATION list\n                        let destMethod = toList.dataset.livueSortMethod;\n                        if (destMethod) {\n                            method = destMethod;\n                        }\n\n                        // Use data-livue-sort-id for list identification (separate from group name)\n                        // Falls back to data-livue-sort-group if sort-id not set\n                        let fromListId = fromList.dataset.livueSortId || fromList.dataset.livueSortGroup || null;\n                        params.push(fromListId);\n                    }\n\n                    // Call the server - SortableJS has already updated the DOM optimistically\n                    livue.call(method, params);\n                }\n            },\n        };\n\n        // Store method on element for cross-list access (server mode only)\n        if (typeof binding.value === 'string') {\n            el.dataset.livueSortMethod = binding.value;\n        }\n\n        // Check for handle elements\n        let hasHandle = el.querySelector('[data-livue-sort-handle]');\n        if (hasHandle) {\n            options.handle = '[data-livue-sort-handle]';\n        }\n\n        // Group support for cross-list drag\n        if (groupName) {\n            options.group = groupName;\n        }\n\n        // Create Sortable instance\n        let sortable = Sortable.create(el, options);\n        sortables.set(el, sortable);\n    },\n\n    updated(el, binding) {\n        // Update stored binding reference\n        bindings.set(el, binding);\n\n        // Re-check for handles after Vue updates (v-for changes)\n        let sortable = sortables.get(el);\n        if (sortable) {\n            let hasHandle = el.querySelector('[data-livue-sort-handle]');\n            if (hasHandle) {\n                sortable.option('handle', '[data-livue-sort-handle]');\n            }\n        }\n    },\n\n    unmounted(el) {\n        let sortable = sortables.get(el);\n\n        if (sortable) {\n            sortable.destroy();\n            sortables.delete(el);\n        }\n\n        bindings.delete(el);\n    },\n};\n\n/**\n * v-sort-item: Mark element as draggable item.\n * Value is the unique ID of the item.\n */\nexport const sortItemDirective = {\n    mounted(el, binding) {\n        let itemId = binding.value;\n\n        // Store in WeakMap for fast lookup\n        itemIds.set(el, itemId);\n\n        // Also set data attribute for SortableJS selector\n        el.setAttribute('data-livue-sort-item', itemId);\n    },\n\n    updated(el, binding) {\n        let itemId = binding.value;\n        itemIds.set(el, itemId);\n        el.setAttribute('data-livue-sort-item', itemId);\n    },\n\n    unmounted(el) {\n        itemIds.delete(el);\n        // Defensive: element may have been removed by Vue re-render\n        if (el && el.removeAttribute) {\n            try {\n                el.removeAttribute('data-livue-sort-item');\n            } catch (e) {\n                // Ignore errors if element is detached\n            }\n        }\n    },\n};\n\n/**\n * v-sort-handle: Mark element as drag handle.\n * Dragging will only work when starting from this element.\n */\nexport const sortHandleDirective = {\n    mounted(el) {\n        el.setAttribute('data-livue-sort-handle', '');\n    },\n\n    unmounted(el) {\n        // Defensive: element may have been removed by Vue re-render\n        if (el && el.removeAttribute) {\n            try {\n                el.removeAttribute('data-livue-sort-handle');\n            } catch (e) {\n                // Ignore errors if element is detached\n            }\n        }\n    },\n};\n\n/**\n * v-sort-ignore: Exclude element from drag operations.\n * Useful for buttons, inputs, and other interactive elements.\n */\nexport const sortIgnoreDirective = {\n    mounted(el) {\n        el.setAttribute('data-livue-sort-ignore', '');\n    },\n\n    unmounted(el) {\n        // Defensive: element may have been removed by Vue re-render\n        if (el && el.removeAttribute) {\n            try {\n                el.removeAttribute('data-livue-sort-ignore');\n            } catch (e) {\n                // Ignore errors if element is detached\n            }\n        }\n    },\n};\n\n/**\n * v-sort-group: Set group name for cross-list dragging.\n * Lists with the same group name can exchange items.\n */\nexport const sortGroupDirective = {\n    mounted(el, binding) {\n        let groupName = binding.value;\n        el.setAttribute('data-livue-sort-group', groupName);\n\n        // If a Sortable already exists, update its group\n        let sortable = sortables.get(el);\n        if (sortable) {\n            sortable.option('group', groupName);\n        }\n    },\n\n    updated(el, binding) {\n        let groupName = binding.value;\n        el.setAttribute('data-livue-sort-group', groupName);\n\n        let sortable = sortables.get(el);\n        if (sortable) {\n            sortable.option('group', groupName);\n        }\n    },\n\n    unmounted(el) {\n        // Defensive: element may have been removed by Vue re-render\n        if (el && el.removeAttribute) {\n            try {\n                el.removeAttribute('data-livue-sort-group');\n            } catch (e) {\n                // Ignore errors if element is detached\n            }\n        }\n    },\n};\n\n// Default export for backward compatibility\nexport default sortDirective;\n","/**\n * LiVue Custom Directives\n *\n * Exports all built-in directives and registers them via the registry system.\n * Directives are registered at boot time and applied to all Vue apps.\n */\n\nimport { addDirective } from '../core/registry.js';\n\nimport initDirective from './init.js';\nimport submitDirective from './submit.js';\nimport intersectDirective from './intersect.js';\nimport currentDirective from './current.js';\nimport ignoreDirective from './ignore.js';\nimport modelDirective from './model.js';\nimport pollDirective from './poll.js';\nimport offlineDirective from './offline.js';\nimport transitionDirective from './transition.js';\nimport replaceDirective from './replace.js';\nimport loadingDirective from './loading.js';\nimport targetDirective from './target.js';\nimport streamDirective from './stream.js';\nimport clickDirective from './click.js';\nimport navigateDirective from './navigate.js';\nimport scrollDirective from './scroll.js';\nimport dirtyDirective from './dirty.js';\nimport watchDirective from './watch.js';\nimport {\n    debounceDirective,\n    throttleDirective,\n    blurDirective,\n    enterDirective,\n    booleanDirective,\n} from './model-modifiers.js';\nimport {\n    sortDirective,\n    sortItemDirective,\n    sortHandleDirective,\n    sortIgnoreDirective,\n    sortGroupDirective,\n} from './sort.js';\n\n/**\n * Register all built-in directives.\n * Called during LiVue boot.\n */\nexport function registerBuiltInDirectives() {\n    // v-init: Execute function on mount\n    addDirective('init', initDirective, null);\n\n    // v-submit: Form submission with preventDefault\n    addDirective('submit', submitDirective, null);\n\n    // v-intersect: IntersectionObserver for viewport detection\n    addDirective('intersect', intersectDirective, null);\n\n    // v-current: Highlight current navigation links\n    addDirective('current', currentDirective, null);\n\n    // v-ignore: Preserve element during template swap\n    addDirective('ignore', ignoreDirective, null);\n\n    // v-model-livue: Enhanced v-model with modifiers (for testing/comparison)\n    addDirective('model-livue', modelDirective, null);\n\n    // v-model modifier directives (work with native v-model)\n    addDirective('debounce', debounceDirective, null);\n    addDirective('throttle', throttleDirective, null);\n    addDirective('blur', blurDirective, null);\n    addDirective('enter', enterDirective, null);\n    addDirective('boolean', booleanDirective, null);\n\n    // v-poll: Automatic polling at intervals\n    addDirective('poll', pollDirective, null);\n\n    // v-offline: Show content when offline\n    addDirective('offline', offlineDirective, null);\n\n    // v-transition: View Transitions API for smooth animations\n    addDirective('transition', transitionDirective, null);\n\n    // v-replace: Force element replacement instead of Vue reuse\n    addDirective('replace', replaceDirective, null);\n\n    // v-loading: Show/hide/modify elements based on loading state\n    addDirective('loading', loadingDirective, null);\n\n    // v-target: Auto-inject data-loading attribute for specific actions\n    addDirective('target', targetDirective, null);\n\n    // v-stream: Mark element as streaming target for $this->stream()\n    addDirective('stream', streamDirective, null);\n\n    // v-click: Cleaner syntax for calling server methods\n    addDirective('click', clickDirective, null);\n\n    // v-navigate: SPA navigation for links with prefetching\n    addDirective('navigate', navigateDirective, null);\n\n    // v-scroll: Mark element for scroll position preservation during SPA navigation\n    addDirective('scroll', scrollDirective, null);\n\n    // v-dirty: Show/modify elements based on dirty tracking state\n    addDirective('dirty', dirtyDirective, null);\n\n    // v-watch: Watch property and sync to server on change\n    addDirective('watch', watchDirective, null);\n\n    // v-sort: Drag & Drop sorting (Wave 6.2)\n    addDirective('sort', sortDirective, null);\n    addDirective('sort-item', sortItemDirective, null);\n    addDirective('sort-handle', sortHandleDirective, null);\n    addDirective('sort-ignore', sortIgnoreDirective, null);\n    addDirective('sort-group', sortGroupDirective, null);\n}\n\nexport {\n    initDirective,\n    submitDirective,\n    intersectDirective,\n    currentDirective,\n    ignoreDirective,\n    modelDirective,\n    debounceDirective,\n    throttleDirective,\n    blurDirective,\n    enterDirective,\n    booleanDirective,\n    pollDirective,\n    offlineDirective,\n    transitionDirective,\n    replaceDirective,\n    loadingDirective,\n    targetDirective,\n    streamDirective,\n    clickDirective,\n    navigateDirective,\n    scrollDirective,\n    dirtyDirective,\n    sortDirective,\n    sortItemDirective,\n    sortHandleDirective,\n    sortIgnoreDirective,\n    sortGroupDirective,\n    watchDirective,\n};\n","/**\n * HMR Indicator - Visual feedback for Hot Module Replacement.\n *\n * Shows a small toast notification when HMR updates occur.\n */\n\nlet indicatorEl = null;\nlet hideTimeout = null;\nlet isInjected = false;\n\n/**\n * Inject the indicator styles.\n */\nfunction injectStyles() {\n    if (isInjected) {\n        return;\n    }\n    isInjected = true;\n\n    const style = document.createElement('style');\n    style.textContent = `\n        .livue-hmr-indicator {\n            position: fixed;\n            bottom: 16px;\n            right: 16px;\n            padding: 8px 16px;\n            background: rgba(30, 30, 30, 0.95);\n            color: #fff;\n            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;\n            font-size: 13px;\n            border-radius: 6px;\n            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);\n            z-index: 999998;\n            display: flex;\n            align-items: center;\n            gap: 8px;\n            opacity: 0;\n            transform: translateY(10px);\n            transition: opacity 0.2s, transform 0.2s;\n            pointer-events: none;\n        }\n\n        .livue-hmr-indicator.visible {\n            opacity: 1;\n            transform: translateY(0);\n        }\n\n        .livue-hmr-indicator .spinner {\n            width: 14px;\n            height: 14px;\n            border: 2px solid rgba(255, 255, 255, 0.3);\n            border-top-color: #fff;\n            border-radius: 50%;\n            animation: livue-hmr-spin 0.8s linear infinite;\n        }\n\n        .livue-hmr-indicator .checkmark {\n            color: #4ade80;\n            font-size: 16px;\n        }\n\n        .livue-hmr-indicator .error-icon {\n            color: #f87171;\n            font-size: 16px;\n        }\n\n        @keyframes livue-hmr-spin {\n            to { transform: rotate(360deg); }\n        }\n    `;\n    document.head.appendChild(style);\n}\n\n/**\n * Create the indicator element if it doesn't exist.\n */\nfunction ensureIndicator() {\n    if (indicatorEl) {\n        return indicatorEl;\n    }\n\n    injectStyles();\n\n    indicatorEl = document.createElement('div');\n    indicatorEl.className = 'livue-hmr-indicator';\n    document.body.appendChild(indicatorEl);\n\n    return indicatorEl;\n}\n\n/**\n * Show the indicator with a specific state.\n *\n * @param {'updating'|'done'|'error'} state - The state to show\n * @param {string} [fileName] - Optional file name to display\n */\nexport function show(state, fileName) {\n    const el = ensureIndicator();\n\n    // Clear any pending hide timeout\n    if (hideTimeout) {\n        clearTimeout(hideTimeout);\n        hideTimeout = null;\n    }\n\n    // Set content based on state\n    switch (state) {\n        case 'updating':\n            el.innerHTML = `\n                <span class=\"spinner\"></span>\n                <span>Updating${fileName ? ': ' + fileName : '...'}</span>\n            `;\n            break;\n\n        case 'done':\n            el.innerHTML = `\n                <span class=\"checkmark\">&#10003;</span>\n                <span>Updated</span>\n            `;\n            // Auto-hide after success\n            hideTimeout = setTimeout(function () {\n                hide();\n            }, 1500);\n            break;\n\n        case 'error':\n            el.innerHTML = `\n                <span class=\"error-icon\">&#10007;</span>\n                <span>Update failed</span>\n            `;\n            // Auto-hide after error\n            hideTimeout = setTimeout(function () {\n                hide();\n            }, 3000);\n            break;\n    }\n\n    // Show the indicator\n    requestAnimationFrame(function () {\n        el.classList.add('visible');\n    });\n}\n\n/**\n * Hide the indicator.\n */\nexport function hide() {\n    if (!indicatorEl) {\n        return;\n    }\n\n    indicatorEl.classList.remove('visible');\n}\n\n/**\n * Remove the indicator element entirely.\n */\nexport function destroy() {\n    if (hideTimeout) {\n        clearTimeout(hideTimeout);\n        hideTimeout = null;\n    }\n\n    if (indicatorEl) {\n        indicatorEl.remove();\n        indicatorEl = null;\n    }\n}\n","/**\n * LiVue HMR (Hot Module Replacement) Module.\n *\n * Handles hot reloading of LiVue components when Blade templates\n * or PHP classes change during development.\n *\n * Uses Vite's HMR API to receive file change notifications from the\n * custom livue-hmr Vite plugin, then reloads components while preserving\n * their reactive state.\n */\n\nimport * as indicator from './hmr-indicator.js';\n\n/**\n * @type {LiVueRuntime|null}\n */\nlet runtime = null;\n\n/**\n * @type {boolean}\n */\nlet enabled = true;\n\n/**\n * @type {boolean}\n */\nlet preserveState = true;\n\n/**\n * @type {boolean}\n */\nlet showIndicator = true;\n\n/**\n * @type {Array<Function>}\n */\nlet updateCallbacks = [];\n\n/**\n * @type {boolean}\n */\nlet isSetup = false;\n\n/**\n * Setup HMR handling.\n *\n * @param {LiVueRuntime} runtimeInstance - The LiVue runtime instance\n */\nexport function setup(runtimeInstance) {\n    if (isSetup) {\n        return;\n    }\n\n    runtime = runtimeInstance;\n\n    // Only setup if HMR is available (Vite dev server)\n    if (!import.meta.hot) {\n        return;\n    }\n\n    isSetup = true;\n\n    // Listen for custom HMR events from the Vite plugin\n    import.meta.hot.on('livue:hmr', handleHmrUpdate);\n\n    // Also accept updates to this module\n    import.meta.hot.accept();\n}\n\n/**\n * Handle an HMR update event.\n *\n * @param {object} data - Event data from Vite plugin\n * @param {string} data.file - Full file path\n * @param {string} data.fileName - File name only\n * @param {'template'|'class'} data.type - Type of file\n * @param {boolean} [data.isNew] - Whether this is a new file\n * @param {number} data.timestamp - Update timestamp\n */\nasync function handleHmrUpdate(data) {\n    if (!enabled) {\n        return;\n    }\n\n    console.log('[LiVue HMR] ' + data.type + ' changed: ' + data.fileName);\n\n    // Show updating indicator\n    if (showIndicator) {\n        indicator.show('updating', data.fileName);\n    }\n\n    // Notify callbacks\n    updateCallbacks.forEach(function (callback) {\n        try {\n            callback(data);\n        } catch (e) {\n            console.error('[LiVue HMR] Callback error:', e);\n        }\n    });\n\n    try {\n        // Save component states before reboot\n        const savedStates = preserveState ? saveComponentStates() : null;\n\n        // Fetch fresh HTML from the server\n        const response = await fetch(window.location.href, {\n            headers: {\n                'X-Requested-With': 'XMLHttpRequest',\n                'X-LiVue-HMR': '1',\n            },\n        });\n\n        if (!response.ok) {\n            throw new Error('Server returned ' + response.status);\n        }\n\n        const html = await response.text();\n\n        // Parse the HTML to extract the body content\n        const parser = new DOMParser();\n        const doc = parser.parseFromString(html, 'text/html');\n\n        // Find all LiVue component elements in the new HTML\n        const newComponents = doc.querySelectorAll('[data-livue-id]');\n\n        if (newComponents.length === 0) {\n            // No components found in new HTML, might be an error page\n            console.warn('[LiVue HMR] No components found in response, skipping update');\n            if (showIndicator) {\n                indicator.show('error');\n            }\n            return;\n        }\n\n        // Update each component's template\n        newComponents.forEach(function (newEl) {\n            const id = newEl.dataset.livueId;\n            const existingEl = document.querySelector('[data-livue-id=\"' + id + '\"]');\n\n            if (existingEl) {\n                // Update the snapshot data\n                if (newEl.dataset.livueSnapshot) {\n                    existingEl.dataset.livueSnapshot = newEl.dataset.livueSnapshot;\n                }\n\n                // Update the inner HTML (template content)\n                existingEl.innerHTML = newEl.innerHTML;\n            }\n        });\n\n        // Reboot the runtime to re-mount components with new templates\n        runtime.reboot();\n\n        // Restore states after reboot\n        if (savedStates) {\n            // Wait for Vue to mount\n            await nextTick();\n            restoreComponentStates(savedStates);\n        }\n\n        // Show success indicator\n        if (showIndicator) {\n            indicator.show('done');\n        }\n\n    } catch (error) {\n        console.error('[LiVue HMR] Update failed:', error);\n\n        if (showIndicator) {\n            indicator.show('error');\n        }\n    }\n}\n\n/**\n * Save the state of all components.\n *\n * @returns {Map<string, { name: string, state: object }>}\n */\nfunction saveComponentStates() {\n    const states = new Map();\n\n    if (!runtime) {\n        return states;\n    }\n\n    // Get all root/island components\n    const components = runtime.all();\n\n    components.forEach(function (component) {\n        // Save root component state\n        saveComponentState(component.componentId, component.name, component.state, states);\n\n        // Save child component states\n        if (component._childRegistry) {\n            for (const childId in component._childRegistry) {\n                const child = component._childRegistry[childId];\n                saveComponentState(childId, child.name, child.state, states);\n            }\n        }\n    });\n\n    return states;\n}\n\n/**\n * Save a single component's state.\n *\n * @param {string} id - Component ID\n * @param {string} name - Component name\n * @param {object} state - Reactive state object\n * @param {Map} states - Map to store states in\n */\nfunction saveComponentState(id, name, state, states) {\n    const savedState = {};\n\n    for (const key in state) {\n        const value = state[key];\n\n        // Skip functions and symbols\n        if (typeof value === 'function' || typeof value === 'symbol') {\n            continue;\n        }\n\n        // Deep clone to avoid reactivity issues\n        try {\n            savedState[key] = JSON.parse(JSON.stringify(value));\n        } catch (e) {\n            // Skip non-serializable values\n            console.warn('[LiVue HMR] Could not save state for ' + name + '.' + key);\n        }\n    }\n\n    states.set(id, { name: name, state: savedState });\n}\n\n/**\n * Restore component states after reboot.\n *\n * @param {Map<string, { name: string, state: object }>} savedStates\n */\nfunction restoreComponentStates(savedStates) {\n    if (!runtime) {\n        return;\n    }\n\n    savedStates.forEach(function (data, oldId) {\n        // Try to find component by name (ID may have changed)\n        const matches = runtime.getByName(data.name);\n\n        if (matches.length > 0) {\n            const component = matches[0];\n\n            // Restore state\n            for (const key in data.state) {\n                if (key in component.state) {\n                    component.state[key] = data.state[key];\n                }\n            }\n        }\n    });\n}\n\n/**\n * Wait for next tick (Vue's microtask queue to flush).\n *\n * @returns {Promise<void>}\n */\nfunction nextTick() {\n    return new Promise(function (resolve) {\n        setTimeout(resolve, 0);\n    });\n}\n\n/**\n * Check if HMR is available (Vite dev server running).\n *\n * @returns {boolean}\n */\nexport function isAvailable() {\n    return typeof import.meta !== 'undefined' && !!import.meta.hot;\n}\n\n/**\n * Enable HMR updates.\n */\nexport function enable() {\n    enabled = true;\n}\n\n/**\n * Disable HMR updates.\n */\nexport function disable() {\n    enabled = false;\n}\n\n/**\n * Check if HMR is enabled.\n *\n * @returns {boolean}\n */\nexport function isEnabled() {\n    return enabled;\n}\n\n/**\n * Configure HMR behavior.\n *\n * @param {object} options\n * @param {boolean} [options.indicator] - Show visual indicator\n * @param {boolean} [options.preserveState] - Preserve component state on reload\n */\nexport function configure(options) {\n    if (options.indicator !== undefined) {\n        showIndicator = options.indicator;\n    }\n    if (options.preserveState !== undefined) {\n        preserveState = options.preserveState;\n    }\n}\n\n/**\n * Register a callback to be called on HMR updates.\n *\n * @param {Function} callback - Function called with update data\n * @returns {Function} Unsubscribe function\n */\nexport function onUpdate(callback) {\n    updateCallbacks.push(callback);\n\n    return function () {\n        const index = updateCallbacks.indexOf(callback);\n        if (index !== -1) {\n            updateCallbacks.splice(index, 1);\n        }\n    };\n}\n\n/**\n * Manually trigger an HMR-like reload.\n * Useful for testing or programmatic refreshes.\n */\nexport async function trigger() {\n    if (!runtime) {\n        return;\n    }\n\n    await handleHmrUpdate({\n        file: 'manual-trigger',\n        fileName: 'manual',\n        type: 'template',\n        timestamp: Date.now(),\n    });\n}\n","/**\n * LiVue Runtime - Core orchestrator.\n *\n * Discovers all LiVue components on the page and mounts Vue apps\n * only on root elements (top-level or islands).\n *\n * Nested components are handled within the parent's Vue app\n * as registered Vue components, sharing the same instance.\n */\n\nimport LiVueComponent from './component.js';\nimport { onError } from '../helpers/errors.js';\nimport {\n    initNavigation,\n    navigateTo,\n    configure as configureNavigation,\n    clearCache as clearNavigationCache,\n    prefetchUrl,\n    isNavigating,\n} from '../features/navigation.js';\nimport progress from '../helpers/progress.js';\nimport { registerBuiltInDirectives } from '../directives/index.js';\nimport { hook, getAvailableHooks } from '../helpers/hooks.js';\nimport { isEchoAvailable, getDebugInfo as getEchoDebugInfo, leaveAll as leaveAllEchoChannels } from '../features/echo.js';\nimport * as devtools from '../devtools/index.js';\nimport * as hmr from '../features/hmr/hmr.js';\n\n/**\n * Debug mode flag.\n * @type {boolean}\n */\nvar _debugMode = false;\n\n/**\n * Debug hook unsubscribers.\n * @type {Array<Function>}\n */\nvar _debugUnsubscribers = [];\n\nclass LiVueRuntime {\n    constructor() {\n        /** @type {Map<string, LiVueComponent>} */\n        this.components = new Map();\n\n        /** @type {MutationObserver|null} */\n        this._observer = null;\n\n        /** @type {boolean} */\n        this._devtoolsInitialized = false;\n\n        /** @type {Array<Function>} Setup callbacks for configuring Vue apps */\n        this._setupCallbacks = [];\n\n        /** @type {Set<string>|null} IDs of components being preserved during navigation */\n        this._preservingIds = null;\n    }\n\n    /**\n     * Configure Vue apps before they are created.\n     * Use this to add plugins like Vuetify, Pinia stores, etc.\n     *\n     * The callback is called for each Vue app instance (root components\n     * and islands), AFTER Pinia is installed but BEFORE mounting.\n     *\n     * @param {Function} callback - Function(app) called for each Vue app\n     *\n     * @example\n     * // Add Vuetify\n     * LiVue.setup((app) => {\n     *     const vuetify = createVuetify({...});\n     *     app.use(vuetify);\n     * });\n     *\n     * @example\n     * // Add multiple plugins\n     * LiVue.setup((app) => {\n     *     app.use(vuetify);\n     *     app.use(router);\n     *     app.component('MyComponent', MyComponent);\n     *     app.directive('focus', focusDirective);\n     * });\n     */\n    setup(callback) {\n        if (typeof callback !== 'function') {\n            console.error('[LiVue] setup() requires a function callback');\n            return;\n        }\n        this._setupCallbacks.push(callback);\n    }\n\n    /**\n     * Register a global error handler.\n     * Called when a non-validation error occurs on any component.\n     *\n     * @param {Function} handler - function(error, componentName)\n     */\n    onError(handler) {\n        onError(handler);\n    }\n\n    /**\n     * Boot the runtime: discover root/island components and mount them.\n     * Children are automatically handled by their parent's Vue app.\n     * Starts a MutationObserver to automatically detect new components.\n     */\n    boot() {\n        // Initialize devtools only in development (lazy, doesn't open panel)\n        if (import.meta.env.DEV && !this._devtoolsInitialized) {\n            devtools.init(this);\n            this._devtoolsInitialized = true;\n        }\n\n        // Register built-in directives before mounting components\n        registerBuiltInDirectives();\n\n        let allElements = document.querySelectorAll('[data-livue-id]');\n\n        allElements.forEach(function (el) {\n            if (this._isRoot(el)) {\n                this._initComponent(el);\n            }\n        }.bind(this));\n\n        // Initialize navigation module (sets history state, popstate listener)\n        initNavigation(this);\n\n        // Start observing DOM for dynamic component changes\n        this._startObserver();\n\n        // Setup keyboard shortcut for devtools (Ctrl+Shift+L) - only in development\n        if (import.meta.env.DEV) {\n            this._setupDevtoolsShortcut();\n        }\n\n        // Setup HMR (Hot Module Replacement) in development\n        hmr.setup(this);\n    }\n\n    /**\n     * Setup keyboard shortcut for devtools.\n     * @private\n     */\n    _setupDevtoolsShortcut() {\n        if (this._devtoolsShortcutSetup) {\n            return;\n        }\n        this._devtoolsShortcutSetup = true;\n\n        document.addEventListener('keydown', function (e) {\n            if (e.ctrlKey && e.shiftKey && e.key === 'L') {\n                e.preventDefault();\n                devtools.toggle();\n            }\n        });\n    }\n\n    /**\n     * Reboot: destroy all existing components and re-discover.\n     * Called after SPA navigation swaps the page content.\n     * The MutationObserver continues running and will pick up new components,\n     * but we do a full scan here to ensure immediate initialization.\n     */\n    reboot() {\n        // Temporarily pause observer to avoid duplicate processing\n        this._stopObserver();\n\n        this.destroy();\n\n        let allElements = document.querySelectorAll('[data-livue-id]');\n\n        allElements.forEach(function (el) {\n            if (this._isRoot(el)) {\n                this._initComponent(el);\n            }\n        }.bind(this));\n\n        // Resume observing\n        this._startObserver();\n    }\n\n    /**\n     * Reboot but preserve certain components (don't destroy them).\n     * Used during SPA navigation with @persist elements.\n     */\n    rebootPreserving() {\n        // Only init NEW components (those not already in the map)\n        let allElements = document.querySelectorAll('[data-livue-id]');\n\n        allElements.forEach(function (el) {\n            if (this._isRoot(el)) {\n                this._initComponent(el); // _initComponent already skips existing\n            }\n        }.bind(this));\n\n        // Resume observing AFTER a frame to let Vue finish any pending DOM cleanup\n        // from the destroyed components. Otherwise the observer sees the cleanup\n        // and incorrectly destroys preserved components.\n        // NOTE: We keep _preservingIds set - it will be cleared/replaced by the next navigation\n        let self = this;\n        requestAnimationFrame(function() {\n            self._startObserver();\n        });\n    }\n\n    /**\n     * Navigate to a URL using SPA navigation.\n     * Can be called from user code: LiVue.navigate('/dashboard')\n     *\n     * @param {string} url - Target URL\n     */\n    navigate(url) {\n        navigateTo(url, true, false);\n    }\n\n    /**\n     * Configure navigation behavior.\n     *\n     * @param {object} options\n     * @param {boolean} [options.showProgressBar] - Show progress bar during navigation (default: true)\n     * @param {string} [options.progressBarColor] - Progress bar color (default: '#29d')\n     * @param {boolean} [options.prefetch] - Enable prefetching (default: true)\n     * @param {boolean} [options.prefetchOnHover] - Prefetch on hover vs mousedown only (default: true)\n     * @param {number} [options.hoverDelay] - Hover delay before prefetch in ms (default: 60)\n     * @param {boolean} [options.cachePages] - Cache pages for back/forward (default: true)\n     * @param {number} [options.maxCacheSize] - Max cached pages (default: 10)\n     * @param {boolean} [options.restoreScroll] - Restore scroll position on back/forward (default: true)\n     */\n    configureNavigation(options) {\n        configureNavigation(options);\n    }\n\n    /**\n     * Prefetch a URL for instant navigation.\n     * Useful for programmatic prefetching.\n     *\n     * @param {string} url - URL to prefetch\n     * @returns {Promise<string|null>} The HTML content or null on error\n     */\n    prefetch(url) {\n        return prefetchUrl(url);\n    }\n\n    /**\n     * Clear the navigation page cache.\n     */\n    clearNavigationCache() {\n        clearNavigationCache();\n    }\n\n    /**\n     * Check if a navigation is currently in progress.\n     *\n     * @returns {boolean}\n     */\n    isNavigating() {\n        return isNavigating();\n    }\n\n    /**\n     * Get the progress bar API.\n     * Use LiVue.progress.configure() to customize appearance.\n     *\n     * @returns {object} Progress bar API { configure, start, done, set, isStarted }\n     */\n    get progress() {\n        return progress;\n    }\n\n    /**\n     * Get Echo (Laravel Broadcasting) status and debug info.\n     *\n     * @returns {object} { available: boolean, channels: string[], subscriptions: string[] }\n     */\n    get echo() {\n        return {\n            available: isEchoAvailable(),\n            ...getEchoDebugInfo(),\n        };\n    }\n\n    /**\n     * Check if an element should get its own Vue app.\n     * Returns true if the element is a top-level component (no livue parent)\n     * or if it's explicitly marked as an island.\n     *\n     * @param {HTMLElement} el\n     * @returns {boolean}\n     */\n    _isRoot(el) {\n        // Islands always get their own Vue app\n        if (el.hasAttribute('data-livue-island')) {\n            return true;\n        }\n\n        // Walk up the DOM to see if there's a parent livue component\n        let parent = el.parentElement;\n\n        while (parent) {\n            if (parent.hasAttribute('data-livue-id') && !parent.hasAttribute('data-livue-island')) {\n                return false; // Nested inside another livue component\n            }\n            parent = parent.parentElement;\n        }\n\n        return true; // No livue parent found\n    }\n\n    /**\n     * Initialize a root/island component.\n     *\n     * @param {HTMLElement} el\n     */\n    _initComponent(el) {\n        let id = el.dataset.livueId;\n\n        if (this.components.has(id)) {\n            return;\n        }\n\n        let component = new LiVueComponent(el);\n        this.components.set(id, component);\n    }\n\n    /**\n     * Get a mounted component instance by its ID.\n     *\n     * @param {string} id\n     * @returns {LiVueComponent|undefined}\n     */\n    getComponent(id) {\n        return this.components.get(id);\n    }\n\n    /**\n     * Find a component by its ID.\n     * Alias for getComponent.\n     *\n     * @param {string} id\n     * @returns {LiVueComponent|undefined}\n     */\n    find(id) {\n        return this.components.get(id);\n    }\n\n    /**\n     * Get the first mounted component on the page.\n     *\n     * @returns {LiVueComponent|undefined}\n     */\n    first() {\n        let iterator = this.components.values();\n        let first = iterator.next();\n        return first.done ? undefined : first.value;\n    }\n\n    /**\n     * Get all mounted root/island components.\n     *\n     * @returns {LiVueComponent[]}\n     */\n    all() {\n        return Array.from(this.components.values());\n    }\n\n    /**\n     * Get all components matching a specific name.\n     * Searches both root components and their children.\n     *\n     * @param {string} name - Component name (kebab-case)\n     * @returns {Array<{ id: string, name: string, state: object, livue: object }>}\n     */\n    getByName(name) {\n        let matches = [];\n\n        this.components.forEach(function (component) {\n            // Check root component\n            if (component.name === name) {\n                matches.push({\n                    id: component.componentId,\n                    name: component.name,\n                    state: component.state,\n                    livue: component._rootLivue,\n                });\n            }\n\n            // Check children\n            for (let childId in component._childRegistry) {\n                let child = component._childRegistry[childId];\n                if (child.name === name) {\n                    matches.push({\n                        id: childId,\n                        name: child.name,\n                        state: child.state,\n                        livue: child.livue,\n                    });\n                }\n            }\n        });\n\n        return matches;\n    }\n\n    /**\n     * Register a hook callback for lifecycle events.\n     *\n     * Available hooks:\n     * - component.init: When a component is initialized\n     * - component.destroy: When a component is destroyed\n     * - element.init: When each DOM element is initialized\n     * - request.started: When an AJAX request starts\n     * - request.finished: When an AJAX request completes\n     * - template.updating: Before a template is swapped\n     * - template.updated: After a template is swapped\n     * - error.occurred: When an error occurs\n     *\n     * @param {string} hookName - The hook to listen for\n     * @param {Function} callback - The callback function\n     * @returns {Function} Unsubscribe function\n     *\n     * @example\n     * const unsubscribe = LiVue.hook('component.init', ({ component, el, cleanup }) => {\n     *     console.log('Component initialized:', component.name);\n     *     cleanup(() => console.log('Cleanup'));\n     * });\n     *\n     * @example\n     * LiVue.hook('request.started', ({ url, updateCount }) => {\n     *     console.log('Request started to', url, 'with', updateCount, 'updates');\n     * });\n     */\n    hook(hookName, callback) {\n        return hook(hookName, callback);\n    }\n\n    /**\n     * Get list of all available hook names.\n     * @returns {string[]}\n     */\n    getAvailableHooks() {\n        return getAvailableHooks();\n    }\n\n    /**\n     * Destroy all mounted Vue app instances.\n     */\n    destroy() {\n        // Clear preserving flag\n        this._preservingIds = null;\n\n        this.components.forEach(function (component) {\n            component.destroy();\n        });\n        this.components.clear();\n\n        // Leave all Echo channels\n        leaveAllEchoChannels();\n    }\n\n    /**\n     * Destroy all mounted Vue app instances EXCEPT those with IDs in the preserveIds set.\n     * Used during SPA navigation to preserve @persist components.\n     *\n     * @param {Set<string>} preserveIds - Set of component IDs to preserve\n     */\n    destroyExcept(preserveIds) {\n        var self = this;\n        var toDelete = [];\n\n        // Store preserveIds so _cleanupComponent can check them\n        // This prevents the MutationObserver from destroying preserved components\n        // when Vue's unmount() triggers DOM removals\n        this._preservingIds = preserveIds;\n\n        this.components.forEach(function (component, id) {\n            if (!preserveIds.has(id)) {\n                component.destroy();\n                toDelete.push(id);\n            }\n        });\n\n        toDelete.forEach(function (id) {\n            self.components.delete(id);\n        });\n\n        // Leave all Echo channels (TODO: preserve channels for persisted components)\n        leaveAllEchoChannels();\n    }\n\n    /**\n     * Start the MutationObserver to watch for DOM changes.\n     * Automatically initializes new LiVue components and cleans up removed ones.\n     */\n    _startObserver() {\n        if (this._observer) {\n            return; // Already observing\n        }\n\n        let self = this;\n\n        this._observer = new MutationObserver(function (mutations) {\n            mutations.forEach(function (mutation) {\n                // Process added nodes\n                mutation.addedNodes.forEach(function (node) {\n                    if (node.nodeType !== Node.ELEMENT_NODE) {\n                        return;\n                    }\n\n                    self._processAddedNode(node);\n                });\n\n                // Process removed nodes\n                mutation.removedNodes.forEach(function (node) {\n                    if (node.nodeType !== Node.ELEMENT_NODE) {\n                        return;\n                    }\n\n                    self._processRemovedNode(node);\n                });\n            });\n        });\n\n        this._observer.observe(document.body, {\n            childList: true,\n            subtree: true,\n        });\n    }\n\n    /**\n     * Stop the MutationObserver.\n     */\n    _stopObserver() {\n        if (this._observer) {\n            this._observer.disconnect();\n            this._observer = null;\n        }\n    }\n\n    /**\n     * Process a node that was added to the DOM.\n     * Finds and initializes any LiVue root components within it.\n     * Also detects standalone <livue-lazy> elements and wraps them.\n     *\n     * @param {HTMLElement} node\n     */\n    _processAddedNode(node) {\n        // Check if the node itself is a LiVue component\n        if (node.hasAttribute && node.hasAttribute('data-livue-id')) {\n            if (this._isRoot(node)) {\n                this._initComponent(node);\n            }\n        }\n\n        // Check for LiVue components within the added node\n        if (node.querySelectorAll) {\n            let components = node.querySelectorAll('[data-livue-id]');\n\n            components.forEach(function (el) {\n                if (this._isRoot(el)) {\n                    this._initComponent(el);\n                }\n            }.bind(this));\n        }\n\n        // Check for standalone <livue-lazy> elements (not inside a LiVue component)\n        this._processStandaloneLazy(node);\n    }\n\n    /**\n     * Find and wrap standalone <livue-lazy> elements.\n     * These are lazy components injected outside of any LiVue root.\n     *\n     * @param {HTMLElement} node\n     */\n    _processStandaloneLazy(node) {\n        let lazyElements = [];\n\n        // Check if the node itself is a livue-lazy\n        if (node.tagName && node.tagName.toLowerCase() === 'livue-lazy') {\n            if (this._isStandaloneLazy(node)) {\n                lazyElements.push(node);\n            }\n        }\n\n        // Check for livue-lazy elements within the added node\n        if (node.querySelectorAll) {\n            let found = node.querySelectorAll('livue-lazy');\n            found.forEach(function (el) {\n                if (this._isStandaloneLazy(el)) {\n                    lazyElements.push(el);\n                }\n            }.bind(this));\n        }\n\n        // Wrap each standalone lazy element\n        lazyElements.forEach(function (el) {\n            this._wrapStandaloneLazy(el);\n        }.bind(this));\n    }\n\n    /**\n     * Check if a <livue-lazy> element is standalone (not inside a LiVue component).\n     *\n     * @param {HTMLElement} el\n     * @returns {boolean}\n     */\n    _isStandaloneLazy(el) {\n        // Already wrapped?\n        if (el.dataset.livueLazyWrapped) {\n            return false;\n        }\n\n        // Walk up the DOM to see if there's a parent livue component\n        let parent = el.parentElement;\n\n        while (parent) {\n            if (parent.hasAttribute('data-livue-id')) {\n                return false; // Inside a LiVue component, Vue will handle it\n            }\n            parent = parent.parentElement;\n        }\n\n        return true; // Standalone\n    }\n\n    /**\n     * Wrap a standalone <livue-lazy> element in a minimal LiVue root component.\n     *\n     * @param {HTMLElement} el\n     */\n    _wrapStandaloneLazy(el) {\n        // Mark as wrapped to avoid double processing\n        el.dataset.livueLazyWrapped = 'true';\n\n        // Create a wrapper div that will become the LiVue root\n        let wrapper = document.createElement('div');\n        let id = 'livue-lazy-wrapper-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);\n\n        // Minimal snapshot for a wrapper component (empty state, no memo except name)\n        let snapshot = {\n            state: {},\n            memo: {\n                name: 'lazy-wrapper',\n                checksum: '',\n            },\n        };\n\n        wrapper.dataset.livueId = id;\n        wrapper.dataset.livueSnapshot = JSON.stringify(snapshot);\n\n        // Move the livue-lazy element inside the wrapper\n        el.parentNode.insertBefore(wrapper, el);\n        wrapper.appendChild(el);\n\n        // Initialize the wrapper as a LiVue component\n        this._initComponent(wrapper);\n    }\n\n    /**\n     * Process a node that was removed from the DOM.\n     * Cleans up any LiVue components that were destroyed.\n     *\n     * @param {HTMLElement} node\n     */\n    _processRemovedNode(node) {\n        // Check if the node itself is a LiVue component\n        if (node.hasAttribute && node.hasAttribute('data-livue-id')) {\n            let id = node.dataset.livueId;\n            this._cleanupComponent(id);\n        }\n\n        // Check for LiVue components within the removed node\n        if (node.querySelectorAll) {\n            let components = node.querySelectorAll('[data-livue-id]');\n\n            components.forEach(function (el) {\n                let id = el.dataset.livueId;\n                this._cleanupComponent(id);\n            }.bind(this));\n        }\n    }\n\n    /**\n     * Clean up a component by ID if it exists.\n     *\n     * @param {string} id\n     */\n    _cleanupComponent(id) {\n        // Skip if this component is being preserved during navigation\n        if (this._preservingIds && this._preservingIds.has(id)) {\n            return;\n        }\n\n        let component = this.components.get(id);\n\n        if (component) {\n            component.destroy();\n            this.components.delete(id);\n        }\n    }\n\n    /**\n     * Set a custom confirmation handler for #[Confirm] methods.\n     *\n     * The handler receives { message, title, confirmText, cancelText }\n     * and must return a Promise<boolean>.\n     *\n     * Example with SweetAlert2:\n     *   LiVue.setConfirmHandler(async (config) => {\n     *       const result = await Swal.fire({\n     *           title: config.title || 'Confirm',\n     *           text: config.message,\n     *           showCancelButton: true,\n     *           confirmButtonText: config.confirmText,\n     *           cancelButtonText: config.cancelText,\n     *       });\n     *       return result.isConfirmed;\n     *   });\n     *\n     * @param {Function} handler - Async function returning Promise<boolean>\n     */\n    setConfirmHandler(handler) {\n        window.LiVue = window.LiVue || {};\n        window.LiVue.confirmHandler = handler;\n    }\n\n    /**\n     * Get the DevTools API.\n     * Returns no-op functions in production to avoid errors.\n     *\n     * @returns {object} DevTools API\n     *\n     * @example\n     * LiVue.devtools.open();\n     * LiVue.devtools.toggle();\n     * const components = LiVue.devtools.getComponents();\n     */\n    get devtools() {\n        if (!import.meta.env.DEV) {\n            // Return no-op API in production\n            return {\n                init: function() {},\n                open: function() {},\n                close: function() {},\n                toggle: function() {},\n                isOpen: function() { return false; },\n                getComponents: function() { return []; },\n                getTimeline: function() { return []; },\n                getEvents: function() { return []; },\n                getPerf: function() { return {}; },\n                clearTimeline: function() {},\n                clearEvents: function() {},\n                clear: function() {},\n                logEvent: function() {},\n                isInitialized: function() { return false; },\n                startCollecting: function() {},\n                stopCollecting: function() {},\n                isCollecting: function() { return false; },\n            };\n        }\n        return devtools;\n    }\n\n    /**\n     * Get the HMR (Hot Module Replacement) API.\n     *\n     * @returns {object} HMR API\n     *\n     * @example\n     * if (LiVue.hmr.isAvailable()) {\n     *     LiVue.hmr.onUpdate((data) => console.log('Updated:', data.fileName));\n     * }\n     */\n    get hmr() {\n        return {\n            isAvailable: hmr.isAvailable,\n            isEnabled: hmr.isEnabled,\n            enable: hmr.enable,\n            disable: hmr.disable,\n            configure: hmr.configure,\n            onUpdate: hmr.onUpdate,\n            trigger: hmr.trigger,\n        };\n    }\n\n    /**\n     * Enable or disable debug mode.\n     * When enabled, logs all hook events to the console.\n     *\n     * @param {boolean} enabled - Whether to enable debug mode\n     *\n     * @example\n     * LiVue.debug(true);  // Enable verbose logging\n     * LiVue.debug(false); // Disable logging\n     */\n    debug(enabled) {\n        if (enabled && !_debugMode) {\n            _debugMode = true;\n            console.log('[LiVue] Debug mode enabled');\n\n            // Subscribe to all hooks\n            var hookNames = getAvailableHooks();\n            hookNames.forEach(function (hookName) {\n                var unsub = hook(hookName, function (payload) {\n                    var logPayload = {};\n\n                    // Sanitize payload for logging (avoid circular refs)\n                    if (payload.component) {\n                        logPayload.componentId = payload.component.id;\n                        logPayload.componentName = payload.component.name;\n                    }\n                    if (payload.el) {\n                        logPayload.element = payload.el.tagName;\n                    }\n                    if (payload.url) {\n                        logPayload.url = payload.url;\n                    }\n                    if (payload.updateCount !== undefined) {\n                        logPayload.updateCount = payload.updateCount;\n                    }\n                    if (payload.lazyCount !== undefined) {\n                        logPayload.lazyCount = payload.lazyCount;\n                    }\n                    if (payload.success !== undefined) {\n                        logPayload.success = payload.success;\n                    }\n                    if (payload.error) {\n                        logPayload.error = payload.error.message || String(payload.error);\n                    }\n                    if (payload.isChild !== undefined) {\n                        logPayload.isChild = payload.isChild;\n                    }\n\n                    console.log('[LiVue] ' + hookName + ':', logPayload);\n                });\n                _debugUnsubscribers.push(unsub);\n            });\n        } else if (!enabled && _debugMode) {\n            _debugMode = false;\n            console.log('[LiVue] Debug mode disabled');\n\n            // Unsubscribe from all hooks\n            _debugUnsubscribers.forEach(function (unsub) {\n                unsub();\n            });\n            _debugUnsubscribers = [];\n        }\n\n        return _debugMode;\n    }\n\n    /**\n     * Check if debug mode is enabled.\n     *\n     * @returns {boolean}\n     */\n    isDebugEnabled() {\n        return _debugMode;\n    }\n}\n\nexport default new LiVueRuntime();\n","/**\n * LiVue ESM Entry Point\n *\n * This is the entry point for importing LiVue as an ES module.\n * Use this when you need to customize the Vue instance (e.g., add Vuetify).\n *\n * Usage:\n *   import LiVue from 'livue';\n *   import { createVuetify } from 'vuetify';\n *\n *   const vuetify = createVuetify({...});\n *\n *   LiVue.setup((app) => {\n *       app.use(vuetify);\n *   });\n *\n * IMPORTANT: This entry point does NOT bundle Vue. Vue is resolved from\n * the user's node_modules, ensuring a single Vue instance is shared with\n * libraries like Vuetify.\n */\n\n// Import CSS as string and inject into DOM\nimport css from '../css/livue.css?inline';\n\n// Inject CSS into document head (only once)\nif (typeof document !== 'undefined' && !document.getElementById('livue-styles')) {\n    const style = document.createElement('style');\n    style.id = 'livue-styles';\n    style.textContent = css;\n    document.head.appendChild(style);\n}\n\nimport LiVueRuntime from './runtime/index.js';\n\n// Read config from server-injected script (window.LiVueConfig)\nvar config = window.LiVueConfig || {};\n\n// Apply navigation config if present\nif (config.showProgressBar !== undefined ||\n    config.progressBarColor !== undefined ||\n    config.prefetch !== undefined ||\n    config.prefetchOnHover !== undefined ||\n    config.hoverDelay !== undefined ||\n    config.cachePages !== undefined ||\n    config.maxCacheSize !== undefined ||\n    config.restoreScroll !== undefined) {\n    LiVueRuntime.configureNavigation(config);\n}\n\n// Boot when DOM is ready (handle case where DOMContentLoaded already fired)\n// Use queueMicrotask to ensure setup() can be called before boot\nfunction bootLiVue() {\n    LiVueRuntime.boot();\n}\n\nif (document.readyState === 'loading') {\n    document.addEventListener('DOMContentLoaded', bootLiVue);\n} else {\n    // Delay boot to allow setup() to be called after import\n    queueMicrotask(bootLiVue);\n}\n\n// Expose globally\nwindow.LiVue = LiVueRuntime;\n\nexport default LiVueRuntime;\n"],"names":["cachedToken","getToken","meta","match","clearToken","_config","_status","_trickleTimer","_barEl","_spinnerEl","_stylesInjected","_pendingCount","clamp","n","min","max","toBarPercent","injectStyles","style","createElements","parent","updateStyles","configure","options","start","set","trickle","amount","done","forceDone","isStarted","getStatus","progress","_runtime","_initialized","_navigating","_pageCache","_prefetching","_hoverTimers","_scrollPositions","_currentPageKey","initNavigation","runtime","generatePageKey","event","saveScrollPosition","navigateTo","setupPrefetching","pageKey","scrollElements","el","key","pos","restoreScrollPosition","elKey","handleGlobalClick","handleMouseEnter","handleMouseLeave","handleMouseDown","handleFocus","href","url","getNavigateMode","mode","timer","prefetchUrl","normalizedUrl","fetchPromise","response","html","cachePage","err","parser","doc","title","oldestKey","clearCache","handleRedirect","redirect","pushState","isPopstate","navigateEvent","cached","navigatingEvent","mutator","persistedElements","collectPersistedElements","preservedIds","data","id","newTitle","restorePersistedElements","newCsrf","oldCsrf","handleTrackedScripts","executeBodyScripts","hashEl","persisted","elements","livueIds","livueElements","livueEl","scrollData","scrollEl","scrollKey","placeholder","currentScripts","newScripts","currentVersions","script","src","needsReload","base","scripts","oldScript","newScript","attr","isNavigating","_hooks","HOOK_NAMES","hook","hookName","callback","trigger","payload","callbacks","error","createCleanupCollector","cleanups","fn","getAvailableHooks","_pending","_pendingLazy","_scheduled","poolRequest","sendIsolated","resolve","reject","flush","poolLazyLoad","updateBatch","lazyBatch","buildUrl","token","headers","updates","entry","lazyLoads","body","i","responses","lazyResponses","result","networkError","serverPayload","prefix","sendAction","snapshot","method","params","diffs","isolate","createReactiveState","initialState","reactive","updateState","reactiveState","newState","oldJson","newJson","serializeState","stateToRefs","toRefs","getByPath","state","path","parts","current","setByPath","value","topKey","topValue","cloned","part","lastPart","_globalErrorHandler","_componentErrorHandlers","createErrors","setErrors","errors","serverErrors","clearErrors","onError","handler","handleError","componentName","componentId","context","handled","setComponentErrorHandler","removeComponentErrorHandler","_builtInDirectives","addDirective","name","directive","_filters","getBuiltInDirectives","_channels","_subscriptions","_warnedNoEcho","isEchoAvailable","getOrCreateChannel","channelName","type","channel","subscribe","echoConfig","callMethod","subscriptionKeys","config","isPresenceEvent","isCustomEvent","echoChannel","subKey","e","subscribePresenceEvent","eventName","j","unsubscribeSingle","sub","cleanupChannelIfEmpty","unsubscribeComponent","suffix","keysToRemove","_","channelKey","hasSubscriptions","leaveAll","getDebugInfo","toggle","_listeners","on","emit","sourceComponentName","sourceComponentId","target","shouldDeliver","removeByComponentId","processServerEvents","events","evt","updateQueryString","urlParams","usePush","prop","paramName","shouldExclude","buildUploadUrl","uploadFile","file","property","uploadToken","onProgress","formData","xhr","percent","uploadFiles","files","fileArray","piniaSymbol","MutationType","createPinia","scope","effectScope","ref","_p","toBeInstalled","pinia","markRaw","app","plugin","_lazyCounter","unwrapState","flat","val","createLazyComponent","rootComponent","defineComponent","props","ctx","loaded","loadedComponentDef","shallowRef","observer","wrapperEl","loadComponent","mountLoadedContent","memo","createLivueHelper","buildComponentDef","processTemplate","childState","childServerState","childComponentRef","livue","tagName","processed","template","componentDef","newInnerHtml","childProcessed","newTemplate","ct","newComponentDef","listeners","childLivue","eventData","onMounted","entries","onUnmounted","h","_debounceMap","_throttleMap","getDebounced","ms","cacheKey","latestFn","latestResolve","latestReject","debounced","fnToRun","resolveToUse","rejectToUse","getThrottled","lastRun","throttled","now","clearModifiers","CHANNEL_NAME","_tabId","_channel","init","handleMessage","handleStorageEvent","processIncoming","register","unregister","broadcast","properties","message","filterState","filtered","_transitionCounter","isViewTransitionsSupported","transitionState","recountTransitions","transitionDirective","binding","transitionName","newName","withViewTransition","streamTargets","streamRequest","onChunk","onComplete","reader","decoder","buffer","finalResponse","lines","line","applyStreamChunk","parseError","chunk","to","content","replace","registerStreamTarget","targetId","unregisterStreamTarget","isTuple","unwrapComposableData","createComposables","callFn","composablesData","composableActions","namespaces","namespace","actions","unwrappedData","methods","action","ns","act","args","updateComposables","composables","newMemo","newData","unwrapped","hasComposables","_childCounter","_ignoredContent","captureInputValues","inputs","input","index","opt","restoreInputValues","formElements","captureIgnoredContent","container","ignoreId","isSelf","restoreIgnoredContent","preserved","computeDiffs","serverState","currentState","_vueApis","computed","watch","watchEffect","readonly","onBeforeMount","onBeforeUnmount","nextTick","provide","inject","_vueApiNames","_vueApiValues","k","extractSetupScript","code","executeSetupCode","stateRefs","stateKeys","stateValues","paramNames","paramValues","transformVModelModifiers","debouncePattern","timing","msUnit","propName","modifiers","throttlePattern","blurPattern","enterPattern","templateHtml","versions","transformedHtml","extracted","refs","extra","componentRef","initialServerState","initialServerSnapshot","vueMethods","confirms","uploads","tabSync","_skipNextBroadcast","serverSnapshot","handleDownload","download","link","buildPayload","applyResponse","sentDiffs","eb","parsed","transitionOpts","parsedSnap","jsError","serverChangedProps","filteredState","filterTabSyncState","broadcastTabSync","loadingTargets","isActive","paramsOrFirst","doCall","targetName","results","currentValue","existingFiles","newFiles","errorMessages","newVal","oldVal","newServerState","newSnapshot","comp","registerTabSync","incomingState","needsServerRefresh","tempDiv","vTextEls","childDefs","matchedIds","nestedEl","childSnapshotJson","childSnapshot","childMemo","childHtml","existing","regId","reactiveProps","r","isNew","childCleanups","helperResult","childComposables","childErrors","childListeners","childEchoConfig","childId","subscribeEcho","childEl","updatedChildEl","refName","modelProp","islands","LiVueComponent","snapshotJson","self","rootComponentRef","rootProcessed","doSwap","rootServerState","rootComposables","initialErrors","rootListeners","rootLivue","compName","compId","rootDef","createApp","piniaInstance","directives","child","unregisterTabSync","unsubscribeEcho","_initializedComponents","getLivueFromVnode","vnode","initDirective","componentEl","initKey","handlers","submitDirective","observers","intersectDirective","arg","threshold","rootMargin","marginValue","isLeaveMode","hasTriggered","updateCurrent","classes","currentPath","linkPath","isMatch","normalizedCurrent","normalizedLink","classList","c","cls","currentDirective","onUrlChange","cleanup","_ignoreCounter","ignoreDirective","bindings","_modelCounter","getContextFromVnode","parseTimingModifiers","debounceMs","throttleMs","hasDebounce","hasThrottle","timingValue","mod","debounceMatch","throttleMatch","timingMatch","getInputValue","setInputValue","values","isVueComponent","modelDirective","modelId","eventType","updateValue","num","handleValueChange","initialValue","isComponent","componentInstance","keyHandler","stopWatcher","originalEmit","newValue","info","pollState","DEFAULT_INTERVAL","parseInterval","secondsMatch","msMatch","pollDirective","interval","keepAlive","visibleOnly","doPoll","startPoll","handleVisibilityChange","offlineState","_isOnline","initGlobalListeners","offlineDirective","updateElement","isOnline","isOffline","classesToAdd","classesToRemove","_replaceCounter","replaceState","replaceVersions","replaceDirective","replaceId","loadingState","DELAY_PRESETS","DEFAULT_DELAY","parseDelay","applyLoadingState","isLoading","attrName","loadingDirective","display","delay","classOrAttr","targetState","targetDirective","stopWatch","newAction","oldAction","elementState","streamDirective","oldState","newTargetId","_counter","parseTimingMs","defaultMs","clickDirective","uniqueId","timingMs","onceFired","staticMethod","executeCall","methodName","listenerOptions","handlerInfo","outsideHandler","navigateDirective","_scrollCounter","scrollDirective","dirtyState","applyDirtyState","isDirty","dirtyDirective","_bindings","_watchCounter","getContext","instance","internal","setupState","resolvePath","watchDirective","blurHandler","isNativeFormElement","hasVModel","getContextFromBinding","findPropertyName","lowerArg","isNativeInput","findTargetInput","createModelModifierDirective","createHandler","argName","targetEl","debounceDirective","throttleDirective","blurDirective","inputHandler","originalBlurUnmounted","enterDirective","originalEnterUnmounted","booleanDirective","ownKeys","object","enumerableOnly","keys","symbols","sym","_objectSpread2","source","_defineProperty","_typeof","obj","_extends","_objectWithoutPropertiesLoose","excluded","sourceKeys","_objectWithoutProperties","sourceSymbolKeys","version","userAgent","pattern","IE11OrLess","Edge","FireFox","Safari","IOS","ChromeForAndroid","captureMode","off","matches","selector","getParentOrHost","closest","includeCTX","R_SPACE","toggleClass","className","css","matrix","selfOnly","appliedTransforms","transform","matrixFn","find","iterator","list","getWindowScrollingElement","scrollingElement","getRect","relativeToContainingBlock","relativeToNonStaticParent","undoScale","elRect","top","left","bottom","right","height","width","containerRect","elMatrix","scaleX","scaleY","isScrolledPast","elSide","parentSide","getParentAutoScrollElement","elSideVal","parentSideVal","visible","getChild","childNum","includeDragEl","currentChild","children","Sortable","lastChild","last","getRelativeScrollOffset","offsetLeft","offsetTop","winScroller","indexOfObject","arr","includeSelf","elem","gotSelf","elemCSS","extend","dst","isRectEqual","rect1","rect2","_throttleTimeout","throttle","_this","cancelThrottle","scrollBy","x","y","clone","Polymer","$","getChildContainingRectFromElement","ghostEl","rect","_rect$left","_rect$top","_rect$right","_rect$bottom","childRect","expando","AnimationStateManager","animationStates","animationCallbackId","fromRect","childMatrix","animating","animationTime","time","toRect","prevFromRect","prevToRect","animatingRect","targetMatrix","calculateRealTime","currentRect","duration","translateX","translateY","repaint","plugins","defaults","PluginManager","option","p","sortable","eventNameGlobal","pluginName","initialized","modified","eventProperties","modifiedValue","dispatchEvent","_ref","rootEl","cloneEl","toEl","fromEl","oldIndex","newIndex","oldDraggableIndex","newDraggableIndex","originalEvent","putSortable","extraEventProperties","onName","allEventProperties","_excluded","pluginEvent","dragEl","parentEl","nextEl","lastDownEl","cloneHidden","moved","_hideGhostForTarget","_unhideGhostForTarget","_dispatchEvent","activeGroup","awaitingDragStarted","ignoreNextClick","sortables","tapEvt","touchEvt","lastDx","lastDy","tapDistanceLeft","tapDistanceTop","lastTarget","lastDirection","pastFirstInvertThresh","isCircumstantialInvert","targetMoveDistance","ghostRelativeParent","ghostRelativeParentInitialScroll","_silent","savedInputChecked","documentExists","PositionGhostAbsolutely","CSSFloatProperty","supportDraggable","supportCssPointerEvents","_detectDirection","elCSS","elWidth","child1","child2","firstChildCSS","secondChildCSS","firstChildWidth","secondChildWidth","touchingSideChild2","_dragElInRowColumn","dragRect","targetRect","vertical","dragElS1Opp","dragElS2Opp","dragElOppLength","targetS1Opp","targetS2Opp","targetOppLength","_detectNearestEmptySortable","ret","insideHorizontally","insideVertically","_prepareGroup","toFn","pull","from","sameGroup","otherGroup","group","originalGroup","nearestEmptyInsertDetectEvent","nearest","_checkOutsideTargetEl","dataTransfer","preventOnFilter","touch","originalTarget","filter","_saveInputCheckedState","criteria","ownerDocument","dragStartFn","_disableDraggable","_nextTick","fallback","inserted","fallbackTolerance","fallbackOffset","ghostMatrix","relativeScrollOffset","dx","dy","cssMatrix","revert","activeSortable","isOwner","canSort","fromSortable","completedFired","dragOverEvent","completed","after","_onMove","changed","capture","insertion","elLastChild","_ghostIsLast","_ghostIsFirst","firstChild","direction","targetBeforeFirstSwap","differentLevel","differentRowCol","side1","scrolledPastTop","scrollBefore","_getSwapDirection","sibling","dragIndex","nextSibling","moveVector","_unsilent","_cancelNextTick","_globalDragOver","order","_generateId","useAnimation","items","store","willInsertAfter","onMoveFn","retVal","firstElRect","childContainingRect","spacer","lastElRect","swapThreshold","invertedSwapThreshold","invertSwap","isLastTarget","mouseOnAxis","targetLength","targetS1","targetS2","invert","_getInsertDirection","str","sum","root","idx","element","_len","_key","autoScrolls","scrollRootEl","scrolling","lastAutoScrollX","lastAutoScrollY","touchEvt$1","pointerElemChangedInterval","AutoScrollPlugin","AutoScroll","_ref2","clearPointerElemChangedInterval","clearAutoScrolls","autoScroll","ogElemScroller","newElem","isFallback","sens","speed","scrollThisInstance","scrollCustomFn","layersOut","currentParent","canScrollX","canScrollY","scrollWidth","scrollHeight","scrollPosX","scrollPosY","vx","vy","scrollOffsetY","scrollOffsetX","drop","dispatchSortableEvent","hideGhostForTarget","unhideGhostForTarget","toSortable","Revert","_ref3","Remove","_ref4","parentSortable","itemIds","parseAnimation","sortDirective","animation","groupName","currentBinding","isServerMode","item","extraParams","itemEl","itemId","fromList","toList","destMethod","fromListId","sortItemDirective","sortHandleDirective","sortIgnoreDirective","sortGroupDirective","registerBuiltInDirectives","indicatorEl","hideTimeout","isInjected","ensureIndicator","show","fileName","hide","enabled","preserveState","showIndicator","updateCallbacks","setup","runtimeInstance","handleHmrUpdate","indicator.show","savedStates","saveComponentStates","newComponents","newEl","existingEl","restoreComponentStates","states","component","saveComponentState","savedState","oldId","isAvailable","enable","disable","isEnabled","onUpdate","_debugMode","_debugUnsubscribers","LiVueRuntime","hmr.setup","devtools.toggle","configureNavigation","clearNavigationCache","getEchoDebugInfo","first","leaveAllEchoChannels","preserveIds","toDelete","mutations","mutation","node","lazyElements","wrapper","hmr.isAvailable","hmr.isEnabled","hmr.enable","hmr.disable","hmr.configure","hmr.onUpdate","hmr.trigger","hookNames","unsub","logPayload","LiVueRuntime$1","bootLiVue"],"mappings":"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","x_google_ignoreList":[14,40]}